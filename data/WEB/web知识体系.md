---
title: web知识体系
url: 'https://www.yuque.com/zackdk/web/wo972c'
created_at: '2022-09-23 15:16'
updated_at: '2022-09-30 15:35'
hidden: true
isMind: true
---

# web知识图谱

## CSS知识点

- 盒模型
  - 标准盒模型
    - 高版本的浏览器基本上默认都是使用标准盒模型
    - 盒子的 width = content
  - IE盒模型
    - 盒子的 width = content + padding + border
- 选择器
  - 基础选择器
    - 标签选择器
        - h1
    - 类选择器
        - .header
    - ID 选择 器
        - #foot
    - 通配选择器
        - *
  - 属性选择器
    -  [attr]
        - 指定属性的元素
    -  [attr=val]
        - 属性等于指定值的元素
    -  [attr*=val]
        - 属性包含指定值的元素
    -  [attr^=val]
        - 属性以指定值开头的元素
    -  [attr$=val]
        - 属性以指定值结尾的元素
  - 组合选择器
    - A + B
        - 相邻兄弟选择器
    - A ~ B
        - 普通兄弟选择器
    - A > B
        - 子选择器
    - A B
        - 后代选择器
  - 常用伪类选择器
    - :hover
        - 鼠标悬浮的元素
    - :active
        - 鼠标激活的元素
    - :not()
        - 用来匹配不符合一组选择器的元素
    - :nth-child()
        - 元素中指定顺序索引的元素
    - :first-child()
        - 元素中为首的元素
    - :last-child()
        - 元素中为尾的元素
    - :first-letter
        - 元素的首字母
  - 伪元素
    - ::after
        - 在元素后插入内容
    - ::before
        - 在元素前插入内容
  - 选择器优先级
    - !important > 内联样式 > ID选择器 > 类选择器 >标签选择器 > 通配选择器、子代选择器、后代选择器
    - 当这些选择器组合的时候，对应有个数值，可以相加得到权重，通常来说权重高的优先级高一些，但有些情况比较特殊。
- 继承性
  - 默认继承父元素的属性
    - 字体相关
        - font-family、font-style、font-size、font-weight 等
    - 文本相关
        - text-align、text-indent、text-decoration、text-shadow、letter-spacing、word-spacing、white-space、line-height、color 等
    - 列表相关
        - list-style、list-style-image、list-style-type、list-style-position 等
    - 其他属性
        - visibility、cursor 等
  - 可以通过以下几个属性控制继承
    - inherit
        - 继承父元素对应属性的计算值
    - initial
        - 应用该属性的默认值
    - unset
        - 如果属性是默认可以继承的，则取 inherit 的效果，否则同 initial
    - revert
        - 效果等同于 unset，兼容性差
- 格式化上下文
  - BFC (Block Formatting Context)
    - 特性
        - BFC 区域内垂直方向 margin 会合并
        - BFC 的区域不会与 float 盒子重叠(todo 验证)
        - 计算 BFC 的高度时，浮动元素也参与计算
        - BFC 为独立的渲染区域，内外互不影响
    - 触发 BFC
        - 根元素 html
        - float 属性不为 none
        - overflow 不为 visible
        - position 为 absolute 或 fixed
  - IFC (Inline Formatting Context) 
    - 特性
        - 节点无法声明宽高，其中 margin 和 padding 在水平方向有效在垂直方向无效
        - 当一个内联盒子超过父元素的宽度时，它会被分割成多盒子，这些盒子分布在多个 line box 中。如果子元素未设置强制换行的情况下，inline box 将不可被分割，将会溢出父元素
  - FFC (Flex Formatting Context) 
  - GFC (Grid Formatting Context)
- 浮动
  - fixed
    - 脱离文档流，指定元素相对于屏幕视口（viewport）的位置来指定元素位置
    - 当祖先元素里 transform 不为 null 的时候，会相对这个元素进行定位，实际上是因为 生成了新的 Stacking Context
  - absolute
    - 脱离文档流，指定元素相对于最近的非 static 定位祖先元素的偏移
  - relative
    - 不会脱离文档流，相对于原位置进行偏移
  - static
    - 正常文档流，元素默认都是这个值
  - sticky
    - 元素根据正常文档流进行定位，后相对它的*最近滚动祖先，进行定位
- 块状元素的流体性
  - 即默认情况下，块状元素的宽度是会填满父容器的
  - 当有 border margin padding 值时，元素的内容实际宽度会自适应的缩小
## HTML知识点

- 事件流
  - 捕获阶段
    - 事件从 window 开始向下传递直到事件的触发元素
  - 冒泡阶段
    - 事件从触发元素一级级往上传递，直到 window
  - addEventListener
    - 第三个参数控制在那个阶段触发，false 为冒泡 true 为 捕获
  - 阻止事件传递
    - stopPropagation
        - 停止事件的继续传播，无论哪个阶段
    - stopImmediatePropagation
        - 阻止事件冒泡并且阻止相同事件的其他侦听器被调用
  - 阻止默认行为
    - preventDefault
        - 阻止某些控件的默认行为
- 标签元素
## 网络相关

- OSI 标准模型
  - todo
- TCP/IP 协议
  - 通信链路层
  - 网络层
  - 传输层
  - 应用层
- TCP
  - 面向连接
  - 可靠
  - 全双工链接，双方都可以接受和发送
  - 拥塞控制
  - 三次握手/四次挥手
    - 三次握手针对连接，四次挥手针对结束链接（todo）
- UDP
  - 无链接
  - 没有握手过程
- HTTP 协议
  - HTTP/1.0
    - 每个 TCP 连接只能发送一个请求，发送数据完毕，连接就关闭。
  - HTTP/1.1
    - TCP 连接默认不关闭，可以被多个请求复用
    - 管道机制，允许同时发出多个请求，不用排队
    - 增加了多种方法 PUT、PATCH、HEAD、 OPTIONS、DELETE
    - 队头堵塞，服务器要按顺序处理请求，如果前面处理很费时，会造成堵塞
  - HTTP/2
    - 区别于之前文本传输，改为了二进制分帧传输
    - 多路复用/可以发多个请求，被分为多个二进制帧，乱序发送，帧中标识了属于那个请求，服务端收到之后重新组装。避免了队头拥塞。
    - Header 压缩
    - PUSH 机制
  - HTTP/3
    - 采用 QUIC 协议 
    - 底层换成了 UDP 协议
  - HTTPS
    - HTTP + SSL
    - 客户端发送请求，服务端返回证书。客户端验证证书有效性。证书有效，生产随机字符串，用证书上的公钥加密。服务端收到过后用对应的私钥解密。之后的传输过程就用这个随机字符串进行对称加密。
  - 状态码
    - 1xx
        - 信息，服务器收到请求，需要请求者继续执行操作
            - 101 -切换协议
    - 2xx
        - 成功
            - 200 - 请求成功
            - 201 - 创建成功
    - 3xx
        - 重定向，需要进一步的操作以完成请求
            - 301 - 永久重定向
            - 302 - 临时重定向
            - 304 - not modified 资源未修改
    - 4xx
        - 客户端错误
            - 400 - 客户端请求的语法错误，服务器无法理解
            - 401 - 未授权，需要用户登录
            - 403 - 禁止访问
            - 404 - 请求的资源不存在
    - 5xx
        - 服务器内部错误
            - 500 - 服务器内部错误
            - 504 - 网关超时
- DNS
  -  IP 地址一串数字，不方便记忆，就有了域名，并通过域名解析协议（DNS，Domain Name System）来将域名和 IP 地址相互映射，
  - 顶级域名
    - 通用顶级域名 .com/.net
    - 国家顶级域名 .cn/.cc/.io
- MQTT
- WebSocket
  - 长链接，基于 TCP
  - 握手过程采用的 HTTP 协议
  - 可以传输二进制和文本
  - new 一个实例，onOpen、onClose、onMessage 事件
- webrtc
- 强缓存/协商缓存
## React相关

- 合成事件
  - 16.x
    - 事件都挂载在 document 上
    - 拥有事件池，事件对象会被复用
  - 17.x
    - 事件都挂载在 root 节点上
    - 删除事件池
    - 解决了多个 React 版本共存的问题
  - 好处
    - 事件委托到根节点上，避免了添加大量的 listener
    - 抽象了一层自己的事件系统，抹平了浏览器之间的差异
    - 方便迁移在各个平台
- setState
  - 17.X
    - 在 React 事件体系内，多次 setState 都会被 batchUpdate
    - 在 React 事件体系外，诸如请求回调，原生浏览器事件，没有办法进行 batchUpdate，所以 setState 会马上触发 re-render
    - 可以用 React.batchUpdate 手动合并多次 setState
  - 18.X
    - 自动合并多次 setState，无论是在哪里触发的
    - 提供了 ReactDOM.flushSync 来立即触发 re-render
    - root 上对于当前是否正处于更新中，进行了一个标记动作，以此来保障这一批 setState 相关的更新行为处于同一次更新调度中
- diff
  - 优化
    - 两棵树的比对，时间复杂度为O(n^3)
    - 只对比同级元素，时间复杂度降为O(n^2)
    - 同级元素增加 key 属性，唯一标识一个元素，时间复杂度降为O(n)
  - key 在实际场景中理解
    - 实际场景中，就列表中不建议使用 index 作为 key
    - React 靠 元素类型 + key 作为唯一标识一个元素，列表中基本上都是同样的元素类型，如果使用 index 作为 key 。在列表中增删或者移动元素后，顺序就被打乱了，此时某个位置上，元素类型 + key 标识的一个元素，就会被复用，但实际上这个元素可能已经被删除或者移动位置了，UI 就显示错乱了。
- 高阶组件
  - 即接受一个组件，返回一个新组件
  - 一般使用这种方法往组件里注入额外的 props
  - class 组件还能在内部 extends 传入组件，进行某些修改
- 生命周期
  - 挂载时
    - constuctor
    - getDerivedStateFromProps
    - render
    - componentDidMount
  - 更新时
    - getDerivedStateFromProps
    - shouldCompoentUpdate
    - render
    - getSnapshotBeforeUpdate
    - componentDidUpdate
  - 卸载时
    - componetWillUnmount
- hooks
  - 在 hook 之前，函数组件是没有内部状态啊的，只能作为纯展示组件
  - hook 需要放在函数体顶部，不能在任何条件语句前
    - 因为 hook 是以链表形式放在 fiber 上的，如果因为条件语句某个 hook 在一次 render 中不执行，就会打乱链表上 hook 的顺序，与上一次的对应不上，储存的状态就对不上，导致错误
  - 内置 hook 类型
    - useState
    - useEffect
    - useLayoutEffect
    - useMemo
    - useCallback
    - useRef
    - useContext
    - useReducer
    - useImperativeHandle
- fiber
  - 一种数据结构
  - 以链表的形式链接
    - return
    - child
    - sibling
- context
- 受控组件/非受控组件
  - 受控
    - 指表单组件的 value 由 react 的 state 接管
  - 非受控
    - 指表单组件的 value 仍然由 表单自己维护
## Vue 相关

- 响应式系统
  - 2.x
    - Object.defineproperty
  - 3.x
    - Proxy
## 编译相关

- webpack
  - 打包过程
  - loader
  - plugin
  - hash
- esbuild
- rollup
- vite
- babel
## NPM 相关

- 版本
  - semver
  - 各种前缀符号
## JS知识点

- 基础类型
    - 值类型
        - number
        - boolean
        - string
        - null
        - undefined
    - 引用类型
        - object
        - Array
        - Function
        - Date
    - Symbol
    - callback
    - generator
        - 执行器（co）
    - async/await
    - 作用域/作用域链/执行上下文
    - 模块化
    - this指向问题
    - ==和===
    - undefined
- 变量定义
  - var
    - 变量提升，声明会提到顶部，赋值在原处
    - 全局作用域下，会挂在 window 上
  - let
    - ES6 加入，拥有块级作用域，变量值可变
  - const
    - ES6 加入，拥有块级作用域，变量值不可以修改，对象是指对象地址不可修改
- 面向对象
  - ES5
    - new 关键字
        - 新建一个干净对象
        - 把对象关联到构造函数的prototype属性
        - 以新建对象为this执行构造函数
        - 判断构造函数的返回值，对象就返回对象，不是就返回新建对象
    - 继承
        - 原型链继承
            - 将父类的实列对象关联到子类的原型上
                - `Child.prototype = new Parent()`
        - 借用构造函数继承
            - 在子类函数体内，显示改变 this 调用父类构造函数
                - `function Child(){ Parent.call(this) }`
        - 组合继承
            - 原型链 + 借用构造函数
                - `function Child(){ Parent.call(this) }； Child.prototype = new Parent()`
            - 父函数相当于执行了两次，造成了属性浪费
        - 寄生继承
            - 解决属性浪费，直接在子类函数体内，拿到拥有父类原型的空函数生成的对象，把这个对象当作 this 继续执行。 
        - 组合寄生继承
            - 组合 + 寄生继承
                - `function Child(){ Parent.call(this) }; Child.prototype  = Object.create(Parent.prototype);`
  - ES6
    - 新增 class 关键字，依旧使用 new 生成对象实例
    - 新增 extends 关键字，用于继承
        - 继承时，子类必须在 constructor 方法中调用 super 方法，因为子类的 this 要由父类构造而来。
    - 类方法实质上还是定义在 类的 prototype 上
    - 类静态方法实质上定义在类这个对象上，所以 new 生成实例上并不会有这个静态方法，但是静态方法可以被 extends 关键字继承
- 原型链
  - 每个对象都有 prototype
  - prototype 也是一个对象，也拥有 prototype 属性，顶端到 Object.prototype 它的原型指向 null，这样一层套一层就是所谓的原型链
  - 当在对象本身上找不到的属性，会顺着原型链往上查找，直到顶端
- 闭包
  - 函数可以作为变量
    - 自由变量是除参数和函数内部定义的变量之外的变量
    - 词法作用域，自由变量的取值从函数定义时的外部作用域所定
    - 当函数作为变量传递，并不知道会在何处调用，函数内部的自由变量寻址就成为一个问题。
    - JS 里采用词法作用域解决，所以函数需要保留一个定义时外部作用域的引用
    - 这个函数定义时外部作用域的引用+函数本身构成了闭包
  - 应用
    - todo
- 事件循环
  - 浏览器
    - 宏任务
        - script全部代码、setTimeout、setInterval、setImmediate
    - 微任务
        - Promise、MutationObserver
    - 所有宏任务会放进一个队列，先进先出
    - 所有微任务会放进一个队列，先进先出
    - 每当一个宏任务执行完后，会检查微任务队列，如果有值就执行微任务队列，直到微任务队列清空，再去宏任务队列取 Task 继续执行，以此往复。
  - nodejs
- 模块系统
  - AMD（历史产物）
  - UMD（历史产物）
  - commonjs(node)
    - 支持动态导入，引入语句发生在运行时
    - 导入为值拷贝，值可修改
  - esmodule
    - 引入语句发生编译时，方便做一些静态分析
    - 导入为引用值，都是只读，无法直接修改
    - 动态导入
        - import() 返回一个 Promise
    - 支持 tree shaking
## Typescript

- 类型定义
  - interface
  - type
- 边界值
  - any
  - never
  - unkown
- ​
## 浏览器相关

- 同源策略