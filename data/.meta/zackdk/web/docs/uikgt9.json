{
  "id": 1337871,
  "slug": "uikgt9",
  "title": "JavaScript之作用域",
  "book_id": 231593,
  "book": {
    "id": 231593,
    "type": "Book",
    "slug": "web",
    "name": "WEB",
    "user_id": 284138,
    "description": "前端知识点记录",
    "creator_id": 284138,
    "public": 1,
    "items_count": 58,
    "likes_count": 0,
    "watches_count": 3,
    "content_updated_at": "2023-02-02T09:09:21.426Z",
    "updated_at": "2023-02-02T09:09:21.000Z",
    "created_at": "2019-03-07T05:05:08.000Z",
    "namespace": "zackdk/web",
    "user": {
      "id": 284138,
      "type": "User",
      "login": "zackdk",
      "name": "行一度空山",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1551934932702-d412771d-8d33-4694-9186-a749a3b4e05b.jpeg",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 5,
      "following_count": 0,
      "created_at": "2019-03-07T05:02:38.000Z",
      "updated_at": "2023-02-01T12:18:25.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 284138,
  "creator": {
    "id": 284138,
    "type": "User",
    "login": "zackdk",
    "name": "行一度空山",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1551934932702-d412771d-8d33-4694-9186-a749a3b4e05b.jpeg",
    "books_count": 2,
    "public_books_count": 1,
    "followers_count": 5,
    "following_count": 0,
    "created_at": "2019-03-07T05:02:38.000Z",
    "updated_at": "2023-02-01T12:18:25.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "<a name=\"4705b884\"></a>\n## 作用域\n\n作用域（scope），程序设计概念，通常来说，一段程序代码中所用到的名字并不总是有效/可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。（来自百度百科）。\n\n---\n\n<a name=\"74835e2c\"></a>\n## 词法作用域与动态作用域\n\n- 词法作用域，也叫静态作用域（lexical scope），函数的作用域在函数书写的时候就决定了。JavaScript即采用的词法作用域。\n- 动态作用域，是在运行时根据程序的流程信息来动态确定的，即根据程序的调用栈来确定的。\n\n---\n\n\n<a name=\"d5519b00\"></a>\n## JS之词法作用域\n\n先看一个例子\n\n```javascript\nvar a= 1;\n\nfunction foo() {\n    console.log(a);\n}\n\nfunction bar() {\n    var a= 2;\n    foo();\n}\n\nbar();\n\n// 结果是 ???\n```\n\n上面的例子中，先定义变量a，再定义了函数foo，然后是函数bar，并在bar中调用了foo，最后调用bar。\n\n**如果JS是静态作用域**，则foo函数运行时，查找自己内部是否有a变量，没有则向外层查找，此时会找到全局作用域中的a，（注意，并不是从它调用的位置向外去找，而是定义的位置向外去找）然后输出1。\n\n**如果JS是动态作用域**，则foo函数运行时，查找自己内部是否有a变量，没有则向外层查找，此时会找到bar函数中的a，（注意，此时是从调用函数的地方开始向外找）然后输出2。\n\n**bash脚本是采用的动态作用域。**\n\n```bash\n#!/bin/bash\na=1\nfoo(){\n  echo $a\n}\nbar(){\n\ta=2\n  foo\n}\nbar\n```\n\n---\n\n\n<a name=\"3cd1dce8\"></a>\n## 思考题\n\n```javascript\nvar scope = \"global scope\";\nfunction checkscope(){\n    var scope = \"local scope\";\n    function f(){\n        return scope;\n    }\n    return f();\n}\ncheckscope();\n```\n\n```javascript\nvar scope = \"global scope\";\nfunction checkscope(){\n    var scope = \"local scope\";\n    function f(){\n        return scope;\n    }\n    return f;\n}\ncheckscope()();\n```\n\n结果：两段代码都会打印：local scope。\n\n---\n\n\n<a name=\"9fb7988a\"></a>\n## JS无块级作用域\n\n**块级作用域**，任何一对花括号中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。\n\n大多数类c语言都是拥有块级作用域的，比如下面的\n\n```c\n//C语言 \n#include <stdio.h> \nvoid main() \n{ \n    if(1) { \n        int j=3; \n    } \n    printf(\"%d/n\",j); \n}\n```\n\n这段代码会抛出错误：\n\n```c\nerror: use of undeclared identifier 'j'\n```\n\nJavaScript是无块级作用域的，同样的代码如下\n\n```javascript\nif(true) { \n    var j=3; \n} \nconsole.log(j);\n```\n\n是能够正常输出结果的。\n\n再看另一个例子\n\n```javascript\nvar test = 111;\nvar a ={\n\ttest:222,\n\tb:function(){\n\t\tconsole.log(test);\n\t}\n}\na.b()\n```\n\n按照静态作用域来理解的话，b函数定义在a内，b中找不到test变量，则在a中去找，找到222，输出222？\n\n但实际运行时，输出的是111，因为a是一个对象，仅仅是一个变量，不会有作用域，b函数去找test会直接找到全局作用域中的111。\n\nES5中，只有全局作用域，和函数作用域两种。其它都不会产生作用域。\n\nES6中，已经增加块级作用域。使用let定义变量即会有块级作用域。\n\n\n",
  "body_draft": "",
  "body_html": "<!doctype html><h2 id=\"4705b884\">作用域</h2><p><br /></p><p>作用域（scope），程序设计概念，通常来说，一段程序代码中所用到的名字并不总是有效/可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。（来自百度百科）。</p><p><br /></p><hr /><h2 id=\"74835e2c\">词法作用域与动态作用域</h2><p><br /></p><ul><li>词法作用域，也叫静态作用域（lexical scope），函数的作用域在函数书写的时候就决定了。JavaScript即采用的词法作用域。</li></ul><ul><li>动态作用域，是在运行时根据程序的流程信息来动态确定的，即根据程序的调用栈来确定的。</li></ul><p><br /></p><hr /><p><br /></p><h2 id=\"d5519b00\">JS之词法作用域</h2><p><br /></p><p>先看一个例子</p><p><br /></p><pre data-lang=\"javascript\"><code>var a= 1;\n\nfunction foo() {\n    console.log(a);\n}\n\nfunction bar() {\n    var a= 2;\n    foo();\n}\n\nbar();\n\n// 结果是 ???</code></pre><p><br /></p><p>上面的例子中，先定义变量a，再定义了函数foo，然后是函数bar，并在bar中调用了foo，最后调用bar。</p><p><br /></p><p><strong>如果JS是静态作用域</strong>，则foo函数运行时，查找自己内部是否有a变量，没有则向外层查找，此时会找到全局作用域中的a，（注意，并不是从它调用的位置向外去找，而是定义的位置向外去找）然后输出1。</p><p><br /></p><p><strong>如果JS是动态作用域</strong>，则foo函数运行时，查找自己内部是否有a变量，没有则向外层查找，此时会找到bar函数中的a，（注意，此时是从调用函数的地方开始向外找）然后输出2。</p><p><br /></p><p><strong>bash脚本是采用的动态作用域。</strong></p><p><br /></p><pre data-lang=\"bash\"><code>#!/bin/bash\na=1\nfoo(){\n  echo $a\n}\nbar(){\n\ta=2\n  foo\n}\nbar</code></pre><p><br /></p><hr /><p><br /></p><h2 id=\"3cd1dce8\">思考题</h2><p><br /></p><pre data-lang=\"javascript\"><code>var scope = &quot;global scope&quot;;\nfunction checkscope(){\n    var scope = &quot;local scope&quot;;\n    function f(){\n        return scope;\n    }\n    return f();\n}\ncheckscope();</code></pre><p><br /></p><pre data-lang=\"javascript\"><code>var scope = &quot;global scope&quot;;\nfunction checkscope(){\n    var scope = &quot;local scope&quot;;\n    function f(){\n        return scope;\n    }\n    return f;\n}\ncheckscope()();</code></pre><p><br /></p><p>结果：两段代码都会打印：local scope。</p><p><br /></p><hr /><p><br /></p><h2 id=\"9fb7988a\">JS无块级作用域</h2><p><br /></p><p><strong>块级作用域</strong>，任何一对花括号中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。</p><p><br /></p><p>大多数类c语言都是拥有块级作用域的，比如下面的</p><p><br /></p><pre data-lang=\"c\"><code>//C语言 \n#include &lt;stdio.h&gt; \nvoid main() \n{ \n    if(1) { \n        int j=3; \n    } \n    printf(&quot;%d/n&quot;,j); \n}</code></pre><p><br /></p><p>这段代码会抛出错误：</p><p><br /></p><pre data-lang=\"c\"><code>error: use of undeclared identifier 'j'</code></pre><p><br /></p><p>JavaScript是无块级作用域的，同样的代码如下</p><p><br /></p><pre data-lang=\"javascript\"><code>if(true) { \n    var j=3; \n} \nconsole.log(j);</code></pre><p><br /></p><p>是能够正常输出结果的。</p><p><br /></p><p>再看另一个例子</p><p><br /></p><pre data-lang=\"javascript\"><code>var test = 111;\nvar a ={\n\ttest:222,\n\tb:function(){\n\t\tconsole.log(test);\n\t}\n}\na.b()</code></pre><p><br /></p><p>按照静态作用域来理解的话，b函数定义在a内，b中找不到test变量，则在a中去找，找到222，输出222？</p><p><br /></p><p>但实际运行时，输出的是111，因为a是一个对象，仅仅是一个变量，不会有作用域，b函数去找test会直接找到全局作用域中的111。</p><p><br /></p><p>ES5中，只有全局作用域，和函数作用域两种。其它都不会产生作用域。</p><p><br /></p><p>ES6中，已经增加块级作用域。使用let定义变量即会有块级作用域。</p><p><br /></p><p><br /></p>",
  "body_lake": "<!doctype lake><h2 id=\"4705b884\">作用域</h2><p><br /></p><p>作用域（scope），程序设计概念，通常来说，一段程序代码中所用到的名字并不总是有效/可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。（来自百度百科）。</p><p><br /></p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22NWIkt%22%7D\"></card><h2 id=\"74835e2c\">词法作用域与动态作用域</h2><p><br /></p><ul><li>词法作用域，也叫静态作用域（lexical scope），函数的作用域在函数书写的时候就决定了。JavaScript即采用的词法作用域。</li></ul><ul><li>动态作用域，是在运行时根据程序的流程信息来动态确定的，即根据程序的调用栈来确定的。</li></ul><p><br /></p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22CTirg%22%7D\"></card><p><br /></p><h2 id=\"d5519b00\">JS之词法作用域</h2><p><br /></p><p>先看一个例子</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20a%3D%201%3B%5Cn%5Cnfunction%20foo()%20%7B%5Cn%20%20%20%20console.log(a)%3B%5Cn%7D%5Cn%5Cnfunction%20bar()%20%7B%5Cn%20%20%20%20var%20a%3D%202%3B%5Cn%20%20%20%20foo()%3B%5Cn%7D%5Cn%5Cnbar()%3B%5Cn%5Cn%2F%2F%20%E7%BB%93%E6%9E%9C%E6%98%AF%20%3F%3F%3F%22%2C%22id%22%3A%22bMKtN%22%7D\"></card><p><br /></p><p>上面的例子中，先定义变量a，再定义了函数foo，然后是函数bar，并在bar中调用了foo，最后调用bar。</p><p><br /></p><p><strong>如果JS是静态作用域</strong>，则foo函数运行时，查找自己内部是否有a变量，没有则向外层查找，此时会找到全局作用域中的a，（注意，并不是从它调用的位置向外去找，而是定义的位置向外去找）然后输出1。</p><p><br /></p><p><strong>如果JS是动态作用域</strong>，则foo函数运行时，查找自己内部是否有a变量，没有则向外层查找，此时会找到bar函数中的a，（注意，此时是从调用函数的地方开始向外找）然后输出2。</p><p><br /></p><p><anchor /><strong>bash脚本是采用的动态作用域。</strong><focus /></p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22bash%22%2C%22code%22%3A%22%23!%2Fbin%2Fbash%5Cna%3D1%5Cnfoo()%7B%5Cn%20%20echo%20%24a%5Cn%7D%5Cnbar()%7B%5Cn%5Cta%3D2%5Cn%20%20foo%5Cn%7D%5Cnbar%22%2C%22id%22%3A%22nZoCX%22%7D\"></card><p><br /></p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22NugIU%22%7D\"></card><p><br /></p><h2 id=\"3cd1dce8\">思考题</h2><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20scope%20%3D%20%5C%22global%20scope%5C%22%3B%5Cnfunction%20checkscope()%7B%5Cn%20%20%20%20var%20scope%20%3D%20%5C%22local%20scope%5C%22%3B%5Cn%20%20%20%20function%20f()%7B%5Cn%20%20%20%20%20%20%20%20return%20scope%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%20f()%3B%5Cn%7D%5Cncheckscope()%3B%22%2C%22id%22%3A%22NYxxN%22%7D\"></card><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20scope%20%3D%20%5C%22global%20scope%5C%22%3B%5Cnfunction%20checkscope()%7B%5Cn%20%20%20%20var%20scope%20%3D%20%5C%22local%20scope%5C%22%3B%5Cn%20%20%20%20function%20f()%7B%5Cn%20%20%20%20%20%20%20%20return%20scope%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%20f%3B%5Cn%7D%5Cncheckscope()()%3B%22%2C%22id%22%3A%22oRM4R%22%7D\"></card><p><br /></p><p>结果：两段代码都会打印：local scope。</p><p><br /></p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22aY3Ie%22%7D\"></card><p><br /></p><h2 id=\"9fb7988a\">JS无块级作用域</h2><p><br /></p><p><strong>块级作用域</strong>，任何一对花括号中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。</p><p><br /></p><p>大多数类c语言都是拥有块级作用域的，比如下面的</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22c%22%2C%22code%22%3A%22%2F%2FC%E8%AF%AD%E8%A8%80%20%5Cn%23include%20%3Cstdio.h%3E%20%5Cnvoid%20main()%20%5Cn%7B%20%5Cn%20%20%20%20if(1)%20%7B%20%5Cn%20%20%20%20%20%20%20%20int%20j%3D3%3B%20%5Cn%20%20%20%20%7D%20%5Cn%20%20%20%20printf(%5C%22%25d%2Fn%5C%22%2Cj)%3B%20%5Cn%7D%22%2C%22id%22%3A%22qjXAb%22%7D\"></card><p><br /></p><p>这段代码会抛出错误：</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22c%22%2C%22code%22%3A%22error%3A%20use%20of%20undeclared%20identifier%20'j'%22%2C%22id%22%3A%22YDR9R%22%7D\"></card><p><br /></p><p>JavaScript是无块级作用域的，同样的代码如下</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22if(true)%20%7B%20%5Cn%20%20%20%20var%20j%3D3%3B%20%5Cn%7D%20%5Cnconsole.log(j)%3B%22%2C%22id%22%3A%22UD75T%22%7D\"></card><p><br /></p><p>是能够正常输出结果的。</p><p><br /></p><p>再看另一个例子</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20test%20%3D%20111%3B%5Cnvar%20a%20%3D%7B%5Cn%5Cttest%3A222%2C%5Cn%5Ctb%3Afunction()%7B%5Cn%5Ct%5Ctconsole.log(test)%3B%5Cn%5Ct%7D%5Cn%7D%5Cna.b()%22%2C%22id%22%3A%228NHPo%22%7D\"></card><p><br /></p><p>按照静态作用域来理解的话，b函数定义在a内，b中找不到test变量，则在a中去找，找到222，输出222？</p><p><br /></p><p>但实际运行时，输出的是111，因为a是一个对象，仅仅是一个变量，不会有作用域，b函数去找test会直接找到全局作用域中的111。</p><p><br /></p><p>ES5中，只有全局作用域，和函数作用域两种。其它都不会产生作用域。</p><p><br /></p><p>ES6中，已经增加块级作用域。使用let定义变量即会有块级作用域。</p><p><br /></p><p><br /></p>",
  "body_draft_lake": "",
  "public": 1,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2019-07-25T04:42:01.000Z",
  "deleted_at": null,
  "created_at": "2019-03-07T06:37:39.000Z",
  "updated_at": "2023-02-02T09:07:59.000Z",
  "published_at": "2019-07-25T04:42:01.000Z",
  "first_published_at": "2019-03-07T06:56:28.000Z",
  "word_count": 784,
  "cover": null,
  "description": "作用域作用域（scope），程序设计概念，通常来说，一段程序代码中所用到的名字并不总是有效/可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。（来自百度百科）。词法作用域与动态作用域词法作用域，也叫静态作用域（lexical scope），函数的作用域在函数书写的时候就决定了。Ja...",
  "custom_description": null,
  "hits": 49,
  "_serializer": "v2.doc_detail"
}