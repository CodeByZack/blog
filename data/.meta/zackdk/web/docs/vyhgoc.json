{
  "id": 1845777,
  "slug": "vyhgoc",
  "title": "JS中Promise的使用问题",
  "book_id": 231593,
  "book": {
    "id": 231593,
    "type": "Book",
    "slug": "web",
    "name": "WEB",
    "user_id": 284138,
    "description": "前端知识点记录",
    "creator_id": 284138,
    "public": 1,
    "items_count": 58,
    "likes_count": 0,
    "watches_count": 3,
    "content_updated_at": "2023-02-02T09:09:21.426Z",
    "updated_at": "2023-02-02T09:09:21.000Z",
    "created_at": "2019-03-07T05:05:08.000Z",
    "namespace": "zackdk/web",
    "user": {
      "id": 284138,
      "type": "User",
      "login": "zackdk",
      "name": "行一度空山",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1551934932702-d412771d-8d33-4694-9186-a749a3b4e05b.jpeg",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 5,
      "following_count": 0,
      "created_at": "2019-03-07T05:02:38.000Z",
      "updated_at": "2023-02-01T12:18:25.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 284138,
  "creator": {
    "id": 284138,
    "type": "User",
    "login": "zackdk",
    "name": "行一度空山",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1551934932702-d412771d-8d33-4694-9186-a749a3b4e05b.jpeg",
    "books_count": 2,
    "public_books_count": 1,
    "followers_count": 5,
    "following_count": 0,
    "created_at": "2019-03-07T05:02:38.000Z",
    "updated_at": "2023-02-01T12:18:25.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "这里只是记录对promise的一些疑惑点，不会具体说promise是什么东西，或者怎么使用。\n\n<a name=\"Qhswp\"></a>\n## Promise的then的两个参数。\nthen有两个入参，为两个函数，如果你传其它类型的值进去，会被忽略掉。<br />比如 `promise.then(1,2)`<br />其实等同于`promise.then()`\n\n第一个函数为reslove状态下的callback，参数为reslove的值<br />比如 `Promise.reslove(333).then(res=>console.log(res))`<br />其中res的值就为333\n\n第二个函数为 reject状态下的callback，参数为错误信息对象<br />比如 `Promise.reject(111).then(()=>{},err=>console.log(err))`<br />其中err的值为111<br />另外，除了在promise内部reject值以外，当promise内部发生语法错误，或者主动抛出了错误，都会被reject捕捉到，当作callback下的入参。\n\n\n```javascript\nvar promiseA = new Promise((reslove,reject)=>{\n\treslove(\"这个是正常返回的结果\")\n})\n\nvar promiseB = new Promise((reslove,reject)=>{\n\treject(\"这个是出错返回的结果\")\n})\n\nvar promiseC = new Promise((reslove,reject)=>{\n\tdodo(\"这里会产生语法错误\")\n})\n\npromiseA.then(res=>console.log(res))//这个是正常返回的结果\npromiseB.then(1,err=>console.log(err))//这个是出错返回的结果\npromiseC.then(1,err=>console.log(err))//ReferenceError: dodo is not defined\n```\n\n\n<a name=\"YPMDr\"></a>\n## Promise的then的返回值。\n\n说到底，then是一个函数，那就会有返回值，且then的返回值固定为promise对象，以便链式调用。<br />而then的返回值，取决于实际上调用了那个callback。具体一点来说，\n\n当调用了resolve状态下的callback，then的返回值就取决于resolve状态下的callback的返回值。<br />当调用了reject状态下的callback，then的返回值就取决于reject状态下的callback的返回值。\n\n**如果没有走任何callback，then的返回值为原promise。**<br />即`promiseA.then()`的返回值为promiseA\n\n无论那种状态下，对callback的返回值处理规则都是一样的,下面统一使用resolve的callback。\n\n**1.返回一个promise，那么then的返回值就是这个promise。**<br />如：`promiseA.then(res=>Promise.resolve(\"resolve\"))`<br />如：`promiseA.then(res=>Promise.reject(\"reject\"))`<br />如：`promiseA.then(res=>new Promise())`\n\n**2.返回一个对象obj，那么then的返回值为Promise.resolve(obj)。**<br />即你返回一个非promise值，then会帮你把该值包装为一个promise，且状态为resolve。\n\n如：`promiseA.then(res=>123)`<br />返回值为 Promise.resolve(123)<br />如：`promiseA.then(res=>{key:\"123\"})`<br />返回值为 Promise.resolve({key:\"123\"})\n\n**3.没有显示返回值，那么then的返回值为Promise.resolve(undefined)**<br />如：promiseA.then(res=>{})\n\n返回值为 Promise.resolve(**undefined**)\n\n```javascript\nvar promiseA = new Promise((reslove,reject)=>{\n\treslove(\"这个是正常返回的结果\")\n})\n\nvar resPromise = promiseA.then()\n\nvar resPromise1 = promiseA.then(res=>{})\n\nvar resPromise2 = promiseA.then(res=>123)\n\nvar resPromise3 = promiseA.then(res=>({key:123}))\n\nvar resPromise4 = promiseA.then(res=>Promise.resolve(\"resolve\"))\n\nvar resPromise5 = promiseA.then(res=>Promise.reject(\"reject\"))\n\nsetTimeout(()=>{\n  console.log( resPromise )\n  console.log( resPromise1 )\n  console.log( resPromise2 )\n  console.log( resPromise3 )\n  console.log( resPromise4 )\n  console.log( resPromise5 )\n},0)\n\n//这里解释一下，为什么需要用setTimeout来打印结果\n//因为then同步返回的是一个新生成的promise,是pending状态。\n//对于这个新的promise的状态改变,是异步的。\n//也就是根据callback的返回值来确定新生成的promise的状态这个操作，是下一个tick才会去做。\n//我也是写这个例子的时候才发现这个问题，但是不想改前面的了。\n//正确说法请参考MDN相关章节\n```\n\nMDN Promise then[链接](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/then)\n\n<a name=\"mq8vH\"></a>\n## Promise的catch。\n\ncatch也是设计来捕捉错误的，reject，或者语法错误，或者主动抛出的错误,和then的第二个函数作用一样。\n\n所以这两个是有冲突的，如果promise是reject状态，当既有then(,()=>{})又有catch的时候，catch是执行不到的。\n\ncatch也会返回一个新的promise，规则同上面所说的。\n\n```javascript\nvar promiseB = new Promise((reslove,reject)=>{\n\treject(\"这个是出错返回的结果\")\n})\n\npromiseB\n  .then(1,(err)=>{console.log(\"then\")})\n  .catch(err=>{console.log(\"catch\")})\n```\n\n",
  "body_draft": "",
  "body_html": "<!doctype html><p>这里只是记录对promise的一些疑惑点，不会具体说promise是什么东西，或者怎么使用。</p><p><br /></p><h2 id=\"Qhswp\">Promise的then的两个参数。</h2><p>then有两个入参，为两个函数，如果你传其它类型的值进去，会被忽略掉。</p><p>比如 <code>promise.then(1,2)</code></p><p>其实等同于<code>promise.then()</code></p><p><br /></p><p>第一个函数为reslove状态下的callback，参数为reslove的值</p><p>比如 <code>Promise.reslove(333).then(res=&gt;console.log(res))</code></p><p>其中res的值就为333</p><p><br /></p><p>第二个函数为 reject状态下的callback，参数为错误信息对象</p><p><span>比如 </span><code>Promise.reject(111).then(()=&gt;{},err=&gt;console.log(err))</code></p><p>其中err的值为111</p><p>另外，除了在promise内部reject值以外，当promise内部发生语法错误，或者主动抛出了错误，都会被reject捕捉到，当作callback下的入参。</p><p><br /></p><p><br /></p><pre data-lang=\"javascript\"><code>var promiseA = new Promise((reslove,reject)=&gt;{\n\treslove(&quot;这个是正常返回的结果&quot;)\n})\n\nvar promiseB = new Promise((reslove,reject)=&gt;{\n\treject(&quot;这个是出错返回的结果&quot;)\n})\n\nvar promiseC = new Promise((reslove,reject)=&gt;{\n\tdodo(&quot;这里会产生语法错误&quot;)\n})\n\npromiseA.then(res=&gt;console.log(res))//这个是正常返回的结果\npromiseB.then(1,err=&gt;console.log(err))//这个是出错返回的结果\npromiseC.then(1,err=&gt;console.log(err))//ReferenceError: dodo is not defined</code></pre><p><br /></p><p><br /></p><h2 id=\"YPMDr\">Promise的then的返回值。</h2><p><br /></p><p>说到底，then是一个函数，那就会有返回值，且then的返回值固定为promise对象，以便链式调用。</p><p>而then的返回值，取决于实际上调用了那个callback。具体一点来说，</p><p><br /></p><p>当调用了resolve状态下的callback，then的返回值就取决于<span>resolve状态下的callback</span>的返回值。</p><p><span>当调用了reject状态下的callback，then的返回值就取决于</span><span>reject状态下的callback</span><span>的返回值。</span></p><p><br /></p><p><strong>如果没有走任何callback，then的返回值为原promise。</strong></p><p>即<code>promiseA.then()</code>的返回值为promiseA</p><p><br /></p><p>无论那种状态下，对callback的返回值处理规则都是一样的,下面统一使用resolve的callback。</p><p><br /></p><p><strong>1.返回一个promise，那么then的返回值就是这个promise。</strong></p><p>如：<code>promiseA.then(res=&gt;Promise.resolve(&quot;resolve&quot;))</code></p><p>如：<code>promiseA.then(res=&gt;Promise.reject(&quot;reject&quot;))</code></p><p>如：<code>promiseA.then(res=&gt;new Promise())</code></p><p><br /></p><p><strong>2.返回一个对象obj，那么then的返回值为Promise.resolve(obj)。</strong></p><p><span style=\"color: #000000;\"><u>即你返回一个非promise值，then会帮你把该值包装为一个promise，且状态为resolve。</u></span><br /></p><p><span>如：</span><code>promiseA.then(res=&gt;123)</code></p><p>返回值为 Promise.resolve(123)</p><p><span>如：</span><code>promiseA.then(res=&gt;{key:&quot;123&quot;})</code></p><p>返回值为 Promise.resolve({key:&quot;123&quot;})</p><p><br /></p><p><strong>3.没有显示返回值，那么then的返回值为Promise.resolve(undefined)</strong></p><p>如：<span style=\"background-color: \"rgba(0, 0, 0, 0.06)\";\">promiseA.then(res=&gt;{})</span><br /></p><p><span>返回值为 Promise.resolve(</span><strong>undefined</strong><span>)</span></p><p><span><br /></span></p><pre data-lang=\"javascript\"><code>var promiseA = new Promise((reslove,reject)=&gt;{\n\treslove(&quot;这个是正常返回的结果&quot;)\n})\n\nvar resPromise = promiseA.then()\n\nvar resPromise1 = promiseA.then(res=&gt;{})\n\nvar resPromise2 = promiseA.then(res=&gt;123)\n\nvar resPromise3 = promiseA.then(res=&gt;({key:123}))\n\nvar resPromise4 = promiseA.then(res=&gt;Promise.resolve(&quot;resolve&quot;))\n\nvar resPromise5 = promiseA.then(res=&gt;Promise.reject(&quot;reject&quot;))\n\nsetTimeout(()=&gt;{\n  console.log( resPromise )\n  console.log( resPromise1 )\n  console.log( resPromise2 )\n  console.log( resPromise3 )\n  console.log( resPromise4 )\n  console.log( resPromise5 )\n},0)\n\n//这里解释一下，为什么需要用setTimeout来打印结果\n//因为then同步返回的是一个新生成的promise,是pending状态。\n//对于这个新的promise的状态改变,是异步的。\n//也就是根据callback的返回值来确定新生成的promise的状态这个操作，是下一个tick才会去做。\n//我也是写这个例子的时候才发现这个问题，但是不想改前面的了。\n//正确说法请参考MDN相关章节</code></pre><p><br /></p><p>MDN Promise then<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/then\" target=\"_blank\">链接</a></p><p><br /></p><h2 id=\"mq8vH\">Promise的catch。</h2><p><br /></p><p>catch也是设计来捕捉错误的，reject，或者语法错误，或者主动抛出的错误,和then的第二个函数作用一样。</p><p><br /></p><p>所以这两个是有冲突的，如果promise是reject状态，当既有then(,()=&gt;{})又有catch的时候，catch是执行不到的。</p><p><br /></p><p>catch也会返回一个新的promise，规则同上面所说的。</p><p><br /></p><pre data-lang=\"javascript\"><code>var promiseB = new Promise((reslove,reject)=&gt;{\n\treject(&quot;这个是出错返回的结果&quot;)\n})\n\npromiseB\n  .then(1,(err)=&gt;{console.log(&quot;then&quot;)})\n  .catch(err=&gt;{console.log(&quot;catch&quot;)})</code></pre><p><br /></p>",
  "body_lake": "<!doctype lake><p>这里只是记录对promise的一些疑惑点，不会具体说promise是什么东西，或者怎么使用。</p><p><br /></p><h2 id=\"Qhswp\">Promise的then的两个参数。</h2><p>then有两个入参，为两个函数，如果你传其它类型的值进去，会被忽略掉。</p><p>比如 <code>promise.then(1,2)</code></p><p>其实等同于<code>promise.then()</code></p><p><br /></p><p>第一个函数为reslove状态下的callback，参数为reslove的值</p><p>比如 <code>Promise.reslove(333).then(res=&gt;console.log(res))</code></p><p>其中res的值就为333</p><p><br /></p><p>第二个函数为 reject状态下的callback，参数为错误信息对象</p><p><span>比如 </span><code>Promise.reject(111).then(()=&gt;{},err=&gt;console.log(err))</code></p><p>其中err的值为111</p><p>另外，除了在promise内部reject值以外，当promise内部发生语法错误，或者主动抛出了错误，都会被reject捕捉到，当作callback下的入参。</p><p><br /></p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20promiseA%20%3D%20new%20Promise((reslove%2Creject)%3D%3E%7B%5Cn%5Ctreslove(%5C%22%E8%BF%99%E4%B8%AA%E6%98%AF%E6%AD%A3%E5%B8%B8%E8%BF%94%E5%9B%9E%E7%9A%84%E7%BB%93%E6%9E%9C%5C%22)%5Cn%7D)%5Cn%5Cnvar%20promiseB%20%3D%20new%20Promise((reslove%2Creject)%3D%3E%7B%5Cn%5Ctreject(%5C%22%E8%BF%99%E4%B8%AA%E6%98%AF%E5%87%BA%E9%94%99%E8%BF%94%E5%9B%9E%E7%9A%84%E7%BB%93%E6%9E%9C%5C%22)%5Cn%7D)%5Cn%5Cnvar%20promiseC%20%3D%20new%20Promise((reslove%2Creject)%3D%3E%7B%5Cn%5Ctdodo(%5C%22%E8%BF%99%E9%87%8C%E4%BC%9A%E4%BA%A7%E7%94%9F%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF%5C%22)%5Cn%7D)%5Cn%5CnpromiseA.then(res%3D%3Econsole.log(res))%2F%2F%E8%BF%99%E4%B8%AA%E6%98%AF%E6%AD%A3%E5%B8%B8%E8%BF%94%E5%9B%9E%E7%9A%84%E7%BB%93%E6%9E%9C%5CnpromiseB.then(1%2Cerr%3D%3Econsole.log(err))%2F%2F%E8%BF%99%E4%B8%AA%E6%98%AF%E5%87%BA%E9%94%99%E8%BF%94%E5%9B%9E%E7%9A%84%E7%BB%93%E6%9E%9C%5CnpromiseC.then(1%2Cerr%3D%3Econsole.log(err))%2F%2FReferenceError%3A%20dodo%20is%20not%20defined%22%2C%22id%22%3A%22rqjiq%22%7D\"></card><p><br /></p><p><br /></p><h2 id=\"YPMDr\">Promise的then的返回值。</h2><p><br /></p><p>说到底，then是一个函数，那就会有返回值，且then的返回值固定为promise对象，以便链式调用。</p><p>而then的返回值，取决于实际上调用了那个callback。具体一点来说，</p><p><br /></p><p>当调用了resolve状态下的callback，then的返回值就取决于<span>resolve状态下的callback</span>的返回值。</p><p><span>当调用了reject状态下的callback，then的返回值就取决于</span><span>reject状态下的callback</span><span>的返回值。</span></p><p><br /></p><p><strong>如果没有走任何callback，then的返回值为原promise。</strong></p><p>即<code>promiseA.then()</code>的返回值为promiseA</p><p><br /></p><p>无论那种状态下，对callback的返回值处理规则都是一样的,下面统一使用resolve的callback。</p><p><br /></p><p><strong>1.返回一个promise，那么then的返回值就是这个promise。</strong></p><p>如：<code>promiseA.then(res=&gt;Promise.resolve(&quot;resolve&quot;))</code></p><p>如：<code>promiseA.then(res=&gt;Promise.reject(&quot;reject&quot;))</code></p><p>如：<code>promiseA.then(res=&gt;new Promise())</code></p><p><br /></p><p><strong>2.返回一个对象obj，那么then的返回值为Promise.resolve(obj)。</strong></p><p><span style=\"color: #000000;\"><u>即你返回一个非promise值，then会帮你把该值包装为一个promise，且状态为resolve。</u></span><br /></p><p><span>如：</span><code>promiseA.then(res=&gt;123)</code></p><p>返回值为 Promise.resolve(123)</p><p><span>如：</span><code>promiseA.then(res=&gt;{key:&quot;123&quot;})</code></p><p>返回值为 Promise.resolve({key:&quot;123&quot;})</p><p><br /></p><p><strong>3.没有显示返回值，那么then的返回值为Promise.resolve(undefined)</strong></p><p>如：<span style=\"background-color: rgba(0, 0, 0, 0.06);\">promiseA.then(res=&gt;{})</span><br /></p><p><span>返回值为 Promise.resolve(</span><strong>undefined</strong><span>)</span></p><p><span><br /></span></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20promiseA%20%3D%20new%20Promise((reslove%2Creject)%3D%3E%7B%5Cn%5Ctreslove(%5C%22%E8%BF%99%E4%B8%AA%E6%98%AF%E6%AD%A3%E5%B8%B8%E8%BF%94%E5%9B%9E%E7%9A%84%E7%BB%93%E6%9E%9C%5C%22)%5Cn%7D)%5Cn%5Cnvar%20resPromise%20%3D%20promiseA.then()%5Cn%5Cnvar%20resPromise1%20%3D%20promiseA.then(res%3D%3E%7B%7D)%5Cn%5Cnvar%20resPromise2%20%3D%20promiseA.then(res%3D%3E123)%5Cn%5Cnvar%20resPromise3%20%3D%20promiseA.then(res%3D%3E(%7Bkey%3A123%7D))%5Cn%5Cnvar%20resPromise4%20%3D%20promiseA.then(res%3D%3EPromise.resolve(%5C%22resolve%5C%22))%5Cn%5Cnvar%20resPromise5%20%3D%20promiseA.then(res%3D%3EPromise.reject(%5C%22reject%5C%22))%5Cn%5CnsetTimeout(()%3D%3E%7B%5Cn%20%20console.log(%20resPromise%20)%5Cn%20%20console.log(%20resPromise1%20)%5Cn%20%20console.log(%20resPromise2%20)%5Cn%20%20console.log(%20resPromise3%20)%5Cn%20%20console.log(%20resPromise4%20)%5Cn%20%20console.log(%20resPromise5%20)%5Cn%7D%2C0)%5Cn%5Cn%2F%2F%E8%BF%99%E9%87%8C%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%94%A8setTimeout%E6%9D%A5%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%9C%5Cn%2F%2F%E5%9B%A0%E4%B8%BAthen%E5%90%8C%E6%AD%A5%E8%BF%94%E5%9B%9E%E7%9A%84%E6%98%AF%E4%B8%80%E4%B8%AA%E6%96%B0%E7%94%9F%E6%88%90%E7%9A%84promise%2C%E6%98%AFpending%E7%8A%B6%E6%80%81%E3%80%82%5Cn%2F%2F%E5%AF%B9%E4%BA%8E%E8%BF%99%E4%B8%AA%E6%96%B0%E7%9A%84promise%E7%9A%84%E7%8A%B6%E6%80%81%E6%94%B9%E5%8F%98%2C%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84%E3%80%82%5Cn%2F%2F%E4%B9%9F%E5%B0%B1%E6%98%AF%E6%A0%B9%E6%8D%AEcallback%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E6%9D%A5%E7%A1%AE%E5%AE%9A%E6%96%B0%E7%94%9F%E6%88%90%E7%9A%84promise%E7%9A%84%E7%8A%B6%E6%80%81%E8%BF%99%E4%B8%AA%E6%93%8D%E4%BD%9C%EF%BC%8C%E6%98%AF%E4%B8%8B%E4%B8%80%E4%B8%AAtick%E6%89%8D%E4%BC%9A%E5%8E%BB%E5%81%9A%E3%80%82%5Cn%2F%2F%E6%88%91%E4%B9%9F%E6%98%AF%E5%86%99%E8%BF%99%E4%B8%AA%E4%BE%8B%E5%AD%90%E7%9A%84%E6%97%B6%E5%80%99%E6%89%8D%E5%8F%91%E7%8E%B0%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%8C%E4%BD%86%E6%98%AF%E4%B8%8D%E6%83%B3%E6%94%B9%E5%89%8D%E9%9D%A2%E7%9A%84%E4%BA%86%E3%80%82%5Cn%2F%2F%E6%AD%A3%E7%A1%AE%E8%AF%B4%E6%B3%95%E8%AF%B7%E5%8F%82%E8%80%83MDN%E7%9B%B8%E5%85%B3%E7%AB%A0%E8%8A%82%22%2C%22id%22%3A%22ePQoJ%22%7D\"></card><p><br /></p><p>MDN Promise then<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/then\" target=\"_blank\">链接</a></p><p><br /></p><h2 id=\"mq8vH\">Promise的catch。</h2><p><br /></p><p>catch也是设计来捕捉错误的，reject，或者语法错误，或者主动抛出的错误,和then的第二个函数作用一样。</p><p><br /></p><p>所以这两个是有冲突的，如果promise是reject状态，当既有then(,()=&gt;{})又有catch的时候，catch是执行不到的。</p><p><br /></p><p>catch也会返回一个新的promise，规则同上面所说的。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20promiseB%20%3D%20new%20Promise((reslove%2Creject)%3D%3E%7B%5Cn%5Ctreject(%5C%22%E8%BF%99%E4%B8%AA%E6%98%AF%E5%87%BA%E9%94%99%E8%BF%94%E5%9B%9E%E7%9A%84%E7%BB%93%E6%9E%9C%5C%22)%5Cn%7D)%5Cn%5CnpromiseB%5Cn%20%20.then(1%2C(err)%3D%3E%7Bconsole.log(%5C%22then%5C%22)%7D)%5Cn%20%20.catch(err%3D%3E%7Bconsole.log(%5C%22catch%5C%22)%7D)%22%2C%22id%22%3A%22xz0Zo%22%7D\"></card><p><br /></p>",
  "body_draft_lake": "",
  "public": 1,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2019-06-04T05:30:32.000Z",
  "deleted_at": null,
  "created_at": "2019-06-04T00:45:10.000Z",
  "updated_at": "2023-02-02T09:07:58.000Z",
  "published_at": "2019-06-04T05:30:32.000Z",
  "first_published_at": "2019-06-04T05:30:32.000Z",
  "word_count": 1015,
  "cover": null,
  "description": "这里只是记录对promise的一些疑惑点，不会具体说promise是什么东西，或者怎么使用。Promise的then的两个参数。then有两个入参，为两个函数，如果你传其它类型的值进去，会被忽略掉。比如 promise.then(1,2)其实等同于promise.then()第一个函数为res...",
  "custom_description": null,
  "hits": 26,
  "_serializer": "v2.doc_detail"
}