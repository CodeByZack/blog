{
  "id": 1337377,
  "slug": "ldkedk",
  "title": "ES6之let const",
  "book_id": 231593,
  "book": {
    "id": 231593,
    "type": "Book",
    "slug": "web",
    "name": "WEB",
    "user_id": 284138,
    "description": "前端知识点记录",
    "creator_id": 284138,
    "public": 1,
    "items_count": 58,
    "likes_count": 0,
    "watches_count": 3,
    "content_updated_at": "2023-02-02T09:09:21.426Z",
    "updated_at": "2023-02-02T09:09:21.000Z",
    "created_at": "2019-03-07T05:05:08.000Z",
    "namespace": "zackdk/web",
    "user": {
      "id": 284138,
      "type": "User",
      "login": "zackdk",
      "name": "行一度空山",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1551934932702-d412771d-8d33-4694-9186-a749a3b4e05b.jpeg",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 5,
      "following_count": 0,
      "created_at": "2019-03-07T05:02:38.000Z",
      "updated_at": "2023-02-01T12:18:25.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 284138,
  "creator": {
    "id": 284138,
    "type": "User",
    "login": "zackdk",
    "name": "行一度空山",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1551934932702-d412771d-8d33-4694-9186-a749a3b4e05b.jpeg",
    "books_count": 2,
    "public_books_count": 1,
    "followers_count": 5,
    "following_count": 0,
    "created_at": "2019-03-07T05:02:38.000Z",
    "updated_at": "2023-02-01T12:18:25.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "在ES6之前，js只有全局作用域和函数作用域，声明变量一般用var，否则就是全局变量。<br />ES6，新增了块级作用域，声明变量多了两个关键字let,const。\n<a name=\"0665242f\"></a>\n## 块级作用域\n\n对于从安卓转到前端的我来说，ES5没有块级作用域，还是很容易造成代码理解的错误的。\n\n```javascript\nfor(var i=0;i<10;i++){\n    //do something...\n}\n\nconsole.log(i);//   10\n```\n\n按照java的习惯，i 变量应该是只在for代码块里生效的。但是js里，这样声明的 i 就是全局变量。这就是因为js没有块级作用域。\n\nES6新增了块级作用域。既let,const,让{ }之间拥有了块级作用域。\n\n```javascript\n{\n    let t = 0;\n}\n\nconsole.log(t); //Uncaught ReferenceError\n\nfor(let i=0;i<10;i++){\n    //do something...\n}\n\nconsole.log(i); //Uncaught ReferenceError\n```\n\n<a name=\"f93ec1d0\"></a>\n## let关键字\n\n<a name=\"704f29e0\"></a>\n### 基本用法\n\n```javascript\n{\n    let t = 0;\n    var m = 1; \n}\n\nconsole.log(t); //Uncaught ReferenceError\nconsole.log(m); //1\n```\n\n上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。\n\n<a name=\"5625aedb\"></a>\n### 不存在变量提升\n\nlet不像var那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。\n\n```javascript\nconsole.log(foo); // 输出undefined\nconsole.log(bar); // 报错ReferenceError\n\nvar foo = 2;\nlet bar = 2;\n```\n\n上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误，所以使用let请先声明，后使用。\n\n<a name=\"45a566a3\"></a>\n### 暂时性死区（temporal dead zone）\n\n只要块级作用域内存在let命令，它所声明的变量在声明之前都是不可用的，即使全局变量中存在同名变量。\n\n```javascript\nvar tmp = 111；\n\nif (true) {\n  // TDZ开始\n  tmp = 'abc'; // ReferenceError\n  console.log(tmp); // ReferenceError\n\n  let tmp; // TDZ结束\n  console.log(tmp); // undefined\n\n  tmp = 123;\n  console.log(tmp); // 123\n}\n```\n\n上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。\n\nES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。\n\n总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。\n\n<a name=\"dccd9155\"></a>\n### 不允许重复声明\n\nlet不允许在相同作用域内，重复声明同一个变量。\n\n```javascript\n// 报错\nfunction () {\n  let a = 10;\n  var a = 1;\n}\n\n// 报错\nfunction () {\n  let a = 10;\n  let a = 1;\n}\n```\n\n因此，不能在函数内部重新声明参数。\n\n```javascript\nfunction func(arg) {\n  let arg; // 报错\n}\n\nfunction func(arg) {\n  {\n    let arg; // 不报错\n  }\n}\n```\n\n<a name=\"27fce117\"></a>\n## const关键字\n\nconst特性与let基本一致。\n\nconst声明一个只读的常量。一旦声明，常量的值就不能改变。\n\n```javascript\nconst PI = 3.1415;\nPI // 3.1415\n\nPI = 3;\n// TypeError: Assignment to constant variable.\n```\n\n上面代码表明改变常量的值会报错。\n\nconst声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。\n\n```javascript\nconst a = 1;\na // 1\n\na = 3;\n// TypeError: Assignment to constant variable.\n\n\nconst b = { a:1,c:2 };\nb //  { a:1,c:2 }\n\nb = {};\n// TypeError: Assignment to constant variable.\n\nb.a = 3;\n\nb.c =12;\n\nb //  { a:3,c:12 }\n```\n\njs的变量可以分为两类，值类型，引用类型。\n\n引用类型，变量其实储存的可以理解为一个内存地址，真正的内容储存在内存地址所指向的内存。\n\nconst修饰引用类型时，const只是限制了引用的地址不能改变，并不会限制地址指向的内容不改变。\n\n",
  "body_draft": "",
  "body_html": "<!doctype html><p>在ES6之前，js只有全局作用域和函数作用域，声明变量一般用var，否则就是全局变量。</p><p>ES6，新增了块级作用域，声明变量多了两个关键字let,const。</p><h2 id=\"0665242f\">块级作用域</h2><p><br /></p><p>对于从安卓转到前端的我来说，ES5没有块级作用域，还是很容易造成代码理解的错误的。</p><p><br /></p><pre data-lang=\"javascript\"><code>for(var i=0;i&lt;10;i++){\n    //do something...\n}\n\nconsole.log(i);//   10</code></pre><p><br /></p><p>按照java的习惯，i 变量应该是只在for代码块里生效的。但是js里，这样声明的 i 就是全局变量。这就是因为js没有块级作用域。</p><p><br /></p><p>ES6新增了块级作用域。既let,const,让{ }之间拥有了块级作用域。</p><p><br /></p><pre data-lang=\"javascript\"><code>{\n    let t = 0;\n}\n\nconsole.log(t); //Uncaught ReferenceError\n\nfor(let i=0;i&lt;10;i++){\n    //do something...\n}\n\nconsole.log(i); //Uncaught ReferenceError</code></pre><p><br /></p><h2 id=\"f93ec1d0\">let关键字</h2><p><br /></p><h3 id=\"704f29e0\">基本用法</h3><p><br /></p><pre data-lang=\"javascript\"><code>{\n    let t = 0;\n    var m = 1; \n}\n\nconsole.log(t); //Uncaught ReferenceError\nconsole.log(m); //1</code></pre><p><br /></p><p>上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。</p><p><br /></p><h3 id=\"5625aedb\">不存在变量提升</h3><p><br /></p><p>let不像var那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。</p><p><br /></p><pre data-lang=\"javascript\"><code>console.log(foo); // 输出undefined\nconsole.log(bar); // 报错ReferenceError\n\nvar foo = 2;\nlet bar = 2;</code></pre><p><br /></p><p>上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误，所以使用let请先声明，后使用。</p><p><br /></p><h3 id=\"45a566a3\">暂时性死区（temporal dead zone）</h3><p><br /></p><p>只要块级作用域内存在let命令，它所声明的变量在声明之前都是不可用的，即使全局变量中存在同名变量。</p><p><br /></p><pre data-lang=\"javascript\"><code>var tmp = 111；\n\nif (true) {\n  // TDZ开始\n  tmp = 'abc'; // ReferenceError\n  console.log(tmp); // ReferenceError\n\n  let tmp; // TDZ结束\n  console.log(tmp); // undefined\n\n  tmp = 123;\n  console.log(tmp); // 123\n}</code></pre><p><br /></p><p>上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。</p><p><br /></p><p>ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p><p><br /></p><p>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。</p><p><br /></p><h3 id=\"dccd9155\">不允许重复声明</h3><p><br /></p><p>let不允许在相同作用域内，重复声明同一个变量。</p><p><br /></p><pre data-lang=\"javascript\"><code>// 报错\nfunction () {\n  let a = 10;\n  var a = 1;\n}\n\n// 报错\nfunction () {\n  let a = 10;\n  let a = 1;\n}</code></pre><p><br /></p><p>因此，不能在函数内部重新声明参数。</p><p><br /></p><pre data-lang=\"javascript\"><code>function func(arg) {\n  let arg; // 报错\n}\n\nfunction func(arg) {\n  {\n    let arg; // 不报错\n  }\n}</code></pre><p><br /></p><h2 id=\"27fce117\">const关键字</h2><p><br /></p><p>const特性与let基本一致。</p><p><br /></p><p>const声明一个只读的常量。一旦声明，常量的值就不能改变。</p><p><br /></p><pre data-lang=\"javascript\"><code>const PI = 3.1415;\nPI // 3.1415\n\nPI = 3;\n// TypeError: Assignment to constant variable.</code></pre><p><br /></p><p>上面代码表明改变常量的值会报错。</p><p><br /></p><p>const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</p><p><br /></p><pre data-lang=\"javascript\"><code>const a = 1;\na // 1\n\na = 3;\n// TypeError: Assignment to constant variable.\n\n\nconst b = { a:1,c:2 };\nb //  { a:1,c:2 }\n\nb = {};\n// TypeError: Assignment to constant variable.\n\nb.a = 3;\n\nb.c =12;\n\nb //  { a:3,c:12 }</code></pre><p><br /></p><p>js的变量可以分为两类，值类型，引用类型。</p><p><br /></p><p>引用类型，变量其实储存的可以理解为一个内存地址，真正的内容储存在内存地址所指向的内存。</p><p><br /></p><p>const修饰引用类型时，const只是限制了引用的地址不能改变，并不会限制地址指向的内容不改变。</p><p><br /></p>",
  "body_lake": "<!doctype lake><p>在ES6之前，js只有全局作用域和函数作用域，声明变量一般用var，否则就是全局变量。</p><p>ES6，新增了块级作用域，声明变量多了两个关键字let,const。</p><h2 id=\"0665242f\">块级作用域</h2><p><br /></p><p>对于从安卓转到前端的我来说，ES5没有块级作用域，还是很容易造成代码理解的错误的。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22for(var%20i%3D0%3Bi%3C10%3Bi%2B%2B)%7B%5Cn%20%20%20%20%2F%2Fdo%20something...%5Cn%7D%5Cn%5Cnconsole.log(i)%3B%2F%2F%20%20%2010%22%2C%22id%22%3A%22H3HNj%22%7D\"></card><p><br /></p><p>按照java的习惯，i 变量应该是只在for代码块里生效的。但是js里，这样声明的 i 就是全局变量。这就是因为js没有块级作用域。</p><p><br /></p><p>ES6新增了块级作用域。既let,const,让{ }之间拥有了块级作用域。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%7B%5Cn%20%20%20%20let%20t%20%3D%200%3B%5Cn%7D%5Cn%5Cnconsole.log(t)%3B%20%2F%2FUncaught%20ReferenceError%5Cn%5Cnfor(let%20i%3D0%3Bi%3C10%3Bi%2B%2B)%7B%5Cn%20%20%20%20%2F%2Fdo%20something...%5Cn%7D%5Cn%5Cnconsole.log(i)%3B%20%2F%2FUncaught%20ReferenceError%22%2C%22id%22%3A%22cmXVd%22%7D\"></card><p><br /></p><h2 id=\"f93ec1d0\">let关键字</h2><p><br /></p><h3 id=\"704f29e0\">基本用法</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%7B%5Cn%20%20%20%20let%20t%20%3D%200%3B%5Cn%20%20%20%20var%20m%20%3D%201%3B%20%5Cn%7D%5Cn%5Cnconsole.log(t)%3B%20%2F%2FUncaught%20ReferenceError%5Cnconsole.log(m)%3B%20%2F%2F1%22%2C%22id%22%3A%22mzT3N%22%7D\"></card><p><br /></p><p>上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。</p><p><br /></p><h3 id=\"5625aedb\">不存在变量提升</h3><p><br /></p><p>let不像var那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22console.log(foo)%3B%20%2F%2F%20%E8%BE%93%E5%87%BAundefined%5Cnconsole.log(bar)%3B%20%2F%2F%20%E6%8A%A5%E9%94%99ReferenceError%5Cn%5Cnvar%20foo%20%3D%202%3B%5Cnlet%20bar%20%3D%202%3B%22%2C%22id%22%3A%22e45fR%22%7D\"></card><p><br /></p><p>上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误，所以使用let请先声明，后使用。</p><p><br /></p><h3 id=\"45a566a3\">暂时性死区（temporal dead zone）</h3><p><br /></p><p>只要块级作用域内存在let命令，它所声明的变量在声明之前都是不可用的，即使全局变量中存在同名变量。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20tmp%20%3D%20111%EF%BC%9B%5Cn%5Cnif%20(true)%20%7B%5Cn%20%20%2F%2F%20TDZ%E5%BC%80%E5%A7%8B%5Cn%20%20tmp%20%3D%20'abc'%3B%20%2F%2F%20ReferenceError%5Cn%20%20console.log(tmp)%3B%20%2F%2F%20ReferenceError%5Cn%5Cn%20%20let%20tmp%3B%20%2F%2F%20TDZ%E7%BB%93%E6%9D%9F%5Cn%20%20console.log(tmp)%3B%20%2F%2F%20undefined%5Cn%5Cn%20%20tmp%20%3D%20123%3B%5Cn%20%20console.log(tmp)%3B%20%2F%2F%20123%5Cn%7D%22%2C%22id%22%3A%22lrV1k%22%7D\"></card><p><br /></p><p>上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。</p><p><br /></p><p>ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p><p><br /></p><p>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。</p><p><br /></p><h3 id=\"dccd9155\">不允许重复声明</h3><p><br /></p><p>let不允许在相同作用域内，重复声明同一个变量。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20%E6%8A%A5%E9%94%99%5Cnfunction%20()%20%7B%5Cn%20%20let%20a%20%3D%2010%3B%5Cn%20%20var%20a%20%3D%201%3B%5Cn%7D%5Cn%5Cn%2F%2F%20%E6%8A%A5%E9%94%99%5Cnfunction%20()%20%7B%5Cn%20%20let%20a%20%3D%2010%3B%5Cn%20%20let%20a%20%3D%201%3B%5Cn%7D%22%2C%22id%22%3A%22Fx3GJ%22%7D\"></card><p><br /></p><p>因此，不能在函数内部重新声明参数。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20func(arg)%20%7B%5Cn%20%20let%20arg%3B%20%2F%2F%20%E6%8A%A5%E9%94%99%5Cn%7D%5Cn%5Cnfunction%20func(arg)%20%7B%5Cn%20%20%7B%5Cn%20%20%20%20let%20arg%3B%20%2F%2F%20%E4%B8%8D%E6%8A%A5%E9%94%99%5Cn%20%20%7D%5Cn%7D%22%2C%22id%22%3A%22PM18L%22%7D\"></card><p><br /></p><h2 id=\"27fce117\">const关键字<cursor /></h2><p><br /></p><p>const特性与let基本一致。</p><p><br /></p><p>const声明一个只读的常量。一旦声明，常量的值就不能改变。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20PI%20%3D%203.1415%3B%5CnPI%20%2F%2F%203.1415%5Cn%5CnPI%20%3D%203%3B%5Cn%2F%2F%20TypeError%3A%20Assignment%20to%20constant%20variable.%22%2C%22id%22%3A%22feDFH%22%7D\"></card><p><br /></p><p>上面代码表明改变常量的值会报错。</p><p><br /></p><p>const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20a%20%3D%201%3B%5Cna%20%2F%2F%201%5Cn%5Cna%20%3D%203%3B%5Cn%2F%2F%20TypeError%3A%20Assignment%20to%20constant%20variable.%5Cn%5Cn%5Cnconst%20b%20%3D%20%7B%20a%3A1%2Cc%3A2%20%7D%3B%5Cnb%20%2F%2F%20%20%7B%20a%3A1%2Cc%3A2%20%7D%5Cn%5Cnb%20%3D%20%7B%7D%3B%5Cn%2F%2F%20TypeError%3A%20Assignment%20to%20constant%20variable.%5Cn%5Cnb.a%20%3D%203%3B%5Cn%5Cnb.c%20%3D12%3B%5Cn%5Cnb%20%2F%2F%20%20%7B%20a%3A3%2Cc%3A12%20%7D%22%2C%22id%22%3A%22yK7iD%22%7D\"></card><p><br /></p><p>js的变量可以分为两类，值类型，引用类型。</p><p><br /></p><p>引用类型，变量其实储存的可以理解为一个内存地址，真正的内容储存在内存地址所指向的内存。</p><p><br /></p><p>const修饰引用类型时，const只是限制了引用的地址不能改变，并不会限制地址指向的内容不改变。</p><p><br /></p>",
  "body_draft_lake": "",
  "public": 1,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2019-07-24T06:41:53.000Z",
  "deleted_at": null,
  "created_at": "2019-03-07T05:14:24.000Z",
  "updated_at": "2023-02-02T09:07:59.000Z",
  "published_at": "2019-07-24T06:41:53.000Z",
  "first_published_at": "2019-03-07T05:18:59.000Z",
  "word_count": 1058,
  "cover": null,
  "description": "在ES6之前，js只有全局作用域和函数作用域，声明变量一般用var，否则就是全局变量。ES6，新增了块级作用域，声明变量多了两个关键字let,const。块级作用域对于从安卓转到前端的我来说，ES5没有块级作用域，还是很容易造成代码理解的错误的。for(var i=0;i&lt;10;i++)...",
  "custom_description": null,
  "hits": 21,
  "_serializer": "v2.doc_detail"
}