{
  "id": 1337412,
  "slug": "nw7yy2",
  "title": "ES6之变量的解构赋值",
  "book_id": 231593,
  "book": {
    "id": 231593,
    "type": "Book",
    "slug": "web",
    "name": "WEB",
    "user_id": 284138,
    "description": "前端知识点记录",
    "creator_id": 284138,
    "public": 1,
    "items_count": 58,
    "likes_count": 0,
    "watches_count": 3,
    "content_updated_at": "2023-02-02T09:09:21.426Z",
    "updated_at": "2023-02-02T09:09:21.000Z",
    "created_at": "2019-03-07T05:05:08.000Z",
    "namespace": "zackdk/web",
    "user": {
      "id": 284138,
      "type": "User",
      "login": "zackdk",
      "name": "行一度空山",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1551934932702-d412771d-8d33-4694-9186-a749a3b4e05b.jpeg",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 5,
      "following_count": 0,
      "created_at": "2019-03-07T05:02:38.000Z",
      "updated_at": "2023-02-01T12:18:25.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 284138,
  "creator": {
    "id": 284138,
    "type": "User",
    "login": "zackdk",
    "name": "行一度空山",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1551934932702-d412771d-8d33-4694-9186-a749a3b4e05b.jpeg",
    "books_count": 2,
    "public_books_count": 1,
    "followers_count": 5,
    "following_count": 0,
    "created_at": "2019-03-07T05:02:38.000Z",
    "updated_at": "2023-02-01T12:18:25.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "解构赋值（Destructuring）：从数组和对象中提取值，对变量进行赋值。\n<a name=\"47f40e55\"></a>\n## 数组的解构赋值\n\n<a name=\"704f29e0\"></a>\n### 基本用法\n\n```javascript\n//基本用法\nlet [a, b, c] = [1, 2, 3];\n// a = 1,b = 2,c = 3\n\n//解构失败\nlet [a, b, c, d ] = [1, 2, 3];\n// a = 1,b = 2,c = 3,d=undefined\n\n//部分解构 \nlet [a, b] = [1, 2, 3];\n// a = 1,b = 2\n```\n\n上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。\n\n如果解构不成功，变量的值就等于undefined。\n\n部分解构，既变量数不相等，仍然可以解构成功。\n\n```javascript\n//以下用法都会报错\n\nlet [foo] = 1;\nlet [foo] = false;\nlet [foo] = NaN;\nlet [foo] = undefined;\nlet [foo] = null;\nlet [foo] = {};\n\n//is not iterable\n```\n\n数组的解构是要求右边的值部署有Iterator接口的。\n\n上面的语句之所以报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。\n\n这就是说等号的右边如果不是数组（或者严格地说，不是可遍历的结构），那么将会报错。\n\n\n```javascript\nlet [x, y, z] = new Set(['a', 'b', 'c']);\nx // \"a\"\n\nfunction* fibs() {\n  let a = 0;\n  let b = 1;\n  while (true) {\n    yield a;\n    [a, b] = [b, a + b];\n  }\n}\nlet [first, second, third, fourth, fifth, sixth] = fibs();\nsixth // 5\n```\n\n因为Set 具备Iterator接口 可以进行解构赋值。\n\nfibs是一个 Generator 函数，原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。\n\n<a name=\"225f3ed0\"></a>\n### 默认值\n\n解构赋值允许指定默认值。\n\n```javascript\nlet [foo = true] = [];\nfoo // true\nlet [x, y = 'b'] = ['a']; // x='a', y='b'\nlet [x, y = 'b'] = ['a', undefined]; // x='a', y='b'\n\nlet [x = 1] = [undefined];\nx // 1\n\nlet [x = 1] = [null];\nx // null\n```\n\nES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，**只有当一个数组成员****严格等于undefined****，默认值才会生效。**\n\n因为null不严格等于undefined,所以默认值不会生效。\n\n如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。\n\n```javascript\nfunction f() {\n  console.log('aaa');\n}\nlet [x = f()] = [1];\n```\n\n上面代码中，因为x能取到值，所以函数f根本不会执行。\n\n默认值可以引用解构赋值的其他变量，但该变量必须已经声明，所以声明顺序很重要。\n\n```javascript\nlet [x = 1, y = x] = [];     // x=1; y=1\nlet [x = 1, y = x] = [2];    // x=2; y=2\nlet [x = 1, y = x] = [1, 2]; // x=1; y=2\nlet [x = y, y = 1] = [];     // ReferenceError: y is not defined\n```\n\n因为x用y做默认值时，y还没有声明,所以会报错。\n\n<a name=\"19ad6b0b\"></a>\n## 对象的解构赋值\n\n对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。对象的结构是依靠key值，也就是属性名来进行的。\n\n```javascript\nlet { foo, bar } = { foo: \"aaa\", bar: \"bbb\" };\nfoo // \"aaa\"\nbar // \"bbb\"\n```\n\n如果希望变量名与属性名不同。必须像下面这样写。\n\n```javascript\nlet { foo:too, bar:boo } = { foo: \"aaa\", bar: \"bbb\" };\ntoo // \"aaa\"\nboo // \"bbb\"\n```\n\n这实际上证明了对象的解构赋值时如下方式的简写。\n\n```javascript\nlet { foo:foo, bar:bar } = { foo: \"aaa\", bar: \"bbb\" };\nfoo // \"aaa\"\nbar // \"bbb\"\n```\n\n也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，前者是同名属性。所以如下代码是会报错的。\n\n```javascript\nlet { foo:bar} = { foo: \"aaa\" };\nbar // \"aaa\"\nfoo // error: foo is not defined\n```\n\n和数组一样对象的解构也可以指定默认值，生效的条件也是属性值严格等于undefined。\n\n```javascript\nvar {x = 3} = {};\nx // 3\n\nvar {x, y = 5} = {x: 1};\nx // 1\ny // 5\n\nvar {x: y = 3} = {};\ny // 3\n\nvar {x: y = 3} = {x: 5};\ny // 5\n\nvar { message: msg = 'Something went wrong' } = {};\nmsg // \"Something went wrong\"\n```\n\n<a name=\"8b161c94\"></a>\n## 函数参数的解构赋值\n\n```javascript\n//参数为数组时\nfunction add([x,y=0]){\n    return x+y;\n}\n\nadd([1,2]) // 3\nadd([1]) // 1\n\n//参数为对象时\nfunction move({x = 0, y = 0} = {}) {\n  return [x, y];\n}\n\nmove({x: 3, y: 8}); // [3, 8]\nmove({x: 3}); // [3, 0]\nmove({}); // [0, 0]\nmove(); // [0, 0]\n```\n\n上述add函数传入的参数值为一个数组，但对于函数来说，这个数组被解构为了 x 和 y 两个变量，同样也支持默认值，当对应位置的值严格等于undefined时，默认值生效。\n\nmove函数同理。两个最大的差别在于。数组是有序的，而对象的属性是可以无序的。<br />另外上面 ={} 是参数的默认值，不写这个，直接调用move()，不传参数时，是会报错的。因为无法对不存在的参数解构。\n\n<a name=\"83ebda29\"></a>\n## 其它情况\n\n<a name=\"5ccd658c\"></a>\n## 解构赋值的常见用途\n\n<a name=\"082ed663\"></a>\n### 交换变量的值\n\n```javascript\nlet x = 1;\nlet y = 2;\n\n[x, y] = [y, x];\n```\n\n上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。\n\n<a name=\"95cf6d22\"></a>\n### 函数参数的定义\n\n```javascript\n// 参数是一组有次序的值\nfunction f([x, y, z]) { ... }\nf([1, 2, 3]);\n\n// 参数是一组无次序的值\nfunction f({x, y, z}) { ... }\nf({z: 3, y: 2, x: 1});\n```\n\n解构赋值可以方便地将一组参数与变量名对应起来。\n\n<a name=\"5e505215\"></a>\n### 函数参数的默认值\n\n```javascript\njQuery.ajax = function (url, {\n  async = true,\n  beforeSend = function () {},\n  cache = true,\n  complete = function () {},\n  crossDomain = false,\n  global = true,\n  // ... more config\n} = {}) {\n  // ... do stuff\n};\n```\n\n指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || 'default foo';这样的语句。\n\n<a name=\"fae5ceed\"></a>\n### 遍历 Map 结构\n\n任何部署了 Iterator 接口的对象，都可以用for...of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。\n\n```javascript\nconst map = new Map();\nmap.set('first', 'hello');\nmap.set('second', 'world');\n\nfor (let [key, value] of map) {\n  console.log(key + \" is \" + value);\n}\n// first is hello\n// second is world\n```\n\n如果只想获取键名，或者只想获取键值，可以写成下面这样。\n\n```javascript\n// 获取键名\nfor (let [key] of map) {\n  // ...\n}\n\n// 获取键值\nfor (let [,value] of map) {\n  // ...\n}\n```\n\n<a name=\"d150ea02\"></a>\n### 输入模块的指定方法\n\n加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。\n\n```javascript\nconst { SourceMapConsumer, SourceNode } = require(\"source-map\");\n```\n\n大部分参考自阮一峰老师的：[变量的解构赋值](http://es6.ruanyifeng.com/#docs/destructuring#%E6%95%B0%E7%BB%84%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC)\n\n",
  "body_draft": "",
  "body_html": "<!doctype html><p>解构赋值（Destructuring）：从数组和对象中提取值，对变量进行赋值。</p><h2 id=\"47f40e55\">数组的解构赋值</h2><p><br /></p><h3 id=\"704f29e0\">基本用法</h3><p><br /></p><pre data-lang=\"javascript\"><code>//基本用法\nlet [a, b, c] = [1, 2, 3];\n// a = 1,b = 2,c = 3\n\n//解构失败\nlet [a, b, c, d ] = [1, 2, 3];\n// a = 1,b = 2,c = 3,d=undefined\n\n//部分解构 \nlet [a, b] = [1, 2, 3];\n// a = 1,b = 2</code></pre><p><br /></p><p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p><p><br /></p><p>如果解构不成功，变量的值就等于undefined。</p><p><br /></p><p>部分解构，既变量数不相等，仍然可以解构成功。</p><p><br /></p><pre data-lang=\"javascript\"><code>//以下用法都会报错\n\nlet [foo] = 1;\nlet [foo] = false;\nlet [foo] = NaN;\nlet [foo] = undefined;\nlet [foo] = null;\nlet [foo] = {};\n\n//is not iterable</code></pre><p><br /></p><p><span style=\"color: #F5222D;\">数组的解构是要求右边的值部署有Iterator接口的。</span></p><p><br /></p><p>上面的语句之所以报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。</p><p><br /></p><p>这就是说等号的右边如果不是数组（或者严格地说，不是可遍历的结构），那么将会报错。</p><p><br /></p><p><br /></p><pre data-lang=\"javascript\"><code>let [x, y, z] = new Set(['a', 'b', 'c']);\nx // &quot;a&quot;\n\nfunction* fibs() {\n  let a = 0;\n  let b = 1;\n  while (true) {\n    yield a;\n    [a, b] = [b, a + b];\n  }\n}\nlet [first, second, third, fourth, fifth, sixth] = fibs();\nsixth // 5</code></pre><p><br /></p><p>因为Set 具备Iterator接口 可以进行解构赋值。</p><p><br /></p><p>fibs是一个 Generator 函数，原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。</p><p><br /></p><h3 id=\"225f3ed0\">默认值</h3><p><br /></p><p>解构赋值允许指定默认值。</p><p><br /></p><pre data-lang=\"javascript\"><code>let [foo = true] = [];\nfoo // true\nlet [x, y = 'b'] = ['a']; // x='a', y='b'\nlet [x, y = 'b'] = ['a', undefined]; // x='a', y='b'\n\nlet [x = 1] = [undefined];\nx // 1\n\nlet [x = 1] = [null];\nx // null</code></pre><p><br /></p><p>ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，<span style=\"color: #F5222D;\"><strong>只有当一个数组成员</strong></span><span style=\"color: #F5222D;\"><strong>严格等于undefined</strong></span><span style=\"color: #F5222D;\"><strong>，默认值才会生效。</strong></span></p><p><br /></p><p>因为null不严格等于undefined,所以默认值不会生效。</p><p><br /></p><p>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</p><p><br /></p><pre data-lang=\"javascript\"><code>function f() {\n  console.log('aaa');\n}\nlet [x = f()] = [1];</code></pre><p><br /></p><p>上面代码中，因为x能取到值，所以函数f根本不会执行。</p><p><br /></p><p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明，所以声明顺序很重要。</p><p><br /></p><pre data-lang=\"javascript\"><code>let [x = 1, y = x] = [];     // x=1; y=1\nlet [x = 1, y = x] = [2];    // x=2; y=2\nlet [x = 1, y = x] = [1, 2]; // x=1; y=2\nlet [x = y, y = 1] = [];     // ReferenceError: y is not defined</code></pre><p><br /></p><p>因为x用y做默认值时，y还没有声明,所以会报错。</p><p><br /></p><h2 id=\"19ad6b0b\">对象的解构赋值</h2><p><br /></p><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。<span style=\"color: #F5222D;\">对象的结构是依靠key值，也就是属性名来进行的。</span></p><p><br /></p><pre data-lang=\"javascript\"><code>let { foo, bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };\nfoo // &quot;aaa&quot;\nbar // &quot;bbb&quot;</code></pre><p><br /></p><p>如果希望变量名与属性名不同。必须像下面这样写。</p><p><br /></p><pre data-lang=\"javascript\"><code>let { foo:too, bar:boo } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };\ntoo // &quot;aaa&quot;\nboo // &quot;bbb&quot;</code></pre><p><br /></p><p>这实际上证明了对象的解构赋值时如下方式的简写。</p><p><br /></p><pre data-lang=\"javascript\"><code>let { foo:foo, bar:bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };\nfoo // &quot;aaa&quot;\nbar // &quot;bbb&quot;</code></pre><p><br /></p><p>也就是说，<span style=\"color: #F5222D;\">对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者</span><span style=\"color: #F5222D;\">，前者是同名属性。</span>所以如下代码是会报错的。</p><p><br /></p><pre data-lang=\"javascript\"><code>let { foo:bar} = { foo: &quot;aaa&quot; };\nbar // &quot;aaa&quot;\nfoo // error: foo is not defined</code></pre><p><br /></p><p>和数组一样对象的解构也可以指定默认值，生效的条件也是属性值严格等于undefined。</p><p><br /></p><pre data-lang=\"javascript\"><code>var {x = 3} = {};\nx // 3\n\nvar {x, y = 5} = {x: 1};\nx // 1\ny // 5\n\nvar {x: y = 3} = {};\ny // 3\n\nvar {x: y = 3} = {x: 5};\ny // 5\n\nvar { message: msg = 'Something went wrong' } = {};\nmsg // &quot;Something went wrong&quot;</code></pre><p><br /></p><h2 id=\"8b161c94\">函数参数的解构赋值</h2><p><br /></p><pre data-lang=\"javascript\"><code>//参数为数组时\nfunction add([x,y=0]){\n    return x+y;\n}\n\nadd([1,2]) // 3\nadd([1]) // 1\n\n//参数为对象时\nfunction move({x = 0, y = 0} = {}) {\n  return [x, y];\n}\n\nmove({x: 3, y: 8}); // [3, 8]\nmove({x: 3}); // [3, 0]\nmove({}); // [0, 0]\nmove(); // [0, 0]</code></pre><p><br /></p><p>上述add函数传入的参数值为一个数组，但对于函数来说，这个数组被解构为了 x 和 y 两个变量，同样也支持默认值，当对应位置的值严格等于undefined时，默认值生效。</p><p><br /></p><p>move函数同理。两个最大的差别在于。数组是有序的，而对象的属性是可以无序的。</p><p>另外上面 ={} 是参数的默认值，不写这个，直接调用move()，不传参数时，是会报错的。因为无法对不存在的参数解构。</p><p><br /></p><h2 id=\"83ebda29\">其它情况</h2><p><br /></p><h2 id=\"5ccd658c\">解构赋值的常见用途</h2><p><br /></p><h3 id=\"082ed663\">交换变量的值</h3><p><br /></p><pre data-lang=\"javascript\"><code>let x = 1;\nlet y = 2;\n\n[x, y] = [y, x];</code></pre><p><br /></p><p>上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p><p><br /></p><h3 id=\"95cf6d22\">函数参数的定义</h3><p><br /></p><pre data-lang=\"javascript\"><code>// 参数是一组有次序的值\nfunction f([x, y, z]) { ... }\nf([1, 2, 3]);\n\n// 参数是一组无次序的值\nfunction f({x, y, z}) { ... }\nf({z: 3, y: 2, x: 1});</code></pre><p><br /></p><p>解构赋值可以方便地将一组参数与变量名对应起来。</p><p><br /></p><h3 id=\"5e505215\">函数参数的默认值</h3><p><br /></p><pre data-lang=\"javascript\"><code>jQuery.ajax = function (url, {\n  async = true,\n  beforeSend = function () {},\n  cache = true,\n  complete = function () {},\n  crossDomain = false,\n  global = true,\n  // ... more config\n} = {}) {\n  // ... do stuff\n};</code></pre><p><br /></p><p>指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || 'default foo';这样的语句。</p><p><br /></p><h3 id=\"fae5ceed\">遍历 Map 结构</h3><p><br /></p><p>任何部署了 Iterator 接口的对象，都可以用for...of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p><p><br /></p><pre data-lang=\"javascript\"><code>const map = new Map();\nmap.set('first', 'hello');\nmap.set('second', 'world');\n\nfor (let [key, value] of map) {\n  console.log(key + &quot; is &quot; + value);\n}\n// first is hello\n// second is world</code></pre><p><br /></p><p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p><p><br /></p><pre data-lang=\"javascript\"><code>// 获取键名\nfor (let [key] of map) {\n  // ...\n}\n\n// 获取键值\nfor (let [,value] of map) {\n  // ...\n}</code></pre><p><br /></p><h3 id=\"d150ea02\">输入模块的指定方法</h3><p><br /></p><p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p><p><br /></p><pre data-lang=\"javascript\"><code>const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;);</code></pre><p><br /></p><p>大部分参考自阮一峰老师的：<a href=\"http://es6.ruanyifeng.com/#docs/destructuring#%E6%95%B0%E7%BB%84%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC\" target=\"_blank\">变量的解构赋值</a></p><p><br /></p>",
  "body_lake": "<!doctype lake><p>解构赋值（Destructuring）：从数组和对象中提取值，对变量进行赋值。</p><h2 id=\"47f40e55\">数组的解构赋值</h2><p><br /></p><h3 id=\"704f29e0\">基本用法</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%5Cnlet%20%5Ba%2C%20b%2C%20c%5D%20%3D%20%5B1%2C%202%2C%203%5D%3B%5Cn%2F%2F%20a%20%3D%201%2Cb%20%3D%202%2Cc%20%3D%203%5Cn%5Cn%2F%2F%E8%A7%A3%E6%9E%84%E5%A4%B1%E8%B4%A5%5Cnlet%20%5Ba%2C%20b%2C%20c%2C%20d%20%5D%20%3D%20%5B1%2C%202%2C%203%5D%3B%5Cn%2F%2F%20a%20%3D%201%2Cb%20%3D%202%2Cc%20%3D%203%2Cd%3Dundefined%5Cn%5Cn%2F%2F%E9%83%A8%E5%88%86%E8%A7%A3%E6%9E%84%20%5Cnlet%20%5Ba%2C%20b%5D%20%3D%20%5B1%2C%202%2C%203%5D%3B%5Cn%2F%2F%20a%20%3D%201%2Cb%20%3D%202%22%7D\"></card><p><br /></p><p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p><p><br /></p><p>如果解构不成功，变量的值就等于undefined。</p><p><br /></p><p>部分解构，既变量数不相等，仍然可以解构成功。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%E4%BB%A5%E4%B8%8B%E7%94%A8%E6%B3%95%E9%83%BD%E4%BC%9A%E6%8A%A5%E9%94%99%5Cn%5Cnlet%20%5Bfoo%5D%20%3D%201%3B%5Cnlet%20%5Bfoo%5D%20%3D%20false%3B%5Cnlet%20%5Bfoo%5D%20%3D%20NaN%3B%5Cnlet%20%5Bfoo%5D%20%3D%20undefined%3B%5Cnlet%20%5Bfoo%5D%20%3D%20null%3B%5Cnlet%20%5Bfoo%5D%20%3D%20%7B%7D%3B%5Cn%5Cn%2F%2Fis%20not%20iterable%22%7D\"></card><p><br /></p><p><span style=\"color: #F5222D;\">数组的解构是要求右边的值部署有Iterator接口的。</span></p><p><br /></p><p>上面的语句之所以报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。</p><p><br /></p><p>这就是说等号的右边如果不是数组（或者严格地说，不是可遍历的结构），那么将会报错。</p><p><br /></p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20%5Bx%2C%20y%2C%20z%5D%20%3D%20new%20Set(%5B'a'%2C%20'b'%2C%20'c'%5D)%3B%5Cnx%20%2F%2F%20%5C%22a%5C%22%5Cn%5Cnfunction*%20fibs()%20%7B%5Cn%20%20let%20a%20%3D%200%3B%5Cn%20%20let%20b%20%3D%201%3B%5Cn%20%20while%20(true)%20%7B%5Cn%20%20%20%20yield%20a%3B%5Cn%20%20%20%20%5Ba%2C%20b%5D%20%3D%20%5Bb%2C%20a%20%2B%20b%5D%3B%5Cn%20%20%7D%5Cn%7D%5Cnlet%20%5Bfirst%2C%20second%2C%20third%2C%20fourth%2C%20fifth%2C%20sixth%5D%20%3D%20fibs()%3B%5Cnsixth%20%2F%2F%205%22%7D\"></card><p><br /></p><p>因为Set 具备Iterator接口 可以进行解构赋值。</p><p><br /></p><p>fibs是一个 Generator 函数，原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。</p><p><br /></p><h3 id=\"225f3ed0\">默认值</h3><p><br /></p><p>解构赋值允许指定默认值。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20%5Bfoo%20%3D%20true%5D%20%3D%20%5B%5D%3B%5Cnfoo%20%2F%2F%20true%5Cnlet%20%5Bx%2C%20y%20%3D%20'b'%5D%20%3D%20%5B'a'%5D%3B%20%2F%2F%20x%3D'a'%2C%20y%3D'b'%5Cnlet%20%5Bx%2C%20y%20%3D%20'b'%5D%20%3D%20%5B'a'%2C%20undefined%5D%3B%20%2F%2F%20x%3D'a'%2C%20y%3D'b'%5Cn%5Cnlet%20%5Bx%20%3D%201%5D%20%3D%20%5Bundefined%5D%3B%5Cnx%20%2F%2F%201%5Cn%5Cnlet%20%5Bx%20%3D%201%5D%20%3D%20%5Bnull%5D%3B%5Cnx%20%2F%2F%20null%22%7D\"></card><p><br /></p><p>ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，<span style=\"color: #F5222D;\"><strong>只有当一个数组成员</strong></span><span style=\"color: #F5222D;\"><strong>严格等于undefined</strong></span><span style=\"color: #F5222D;\"><strong>，默认值才会生效。</strong></span></p><p><br /></p><p>因为null不严格等于undefined,所以默认值不会生效。</p><p><br /></p><p>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20f()%20%7B%5Cn%20%20console.log('aaa')%3B%5Cn%7D%5Cnlet%20%5Bx%20%3D%20f()%5D%20%3D%20%5B1%5D%3B%22%7D\"></card><p><br /></p><p>上面代码中，因为x能取到值，所以函数f根本不会执行。</p><p><br /></p><p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明，所以声明顺序很重要。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20%5Bx%20%3D%201%2C%20y%20%3D%20x%5D%20%3D%20%5B%5D%3B%20%20%20%20%20%2F%2F%20x%3D1%3B%20y%3D1%5Cnlet%20%5Bx%20%3D%201%2C%20y%20%3D%20x%5D%20%3D%20%5B2%5D%3B%20%20%20%20%2F%2F%20x%3D2%3B%20y%3D2%5Cnlet%20%5Bx%20%3D%201%2C%20y%20%3D%20x%5D%20%3D%20%5B1%2C%202%5D%3B%20%2F%2F%20x%3D1%3B%20y%3D2%5Cnlet%20%5Bx%20%3D%20y%2C%20y%20%3D%201%5D%20%3D%20%5B%5D%3B%20%20%20%20%20%2F%2F%20ReferenceError%3A%20y%20is%20not%20defined%22%7D\"></card><p><br /></p><p>因为x用y做默认值时，y还没有声明,所以会报错。</p><p><br /></p><h2 id=\"19ad6b0b\">对象的解构赋值</h2><p><br /></p><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。<span style=\"color: #F5222D;\">对象的结构是依靠key值，也就是属性名来进行的。</span></p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20%7B%20foo%2C%20bar%20%7D%20%3D%20%7B%20foo%3A%20%5C%22aaa%5C%22%2C%20bar%3A%20%5C%22bbb%5C%22%20%7D%3B%5Cnfoo%20%2F%2F%20%5C%22aaa%5C%22%5Cnbar%20%2F%2F%20%5C%22bbb%5C%22%22%7D\"></card><p><br /></p><p>如果希望变量名与属性名不同。必须像下面这样写。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20%7B%20foo%3Atoo%2C%20bar%3Aboo%20%7D%20%3D%20%7B%20foo%3A%20%5C%22aaa%5C%22%2C%20bar%3A%20%5C%22bbb%5C%22%20%7D%3B%5Cntoo%20%2F%2F%20%5C%22aaa%5C%22%5Cnboo%20%2F%2F%20%5C%22bbb%5C%22%22%7D\"></card><p><br /></p><p>这实际上证明了对象的解构赋值时如下方式的简写。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20%7B%20foo%3Afoo%2C%20bar%3Abar%20%7D%20%3D%20%7B%20foo%3A%20%5C%22aaa%5C%22%2C%20bar%3A%20%5C%22bbb%5C%22%20%7D%3B%5Cnfoo%20%2F%2F%20%5C%22aaa%5C%22%5Cnbar%20%2F%2F%20%5C%22bbb%5C%22%22%7D\"></card><p><br /></p><p>也就是说，<span style=\"color: #F5222D;\">对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者</span><span style=\"color: #F5222D;\">，前者是同名属性。</span>所以如下代码是会报错的。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20%7B%20foo%3Abar%7D%20%3D%20%7B%20foo%3A%20%5C%22aaa%5C%22%20%7D%3B%5Cnbar%20%2F%2F%20%5C%22aaa%5C%22%5Cnfoo%20%2F%2F%20error%3A%20foo%20is%20not%20defined%22%7D\"></card><p><br /></p><p>和数组一样对象的解构也可以指定默认值，生效的条件也是属性值严格等于undefined。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20%7Bx%20%3D%203%7D%20%3D%20%7B%7D%3B%5Cnx%20%2F%2F%203%5Cn%5Cnvar%20%7Bx%2C%20y%20%3D%205%7D%20%3D%20%7Bx%3A%201%7D%3B%5Cnx%20%2F%2F%201%5Cny%20%2F%2F%205%5Cn%5Cnvar%20%7Bx%3A%20y%20%3D%203%7D%20%3D%20%7B%7D%3B%5Cny%20%2F%2F%203%5Cn%5Cnvar%20%7Bx%3A%20y%20%3D%203%7D%20%3D%20%7Bx%3A%205%7D%3B%5Cny%20%2F%2F%205%5Cn%5Cnvar%20%7B%20message%3A%20msg%20%3D%20'Something%20went%20wrong'%20%7D%20%3D%20%7B%7D%3B%5Cnmsg%20%2F%2F%20%5C%22Something%20went%20wrong%5C%22%22%7D\"></card><p><br /></p><h2 id=\"8b161c94\">函数参数的解构赋值</h2><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%E5%8F%82%E6%95%B0%E4%B8%BA%E6%95%B0%E7%BB%84%E6%97%B6%5Cnfunction%20add(%5Bx%2Cy%3D0%5D)%7B%5Cn%20%20%20%20return%20x%2By%3B%5Cn%7D%5Cn%5Cnadd(%5B1%2C2%5D)%20%2F%2F%203%5Cnadd(%5B1%5D)%20%2F%2F%201%5Cn%5Cn%2F%2F%E5%8F%82%E6%95%B0%E4%B8%BA%E5%AF%B9%E8%B1%A1%E6%97%B6%5Cnfunction%20move(%7Bx%20%3D%200%2C%20y%20%3D%200%7D%20%3D%20%7B%7D)%20%7B%5Cn%20%20return%20%5Bx%2C%20y%5D%3B%5Cn%7D%5Cn%5Cnmove(%7Bx%3A%203%2C%20y%3A%208%7D)%3B%20%2F%2F%20%5B3%2C%208%5D%5Cnmove(%7Bx%3A%203%7D)%3B%20%2F%2F%20%5B3%2C%200%5D%5Cnmove(%7B%7D)%3B%20%2F%2F%20%5B0%2C%200%5D%5Cnmove()%3B%20%2F%2F%20%5B0%2C%200%5D%22%7D\"></card><p><br /></p><p>上述add函数传入的参数值为一个数组，但对于函数来说，这个数组被解构为了 x 和 y 两个变量，同样也支持默认值，当对应位置的值严格等于undefined时，默认值生效。</p><p><br /></p><p>move函数同理。两个最大的差别在于。数组是有序的，而对象的属性是可以无序的。</p><p>另外上面 ={} 是参数的默认值，不写这个，直接调用move()，不传参数时，是会报错的。因为无法对不存在的参数解构。</p><p><br /></p><h2 id=\"83ebda29\">其它情况</h2><p><br /></p><h2 id=\"5ccd658c\">解构赋值的常见用途</h2><p><br /></p><h3 id=\"082ed663\">交换变量的值</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20x%20%3D%201%3B%5Cnlet%20y%20%3D%202%3B%5Cn%5Cn%5Bx%2C%20y%5D%20%3D%20%5By%2C%20x%5D%3B%22%7D\"></card><p><br /></p><p>上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p><p><br /></p><h3 id=\"95cf6d22\">函数参数的定义</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20%E5%8F%82%E6%95%B0%E6%98%AF%E4%B8%80%E7%BB%84%E6%9C%89%E6%AC%A1%E5%BA%8F%E7%9A%84%E5%80%BC%5Cnfunction%20f(%5Bx%2C%20y%2C%20z%5D)%20%7B%20...%20%7D%5Cnf(%5B1%2C%202%2C%203%5D)%3B%5Cn%5Cn%2F%2F%20%E5%8F%82%E6%95%B0%E6%98%AF%E4%B8%80%E7%BB%84%E6%97%A0%E6%AC%A1%E5%BA%8F%E7%9A%84%E5%80%BC%5Cnfunction%20f(%7Bx%2C%20y%2C%20z%7D)%20%7B%20...%20%7D%5Cnf(%7Bz%3A%203%2C%20y%3A%202%2C%20x%3A%201%7D)%3B%22%7D\"></card><p><br /></p><p>解构赋值可以方便地将一组参数与变量名对应起来。</p><p><br /></p><h3 id=\"5e505215\">函数参数的默认值</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22jQuery.ajax%20%3D%20function%20(url%2C%20%7B%5Cn%20%20async%20%3D%20true%2C%5Cn%20%20beforeSend%20%3D%20function%20()%20%7B%7D%2C%5Cn%20%20cache%20%3D%20true%2C%5Cn%20%20complete%20%3D%20function%20()%20%7B%7D%2C%5Cn%20%20crossDomain%20%3D%20false%2C%5Cn%20%20global%20%3D%20true%2C%5Cn%20%20%2F%2F%20...%20more%20config%5Cn%7D%20%3D%20%7B%7D)%20%7B%5Cn%20%20%2F%2F%20...%20do%20stuff%5Cn%7D%3B%22%7D\"></card><p><br /></p><p>指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || 'default foo';这样的语句。</p><p><br /></p><h3 id=\"fae5ceed\">遍历 Map 结构</h3><p><br /></p><p>任何部署了 Iterator 接口的对象，都可以用for...of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20map%20%3D%20new%20Map()%3B%5Cnmap.set('first'%2C%20'hello')%3B%5Cnmap.set('second'%2C%20'world')%3B%5Cn%5Cnfor%20(let%20%5Bkey%2C%20value%5D%20of%20map)%20%7B%5Cn%20%20console.log(key%20%2B%20%5C%22%20is%20%5C%22%20%2B%20value)%3B%5Cn%7D%5Cn%2F%2F%20first%20is%20hello%5Cn%2F%2F%20second%20is%20world%22%7D\"></card><p><br /></p><p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20%E8%8E%B7%E5%8F%96%E9%94%AE%E5%90%8D%5Cnfor%20(let%20%5Bkey%5D%20of%20map)%20%7B%5Cn%20%20%2F%2F%20...%5Cn%7D%5Cn%5Cn%2F%2F%20%E8%8E%B7%E5%8F%96%E9%94%AE%E5%80%BC%5Cnfor%20(let%20%5B%2Cvalue%5D%20of%20map)%20%7B%5Cn%20%20%2F%2F%20...%5Cn%7D%22%7D\"></card><p><br /></p><h3 id=\"d150ea02\">输入模块的指定方法</h3><p><br /></p><p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20%7B%20SourceMapConsumer%2C%20SourceNode%20%7D%20%3D%20require(%5C%22source-map%5C%22)%3B%22%7D\"></card><p><br /></p><p>大部分参考自阮一峰老师的：<a href=\"http://es6.ruanyifeng.com/#docs/destructuring#%E6%95%B0%E7%BB%84%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC\" target=\"_blank\">变量的解构赋值</a></p><p><br /></p>",
  "body_draft_lake": "",
  "public": 1,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2019-03-07T05:42:50.000Z",
  "deleted_at": null,
  "created_at": "2019-03-07T05:21:53.000Z",
  "updated_at": "2023-02-02T09:07:59.000Z",
  "published_at": "2019-03-07T05:42:50.000Z",
  "first_published_at": "2019-03-07T05:42:50.000Z",
  "word_count": 1658,
  "cover": null,
  "description": "解构赋值（Destructuring）：从数组和对象中提取值，对变量进行赋值。数组的解构赋值基本用法//基本用法 let [a, b, c] = [1, 2, 3]; // a = 1,b = 2,c = 3  //解构失败 let [a, b, c, d ] = [1, 2, 3]; // ...",
  "custom_description": null,
  "hits": 30,
  "_serializer": "v2.doc_detail"
}