{
  "id": 112805665,
  "slug": "nvup03561w4z8x90",
  "title": "使用 Esbuild 在浏览器内编译 React",
  "book_id": 231593,
  "book": {
    "id": 231593,
    "type": "Book",
    "slug": "web",
    "name": "WEB",
    "user_id": 284138,
    "description": "前端知识点记录",
    "creator_id": 284138,
    "public": 1,
    "items_count": 58,
    "likes_count": 0,
    "watches_count": 3,
    "content_updated_at": "2023-02-02T09:09:21.426Z",
    "updated_at": "2023-02-02T09:09:21.000Z",
    "created_at": "2019-03-07T05:05:08.000Z",
    "namespace": "zackdk/web",
    "user": {
      "id": 284138,
      "type": "User",
      "login": "zackdk",
      "name": "行一度空山",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1551934932702-d412771d-8d33-4694-9186-a749a3b4e05b.jpeg",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 5,
      "following_count": 0,
      "created_at": "2019-03-07T05:02:38.000Z",
      "updated_at": "2023-02-01T12:18:25.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 284138,
  "creator": {
    "id": 284138,
    "type": "User",
    "login": "zackdk",
    "name": "行一度空山",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1551934932702-d412771d-8d33-4694-9186-a749a3b4e05b.jpeg",
    "books_count": 2,
    "public_books_count": 1,
    "followers_count": 5,
    "following_count": 0,
    "created_at": "2019-03-07T05:02:38.000Z",
    "updated_at": "2023-02-01T12:18:25.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "---\n\n<a name=\"32429250\"></a>\n## 为什么要在浏览器内编译 React ?\n\n博客编写时需要实时预览，使用的 MDX 需要经过编译，预览则采用了 iframe 进行预览，所以我需要把 MDX 编译成 JavaScript ，放到 iframe 里。\n\n<a name=\"89269a88\"></a>\n## esbuild 怎么跑在浏览器内的 ?\n\nesbuild 提供了 wasm 版本，是支持在浏览器内运行的，具体可以参考[官网](https://esbuild.github.io/api/#running-in-the-browser)。\n\n<a name=\"bac5e51d\"></a>\n## esbuild 在浏览器内运行，有啥问题么 ?\n\n有的，浏览器内没有文件系统，所以你会看到如下的错误：\n\n```shell\nUncaught (in promise) Error: Build failed with 3 errors:\nerror: Cannot read directory \".\": not implemented on js\nerror: Cannot read directory \".\": not implemented on js\nerror: Could not resolve \"index.jsx\"\n```\n\n但可以通过 esbuild 提供的插件机制来解决。\n\n<a name=\"5eb14931\"></a>\n## 亲手尝试一下在浏览器内使用 esbuild 编译\n\n1. 引入 esbuild\n\n```html\n<script src=\"https://www.unpkg.com/esbuild-wasm/lib/browser.min.js\"></script>\n<script>\n    esbuild\n    .initialize({\n        wasmURL: 'https://www.unpkg.com/esbuild-wasm/esbuild.wasm',\n    })\n    .then(() => {\n        build();\n    });\n\n    const build = () => {\n        console.log(esbuild);\n    };\n</script>\n```\n\n2. 使用 esbuild\n\n```javascript\n\nesbuild.build({\n    entryPoints: ['index.jsx'],\n    bundle: true,\n    write: false,\n});\n```\n\n不出意外，你就能看到上面那个错误了，因为在浏览器里， esbuild 并不知道去那里读取 `index.jsx` 这个文件。\n\n3. 使用插件解决在浏览器内读取文件的问题\n\nesbuild 插件格式如下：\n\n```javascript\nconst myPlugin = {\n    name: 'myPlugin',\n    setup: (build) => {\n        build.onResolve({ filter: /.*/ }, (args) => {});\n        build.onLoad({ filter: /.*/ }, (args) => {});\n    },\n};\n```\n\n`onResolve` 是用来解析引入模块的地址的，要求模块的具体地址， `onLoad` 则是根据 `onResolve` 返回的 path 去拿到实际的文件内容。\n\n这个机制正好能解决我们的问题。\n\n```javascript\nconst files = {\n    '/index.jsx': indexJSX,\n    '/App.jsx': appJSX,\n};\nconst myPlugin = {\n    name: 'myPlugin',\n    setup: (build) => {\n        build.onResolve({ filter: /.*/ }, (args) => {\n            // 入口文件单独处理\n            if (args.kind === 'entry-point') {\n                return { path: '/' + args.path };\n            }\n            // 这里只是简单处理一下\n            if (args.path === './App.jsx') {\n                return { path: '/App.jsx' };\n            }\n        });\n        build.onLoad({ filter: /.*/ }, (args) => {\n            if (args.path === '/index.jsx') {\n                return {\n                contents: files['/index.jsx'],\n                loader: 'jsx',\n                };\n            }\n            if (args.path === '/App.jsx') {\n                return {\n                contents: files['/App.jsx'],\n                loader: 'jsx',\n                };\n            }\n            return null;\n        });\n    },\n};\nesbuild.build({\n    entryPoints: ['index.jsx'],\n    bundle: true,\n    write: false,\n    plugins: [myPlugin],\n\n});\n```\n\n如上的插件能解决我们自己的文件引入问题，但控制台还有个错误\n\n```javascript\nUncaught (in promise) Error: Build failed with 2 errors:\nerror: Cannot read directory \".\": not implemented on js\nindex.jsx:1:18: ERROR: Could not resolve \"react\"\n```\n\n针对第三方包，我们并没有处理。我们当然可以继续沿着上面的逻辑处理，去引入 cdn 上的 React 文件，因为 `onLoad` 可以是异步的。<br />这里我们换一种方式，使用 script 标签引入 React 和 ReactDOM ， esbuild 直接使用 window 上的变量。所以继续对插件进行改造。\n\n```javascript\nconst files = {\n    '/index.jsx': indexJSX,\n    '/App.jsx': appJSX,\n};\n\nconst externals = {\n    react: 'React',\n    'react-dom/client': 'ReactDOM',\n};\n\nconst myPlugin = {\n    name: 'myPlugin',\n    setup: (build) => {\n        build.onResolve({ filter: /.*/ }, (args) => {\n            // 入口文件单独处理\n            if (args.kind === 'entry-point') {\n                return { path: '/' + args.path };\n            }\n            // 这里只是简单处理一下\n            if (args.path === './App.jsx') {\n                return { path: '/App.jsx' };\n            }\n            if (Object.keys(externals).includes(args.path)) {\n                return { path: `/externals/${args.path}` };\n            }\n        });\n        build.onLoad({ filter: /.*/ }, (args) => {\n            if (args.path === '/index.jsx') {\n                return {\n                contents: files['/index.jsx'],\n                loader: 'jsx',\n                };\n            }\n            if (args.path === '/App.jsx') {\n                return {\n                contents: files['/App.jsx'],\n                loader: 'jsx',\n                };\n            }\n            if (args.path.startsWith('/externals/')) {\n                const libName = args.path.replace('/externals/', '');\n                const contents = `module.exports = ${externals[libName]}`;\n                return { contents };\n            }\n            return null;\n        });\n    },\n};\n\nconst res = await esbuild.build({\n    entryPoints: ['index.jsx'],\n    bundle: true,\n    write: false,\n    plugins: [myPlugin],\n});\n\nconsole.log(res);\n```\n\n好了能正常编译出来了。但输出的是 `Uint8Array` 。需要 decode 一下。\n\n```javascript\nconst contents = res.outputFiles[0].contents;\nconst decoder = new TextDecoder();\nconst text = decoder.decode(contents);\n```\n\n<a name=\"72d84f85\"></a>\n## 以上最终代码的集合\n\n[use-esbuild-in-browser](https://stackblitz.com/edit/web-platform-tqkzwj?file=index.html)\n",
  "body_draft": "",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><hr id=\"ARlAB\" class=\"ne-hr\"><h2 id=\"32429250\"><span class=\"ne-text\">为什么要在浏览器内编译 React ?</span></h2><p id=\"u618cf27d\" class=\"ne-p\"><br></p><p id=\"u2b09beda\" class=\"ne-p\"><span class=\"ne-text\">博客编写时需要实时预览，使用的 MDX 需要经过编译，预览则采用了 iframe 进行预览，所以我需要把 MDX 编译成 JavaScript ，放到 iframe 里。</span></p><p id=\"ub85fb0fd\" class=\"ne-p\"><br></p><h2 id=\"89269a88\"><span class=\"ne-text\">esbuild 怎么跑在浏览器内的 ?</span></h2><p id=\"u3cafc9eb\" class=\"ne-p\"><br></p><p id=\"u1a3f4913\" class=\"ne-p\"><span class=\"ne-text\">esbuild 提供了 wasm 版本，是支持在浏览器内运行的，具体可以参考</span><a href=\"https://esbuild.github.io/api/#running-in-the-browser\" data-href=\"https://esbuild.github.io/api/#running-in-the-browser\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">官网</span></a><span class=\"ne-text\">。</span></p><p id=\"ud1f97dd6\" class=\"ne-p\"><br></p><h2 id=\"bac5e51d\"><span class=\"ne-text\">esbuild 在浏览器内运行，有啥问题么 ?</span></h2><p id=\"ucb524e21\" class=\"ne-p\"><br></p><p id=\"ubb10e490\" class=\"ne-p\"><span class=\"ne-text\">有的，浏览器内没有文件系统，所以你会看到如下的错误：</span></p><p id=\"u4696adc5\" class=\"ne-p\"><br></p><pre data-language=\"shell\" id=\"1522c139\" class=\"ne-codeblock language-shell\">Uncaught (in promise) Error: Build failed with 3 errors:\nerror: Cannot read directory &quot;.&quot;: not implemented on js\nerror: Cannot read directory &quot;.&quot;: not implemented on js\nerror: Could not resolve &quot;index.jsx&quot;</pre><p id=\"ua1e68d3c\" class=\"ne-p\"><br></p><p id=\"uf2e50499\" class=\"ne-p\"><span class=\"ne-text\">但可以通过 esbuild 提供的插件机制来解决。</span></p><p id=\"ue8527ad2\" class=\"ne-p\"><br></p><h2 id=\"5eb14931\"><span class=\"ne-text\">亲手尝试一下在浏览器内使用 esbuild 编译</span></h2><p id=\"u0bd55192\" class=\"ne-p\"><br></p><ol class=\"ne-ol\"><li id=\"uc6426aaa\"><span class=\"ne-text\">引入 esbuild</span></li></ol><p id=\"u514d9e4d\" class=\"ne-p\"><br></p><pre data-language=\"html\" id=\"3a4d43bd\" class=\"ne-codeblock language-html\">&lt;script src=&quot;https://www.unpkg.com/esbuild-wasm/lib/browser.min.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n    esbuild\n    .initialize({\n        wasmURL: 'https://www.unpkg.com/esbuild-wasm/esbuild.wasm',\n    })\n    .then(() =&gt; {\n        build();\n    });\n\n    const build = () =&gt; {\n        console.log(esbuild);\n    };\n&lt;/script&gt;</pre><p id=\"u81d69dca\" class=\"ne-p\"><br></p><ol start=\"2\" class=\"ne-ol\"><li id=\"u66fc368f\"><span class=\"ne-text\">使用 esbuild</span></li></ol><p id=\"ufb8380fd\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"ca9361c4\" class=\"ne-codeblock language-javascript\">\nesbuild.build({\n    entryPoints: ['index.jsx'],\n    bundle: true,\n    write: false,\n});</pre><p id=\"u890c5263\" class=\"ne-p\"><br></p><p id=\"ub7c9fdae\" class=\"ne-p\"><span class=\"ne-text\">不出意外，你就能看到上面那个错误了，因为在浏览器里， esbuild 并不知道去那里读取 </span><code class=\"ne-code\"><span class=\"ne-text\">index.jsx</span></code><span class=\"ne-text\"> 这个文件。</span></p><p id=\"u3f8acb51\" class=\"ne-p\"><br></p><ol start=\"3\" class=\"ne-ol\"><li id=\"u25890344\"><span class=\"ne-text\">使用插件解决在浏览器内读取文件的问题</span></li></ol><p id=\"u621f86f4\" class=\"ne-p\"><br></p><p id=\"ud4fc839b\" class=\"ne-p\"><span class=\"ne-text\">esbuild 插件格式如下：</span></p><p id=\"u2999980f\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"ddb767b8\" class=\"ne-codeblock language-javascript\">const myPlugin = {\n    name: 'myPlugin',\n    setup: (build) =&gt; {\n        build.onResolve({ filter: /.*/ }, (args) =&gt; {});\n        build.onLoad({ filter: /.*/ }, (args) =&gt; {});\n    },\n};</pre><p id=\"u20ecb903\" class=\"ne-p\"><br></p><p id=\"u1f772a2b\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">onResolve</span></code><span class=\"ne-text\"> 是用来解析引入模块的地址的，要求模块的具体地址， </span><code class=\"ne-code\"><span class=\"ne-text\">onLoad</span></code><span class=\"ne-text\"> 则是根据 </span><code class=\"ne-code\"><span class=\"ne-text\">onResolve</span></code><span class=\"ne-text\"> 返回的 path 去拿到实际的文件内容。</span></p><p id=\"uf19a7485\" class=\"ne-p\"><br></p><p id=\"u106deaf4\" class=\"ne-p\"><span class=\"ne-text\">这个机制正好能解决我们的问题。</span></p><p id=\"uf89f667f\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"4b7ded62\" class=\"ne-codeblock language-javascript\">const files = {\n    '/index.jsx': indexJSX,\n    '/App.jsx': appJSX,\n};\nconst myPlugin = {\n    name: 'myPlugin',\n    setup: (build) =&gt; {\n        build.onResolve({ filter: /.*/ }, (args) =&gt; {\n            // 入口文件单独处理\n            if (args.kind === 'entry-point') {\n                return { path: '/' + args.path };\n            }\n            // 这里只是简单处理一下\n            if (args.path === './App.jsx') {\n                return { path: '/App.jsx' };\n            }\n        });\n        build.onLoad({ filter: /.*/ }, (args) =&gt; {\n            if (args.path === '/index.jsx') {\n                return {\n                contents: files['/index.jsx'],\n                loader: 'jsx',\n                };\n            }\n            if (args.path === '/App.jsx') {\n                return {\n                contents: files['/App.jsx'],\n                loader: 'jsx',\n                };\n            }\n            return null;\n        });\n    },\n};\nesbuild.build({\n    entryPoints: ['index.jsx'],\n    bundle: true,\n    write: false,\n    plugins: [myPlugin],\n\n});</pre><p id=\"ue6340640\" class=\"ne-p\"><br></p><p id=\"u38ba0319\" class=\"ne-p\"><span class=\"ne-text\">如上的插件能解决我们自己的文件引入问题，但控制台还有个错误</span></p><p id=\"u207cd7f0\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"5dca8641\" class=\"ne-codeblock language-javascript\">Uncaught (in promise) Error: Build failed with 2 errors:\nerror: Cannot read directory &quot;.&quot;: not implemented on js\nindex.jsx:1:18: ERROR: Could not resolve &quot;react&quot;</pre><p id=\"ud10661b4\" class=\"ne-p\"><br></p><p id=\"udd1818c7\" class=\"ne-p\"><span class=\"ne-text\">针对第三方包，我们并没有处理。我们当然可以继续沿着上面的逻辑处理，去引入 cdn 上的 React 文件，因为 </span><code class=\"ne-code\"><span class=\"ne-text\">onLoad</span></code><span class=\"ne-text\"> 可以是异步的。<br /></span><span class=\"ne-text\">这里我们换一种方式，使用 script 标签引入 React 和 ReactDOM ， esbuild 直接使用 window 上的变量。所以继续对插件进行改造。</span></p><p id=\"uf250d281\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"f1fc0020\" class=\"ne-codeblock language-javascript\">const files = {\n    '/index.jsx': indexJSX,\n    '/App.jsx': appJSX,\n};\n\nconst externals = {\n    react: 'React',\n    'react-dom/client': 'ReactDOM',\n};\n\nconst myPlugin = {\n    name: 'myPlugin',\n    setup: (build) =&gt; {\n        build.onResolve({ filter: /.*/ }, (args) =&gt; {\n            // 入口文件单独处理\n            if (args.kind === 'entry-point') {\n                return { path: '/' + args.path };\n            }\n            // 这里只是简单处理一下\n            if (args.path === './App.jsx') {\n                return { path: '/App.jsx' };\n            }\n            if (Object.keys(externals).includes(args.path)) {\n                return { path: `/externals/${args.path}` };\n            }\n        });\n        build.onLoad({ filter: /.*/ }, (args) =&gt; {\n            if (args.path === '/index.jsx') {\n                return {\n                contents: files['/index.jsx'],\n                loader: 'jsx',\n                };\n            }\n            if (args.path === '/App.jsx') {\n                return {\n                contents: files['/App.jsx'],\n                loader: 'jsx',\n                };\n            }\n            if (args.path.startsWith('/externals/')) {\n                const libName = args.path.replace('/externals/', '');\n                const contents = `module.exports = ${externals[libName]}`;\n                return { contents };\n            }\n            return null;\n        });\n    },\n};\n\nconst res = await esbuild.build({\n    entryPoints: ['index.jsx'],\n    bundle: true,\n    write: false,\n    plugins: [myPlugin],\n});\n\nconsole.log(res);</pre><p id=\"u01fcfe4e\" class=\"ne-p\"><br></p><p id=\"u8ab9aaee\" class=\"ne-p\"><span class=\"ne-text\">好了能正常编译出来了。但输出的是 </span><code class=\"ne-code\"><span class=\"ne-text\">Uint8Array</span></code><span class=\"ne-text\"> 。需要 decode 一下。</span></p><p id=\"u0ec59fd6\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"91020cb8\" class=\"ne-codeblock language-javascript\">const contents = res.outputFiles[0].contents;\nconst decoder = new TextDecoder();\nconst text = decoder.decode(contents);</pre><p id=\"u619e5647\" class=\"ne-p\"><br></p><h2 id=\"72d84f85\"><span class=\"ne-text\">以上最终代码的集合</span></h2><p id=\"u2ee0ddd3\" class=\"ne-p\"><br></p><p id=\"ue592baa0\" class=\"ne-p\"><a href=\"https://stackblitz.com/edit/web-platform-tqkzwj?file=index.html\" data-href=\"https://stackblitz.com/edit/web-platform-tqkzwj?file=index.html\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">use-esbuild-in-browser</span></a></p></div>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"fixed\" /><meta name=\"paragraphSpacing\" content=\"relax\" /><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22ARlAB%22%7D\"></card><h2 data-lake-id=\"32429250\" id=\"32429250\"><span data-lake-id=\"udccc0564\" id=\"udccc0564\">为什么要在浏览器内编译 React ?</span></h2><p data-lake-id=\"u618cf27d\" id=\"u618cf27d\"><br></p><p data-lake-id=\"u2b09beda\" id=\"u2b09beda\"><span data-lake-id=\"u949de551\" id=\"u949de551\">博客编写时需要实时预览，使用的 MDX 需要经过编译，预览则采用了 iframe 进行预览，所以我需要把 MDX 编译成 JavaScript ，放到 iframe 里。</span></p><p data-lake-id=\"ub85fb0fd\" id=\"ub85fb0fd\"><br></p><h2 data-lake-id=\"89269a88\" id=\"89269a88\"><span data-lake-id=\"ud8a60f23\" id=\"ud8a60f23\">esbuild 怎么跑在浏览器内的 ?</span></h2><p data-lake-id=\"u3cafc9eb\" id=\"u3cafc9eb\"><br></p><p data-lake-id=\"u1a3f4913\" id=\"u1a3f4913\"><span data-lake-id=\"uf25a043a\" id=\"uf25a043a\">esbuild 提供了 wasm 版本，是支持在浏览器内运行的，具体可以参考</span><a href=\"https://esbuild.github.io/api/#running-in-the-browser\" target=\"_blank\" data-lake-id=\"u97f61bd4\" id=\"u97f61bd4\"><span data-lake-id=\"u8f9a17ea\" id=\"u8f9a17ea\">官网</span></a><span data-lake-id=\"u6c238437\" id=\"u6c238437\">。</span></p><p data-lake-id=\"ud1f97dd6\" id=\"ud1f97dd6\"><br></p><h2 data-lake-id=\"bac5e51d\" id=\"bac5e51d\"><span data-lake-id=\"ucb7b064e\" id=\"ucb7b064e\">esbuild 在浏览器内运行，有啥问题么 ?</span></h2><p data-lake-id=\"ucb524e21\" id=\"ucb524e21\"><br></p><p data-lake-id=\"ubb10e490\" id=\"ubb10e490\"><span data-lake-id=\"u9e7cc43e\" id=\"u9e7cc43e\">有的，浏览器内没有文件系统，所以你会看到如下的错误：</span></p><p data-lake-id=\"u4696adc5\" id=\"u4696adc5\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22shell%22%2C%22code%22%3A%22Uncaught%20(in%20promise)%20Error%3A%20Build%20failed%20with%203%20errors%3A%5Cnerror%3A%20Cannot%20read%20directory%20%5C%22.%5C%22%3A%20not%20implemented%20on%20js%5Cnerror%3A%20Cannot%20read%20directory%20%5C%22.%5C%22%3A%20not%20implemented%20on%20js%5Cnerror%3A%20Could%20not%20resolve%20%5C%22index.jsx%5C%22%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%221522c139%22%7D\"></card><p data-lake-id=\"ua1e68d3c\" id=\"ua1e68d3c\"><br></p><p data-lake-id=\"uf2e50499\" id=\"uf2e50499\"><span data-lake-id=\"u81ebe60f\" id=\"u81ebe60f\">但可以通过 esbuild 提供的插件机制来解决。</span></p><p data-lake-id=\"ue8527ad2\" id=\"ue8527ad2\"><br></p><h2 data-lake-id=\"5eb14931\" id=\"5eb14931\"><span data-lake-id=\"u0748cf0e\" id=\"u0748cf0e\">亲手尝试一下在浏览器内使用 esbuild 编译</span></h2><p data-lake-id=\"u0bd55192\" id=\"u0bd55192\"><br></p><ol list=\"u61e7108a\"><li fid=\"u9b4af0d9\" data-lake-id=\"uc6426aaa\" id=\"uc6426aaa\"><span data-lake-id=\"ufd5b5653\" id=\"ufd5b5653\">引入 esbuild</span></li></ol><p data-lake-id=\"u514d9e4d\" id=\"u514d9e4d\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22html%22%2C%22code%22%3A%22%3Cscript%20src%3D%5C%22https%3A%2F%2Fwww.unpkg.com%2Fesbuild-wasm%2Flib%2Fbrowser.min.js%5C%22%3E%3C%2Fscript%3E%5Cn%3Cscript%3E%5Cn%20%20%20%20esbuild%5Cn%20%20%20%20.initialize(%7B%5Cn%20%20%20%20%20%20%20%20wasmURL%3A%20'https%3A%2F%2Fwww.unpkg.com%2Fesbuild-wasm%2Fesbuild.wasm'%2C%5Cn%20%20%20%20%7D)%5Cn%20%20%20%20.then(()%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20build()%3B%5Cn%20%20%20%20%7D)%3B%5Cn%5Cn%20%20%20%20const%20build%20%3D%20()%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20console.log(esbuild)%3B%5Cn%20%20%20%20%7D%3B%5Cn%3C%2Fscript%3E%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%223a4d43bd%22%7D\"></card><p data-lake-id=\"u81d69dca\" id=\"u81d69dca\"><br></p><ol list=\"u0d0da31a\" start=\"2\"><li fid=\"u5619c8c7\" data-lake-id=\"u66fc368f\" id=\"u66fc368f\"><span data-lake-id=\"u4eb1566f\" id=\"u4eb1566f\">使用 esbuild</span></li></ol><p data-lake-id=\"ufb8380fd\" id=\"ufb8380fd\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%5Cnesbuild.build(%7B%5Cn%20%20%20%20entryPoints%3A%20%5B'index.jsx'%5D%2C%5Cn%20%20%20%20bundle%3A%20true%2C%5Cn%20%20%20%20write%3A%20false%2C%5Cn%7D)%3B%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22ca9361c4%22%7D\"></card><p data-lake-id=\"u890c5263\" id=\"u890c5263\"><br></p><p data-lake-id=\"ub7c9fdae\" id=\"ub7c9fdae\"><span data-lake-id=\"u7500db1f\" id=\"u7500db1f\">不出意外，你就能看到上面那个错误了，因为在浏览器里， esbuild 并不知道去那里读取 </span><code data-lake-id=\"u7a5179c7\" id=\"u7a5179c7\"><span data-lake-id=\"ubc695e11\" id=\"ubc695e11\">index.jsx</span></code><span data-lake-id=\"u6cd6f3f0\" id=\"u6cd6f3f0\"> 这个文件。</span></p><p data-lake-id=\"u3f8acb51\" id=\"u3f8acb51\"><br></p><ol list=\"uf4e0ca1c\" start=\"3\"><li fid=\"u27098bb9\" data-lake-id=\"u25890344\" id=\"u25890344\"><span data-lake-id=\"u565730fb\" id=\"u565730fb\">使用插件解决在浏览器内读取文件的问题</span></li></ol><p data-lake-id=\"u621f86f4\" id=\"u621f86f4\"><br></p><p data-lake-id=\"ud4fc839b\" id=\"ud4fc839b\"><span data-lake-id=\"ucb2d00ac\" id=\"ucb2d00ac\">esbuild 插件格式如下：</span></p><p data-lake-id=\"u2999980f\" id=\"u2999980f\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20myPlugin%20%3D%20%7B%5Cn%20%20%20%20name%3A%20'myPlugin'%2C%5Cn%20%20%20%20setup%3A%20(build)%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20build.onResolve(%7B%20filter%3A%20%2F.*%2F%20%7D%2C%20(args)%20%3D%3E%20%7B%7D)%3B%5Cn%20%20%20%20%20%20%20%20build.onLoad(%7B%20filter%3A%20%2F.*%2F%20%7D%2C%20(args)%20%3D%3E%20%7B%7D)%3B%5Cn%20%20%20%20%7D%2C%5Cn%7D%3B%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22ddb767b8%22%7D\"></card><p data-lake-id=\"u20ecb903\" id=\"u20ecb903\"><br></p><p data-lake-id=\"u1f772a2b\" id=\"u1f772a2b\"><code data-lake-id=\"uf95d8901\" id=\"uf95d8901\"><span data-lake-id=\"ucd46824f\" id=\"ucd46824f\">onResolve</span></code><span data-lake-id=\"ua63c21ce\" id=\"ua63c21ce\"> 是用来解析引入模块的地址的，要求模块的具体地址， </span><code data-lake-id=\"u680441c2\" id=\"u680441c2\"><span data-lake-id=\"u6d25d7fb\" id=\"u6d25d7fb\">onLoad</span></code><span data-lake-id=\"u50e74ec7\" id=\"u50e74ec7\"> 则是根据 </span><code data-lake-id=\"uea3e7a7b\" id=\"uea3e7a7b\"><span data-lake-id=\"uf2d70aa6\" id=\"uf2d70aa6\">onResolve</span></code><span data-lake-id=\"ub03546da\" id=\"ub03546da\"> 返回的 path 去拿到实际的文件内容。</span></p><p data-lake-id=\"uf19a7485\" id=\"uf19a7485\"><br></p><p data-lake-id=\"u106deaf4\" id=\"u106deaf4\"><span data-lake-id=\"u985c5eea\" id=\"u985c5eea\">这个机制正好能解决我们的问题。</span></p><p data-lake-id=\"uf89f667f\" id=\"uf89f667f\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20files%20%3D%20%7B%5Cn%20%20%20%20'%2Findex.jsx'%3A%20indexJSX%2C%5Cn%20%20%20%20'%2FApp.jsx'%3A%20appJSX%2C%5Cn%7D%3B%5Cnconst%20myPlugin%20%3D%20%7B%5Cn%20%20%20%20name%3A%20'myPlugin'%2C%5Cn%20%20%20%20setup%3A%20(build)%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20build.onResolve(%7B%20filter%3A%20%2F.*%2F%20%7D%2C%20(args)%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6%E5%8D%95%E7%8B%AC%E5%A4%84%E7%90%86%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(args.kind%20%3D%3D%3D%20'entry-point')%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20%7B%20path%3A%20'%2F'%20%2B%20args.path%20%7D%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E8%BF%99%E9%87%8C%E5%8F%AA%E6%98%AF%E7%AE%80%E5%8D%95%E5%A4%84%E7%90%86%E4%B8%80%E4%B8%8B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(args.path%20%3D%3D%3D%20'.%2FApp.jsx')%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20%7B%20path%3A%20'%2FApp.jsx'%20%7D%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%7D)%3B%5Cn%20%20%20%20%20%20%20%20build.onLoad(%7B%20filter%3A%20%2F.*%2F%20%7D%2C%20(args)%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(args.path%20%3D%3D%3D%20'%2Findex.jsx')%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20contents%3A%20files%5B'%2Findex.jsx'%5D%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20loader%3A%20'jsx'%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(args.path%20%3D%3D%3D%20'%2FApp.jsx')%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20contents%3A%20files%5B'%2FApp.jsx'%5D%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20loader%3A%20'jsx'%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20return%20null%3B%5Cn%20%20%20%20%20%20%20%20%7D)%3B%5Cn%20%20%20%20%7D%2C%5Cn%7D%3B%5Cnesbuild.build(%7B%5Cn%20%20%20%20entryPoints%3A%20%5B'index.jsx'%5D%2C%5Cn%20%20%20%20bundle%3A%20true%2C%5Cn%20%20%20%20write%3A%20false%2C%5Cn%20%20%20%20plugins%3A%20%5BmyPlugin%5D%2C%5Cn%5Cn%7D)%3B%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%224b7ded62%22%7D\"></card><p data-lake-id=\"ue6340640\" id=\"ue6340640\"><br></p><p data-lake-id=\"u38ba0319\" id=\"u38ba0319\"><span data-lake-id=\"u24209388\" id=\"u24209388\">如上的插件能解决我们自己的文件引入问题，但控制台还有个错误</span></p><p data-lake-id=\"u207cd7f0\" id=\"u207cd7f0\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22Uncaught%20(in%20promise)%20Error%3A%20Build%20failed%20with%202%20errors%3A%5Cnerror%3A%20Cannot%20read%20directory%20%5C%22.%5C%22%3A%20not%20implemented%20on%20js%5Cnindex.jsx%3A1%3A18%3A%20ERROR%3A%20Could%20not%20resolve%20%5C%22react%5C%22%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%225dca8641%22%7D\"></card><p data-lake-id=\"ud10661b4\" id=\"ud10661b4\"><br></p><p data-lake-id=\"udd1818c7\" id=\"udd1818c7\"><span data-lake-id=\"u136d0540\" id=\"u136d0540\">针对第三方包，我们并没有处理。我们当然可以继续沿着上面的逻辑处理，去引入 cdn 上的 React 文件，因为 </span><code data-lake-id=\"u552833a5\" id=\"u552833a5\"><span data-lake-id=\"uab3ce76a\" id=\"uab3ce76a\">onLoad</span></code><span data-lake-id=\"uc27a6a14\" id=\"uc27a6a14\"> 可以是异步的。<br /></span><span data-lake-id=\"u8536e11e\" id=\"u8536e11e\">这里我们换一种方式，使用 script 标签引入 React 和 ReactDOM ， esbuild 直接使用 window 上的变量。所以继续对插件进行改造。</span></p><p data-lake-id=\"uf250d281\" id=\"uf250d281\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20files%20%3D%20%7B%5Cn%20%20%20%20'%2Findex.jsx'%3A%20indexJSX%2C%5Cn%20%20%20%20'%2FApp.jsx'%3A%20appJSX%2C%5Cn%7D%3B%5Cn%5Cnconst%20externals%20%3D%20%7B%5Cn%20%20%20%20react%3A%20'React'%2C%5Cn%20%20%20%20'react-dom%2Fclient'%3A%20'ReactDOM'%2C%5Cn%7D%3B%5Cn%5Cnconst%20myPlugin%20%3D%20%7B%5Cn%20%20%20%20name%3A%20'myPlugin'%2C%5Cn%20%20%20%20setup%3A%20(build)%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20build.onResolve(%7B%20filter%3A%20%2F.*%2F%20%7D%2C%20(args)%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6%E5%8D%95%E7%8B%AC%E5%A4%84%E7%90%86%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(args.kind%20%3D%3D%3D%20'entry-point')%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20%7B%20path%3A%20'%2F'%20%2B%20args.path%20%7D%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E8%BF%99%E9%87%8C%E5%8F%AA%E6%98%AF%E7%AE%80%E5%8D%95%E5%A4%84%E7%90%86%E4%B8%80%E4%B8%8B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(args.path%20%3D%3D%3D%20'.%2FApp.jsx')%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20%7B%20path%3A%20'%2FApp.jsx'%20%7D%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(Object.keys(externals).includes(args.path))%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20%7B%20path%3A%20%60%2Fexternals%2F%24%7Bargs.path%7D%60%20%7D%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%7D)%3B%5Cn%20%20%20%20%20%20%20%20build.onLoad(%7B%20filter%3A%20%2F.*%2F%20%7D%2C%20(args)%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(args.path%20%3D%3D%3D%20'%2Findex.jsx')%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20contents%3A%20files%5B'%2Findex.jsx'%5D%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20loader%3A%20'jsx'%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(args.path%20%3D%3D%3D%20'%2FApp.jsx')%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20contents%3A%20files%5B'%2FApp.jsx'%5D%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20loader%3A%20'jsx'%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(args.path.startsWith('%2Fexternals%2F'))%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20const%20libName%20%3D%20args.path.replace('%2Fexternals%2F'%2C%20'')%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20const%20contents%20%3D%20%60module.exports%20%3D%20%24%7Bexternals%5BlibName%5D%7D%60%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20%7B%20contents%20%7D%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20return%20null%3B%5Cn%20%20%20%20%20%20%20%20%7D)%3B%5Cn%20%20%20%20%7D%2C%5Cn%7D%3B%5Cn%5Cnconst%20res%20%3D%20await%20esbuild.build(%7B%5Cn%20%20%20%20entryPoints%3A%20%5B'index.jsx'%5D%2C%5Cn%20%20%20%20bundle%3A%20true%2C%5Cn%20%20%20%20write%3A%20false%2C%5Cn%20%20%20%20plugins%3A%20%5BmyPlugin%5D%2C%5Cn%7D)%3B%5Cn%5Cnconsole.log(res)%3B%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22f1fc0020%22%7D\"></card><p data-lake-id=\"u01fcfe4e\" id=\"u01fcfe4e\"><br></p><p data-lake-id=\"u8ab9aaee\" id=\"u8ab9aaee\"><span data-lake-id=\"u43dd69d7\" id=\"u43dd69d7\">好了能正常编译出来了。但输出的是 </span><code data-lake-id=\"ufe42a5f9\" id=\"ufe42a5f9\"><span data-lake-id=\"u5dd9f06e\" id=\"u5dd9f06e\">Uint8Array</span></code><span data-lake-id=\"u28a737aa\" id=\"u28a737aa\"> 。需要 decode 一下。</span></p><p data-lake-id=\"u0ec59fd6\" id=\"u0ec59fd6\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20contents%20%3D%20res.outputFiles%5B0%5D.contents%3B%5Cnconst%20decoder%20%3D%20new%20TextDecoder()%3B%5Cnconst%20text%20%3D%20decoder.decode(contents)%3B%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%2291020cb8%22%7D\"></card><p data-lake-id=\"u619e5647\" id=\"u619e5647\"><br></p><h2 data-lake-id=\"72d84f85\" id=\"72d84f85\"><span data-lake-id=\"ubda3a2ef\" id=\"ubda3a2ef\">以上最终代码的集合</span></h2><p data-lake-id=\"u2ee0ddd3\" id=\"u2ee0ddd3\"><br></p><p data-lake-id=\"ue592baa0\" id=\"ue592baa0\"><a href=\"https://stackblitz.com/edit/web-platform-tqkzwj?file=index.html\" target=\"_blank\" data-lake-id=\"ubde9e901\" id=\"ubde9e901\"><span data-lake-id=\"u0c08c697\" id=\"u0c08c697\">use-esbuild-in-browser</span></a></p>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2023-01-31T01:53:45.000Z",
  "deleted_at": null,
  "created_at": "2023-01-31T01:51:27.000Z",
  "updated_at": "2023-01-31T01:53:45.000Z",
  "published_at": "2023-01-31T01:53:45.000Z",
  "first_published_at": "2023-01-31T01:53:44.870Z",
  "word_count": 879,
  "cover": null,
  "description": "为什么要在浏览器内编译 React ?博客编写时需要实时预览，使用的 MDX 需要经过编译，预览则采用了 iframe 进行预览，所以我需要把 MDX 编译成 JavaScript ，放到 iframe 里。esbuild 怎么跑在浏览器内的 ?esbuild 提供了 wasm 版本，是支持在...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}