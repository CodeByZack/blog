{
  "id": 47178335,
  "slug": "fdgzy3",
  "title": "TypeScript入门",
  "book_id": 231593,
  "book": {
    "id": 231593,
    "type": "Book",
    "slug": "web",
    "name": "WEB",
    "user_id": 284138,
    "description": "前端知识点记录",
    "creator_id": 284138,
    "public": 1,
    "items_count": 58,
    "likes_count": 0,
    "watches_count": 3,
    "content_updated_at": "2023-02-02T09:09:21.426Z",
    "updated_at": "2023-02-02T09:09:21.000Z",
    "created_at": "2019-03-07T05:05:08.000Z",
    "namespace": "zackdk/web",
    "user": {
      "id": 284138,
      "type": "User",
      "login": "zackdk",
      "name": "行一度空山",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1551934932702-d412771d-8d33-4694-9186-a749a3b4e05b.jpeg",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 5,
      "following_count": 0,
      "created_at": "2019-03-07T05:02:38.000Z",
      "updated_at": "2023-02-01T12:18:25.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 284138,
  "creator": {
    "id": 284138,
    "type": "User",
    "login": "zackdk",
    "name": "行一度空山",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1551934932702-d412771d-8d33-4694-9186-a749a3b4e05b.jpeg",
    "books_count": 2,
    "public_books_count": 1,
    "followers_count": 5,
    "following_count": 0,
    "created_at": "2019-03-07T05:02:38.000Z",
    "updated_at": "2023-02-01T12:18:25.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "<a name=\"28672e27\"></a>\n## 基础类型\n\n<a name=\"5e44db3d\"></a>\n### 原始值类型\n\n原始值类型，ts 会自动推导出来。\n\n类型语法：string，number，boolean\n\n```typescript\nconst a: string = 'hello ts';\nconst b: number = 2;\nconst c: boolean = true;\n```\n\n需要注意的是：String, Number, Boolean 在 TS 里都是有效值，但平时使用中几乎不会用到。\n\n<a name=\"f45a735a\"></a>\n### 数组类型\n\n如下定义：\n\n```typescript\n// 可以使用[]进行类型定义\nconst numArr: number[] = [1, 2, 3];\nconst strArr: string[] = ['1', '2', '3'];\nconst booleanArr: boolean[] = [true, false];\n\n// 也可以使用Array<T>进行类型定义\nconst numArr: Arrary<number> = [1, 2, 3];\nconst strArr: Arrary<string> = ['1', '2', '3'];\nconst booleanArr: Arrary<boolean> = [true, false];\n```\n\n<a name=\"25009be8\"></a>\n### 函数类型\n\n函数主要定义入参和出参的类型：\n\n```typescript\n// function 定义\nfunction identify(params: string): string {\n  return params;\n}\n\nconst identify2 = function (params: number): number {\n  return params;\n};\n\n// 箭头函数\nconst arrowFunc = (i: boolean): boolean => {\n  return i;\n};\n\nexport type identifyType = typeof identify;\nexport type identify2Type = typeof identify2;\nexport type identify3Type = typeof arrowFunc;\n```\n\ntodo-函数重载\n\n<a name=\"1e767357\"></a>\n### 对象类型\n\n最常用的类型，使用 ?: 可以让某个属性可选。\n\n```typescript\nconst obj: {\n  x: number;\n  z: boolean;\n  c?: string;\n} = {\n  x: 1,\n  z: false,\n  c: '',\n};\n```\n\n<a name=\"0359e3b7\"></a>\n### 联合类型（Union Types）\n\n简单来说就是，一个变量可能有多个类型选项。\n\n当一个函数入参可能是这种类型，或者是那种类型。就可以使用联合类型。如下：\n\n```typescript\nconst printId = (id: number | string) => {\n  console.log('Your ID is: ' + id);\n};\n\nprintId(1);\nprintId('str');\n// printId(true); 此处会提示类型错误\n```\n\n有一个问题，既然变量可能有多个类型定义，你就不能只使用属于某个类型定义的属性。\n\n```typescript\nconst printId = (id: number | string) => {\n  console.log(id.toUpperCase()); // 此处会提示类型错误\n};\n```\n\n此时你需要做一个操作，类型收窄，即判断了类型再使用相应类型的属性。\n\n```typescript\nconst printId = (id: number | string) => {\n  if (typeof id === 'string') {\n    // In this branch, id is of type 'string'\n    console.log(id.toUpperCase());\n  } else {\n    // Here, id is of type 'number'\n    console.log(id);\n  }\n};\n```\n\n<a name=\"0733e651\"></a>\n### 类型别名（Type Aliases）\n\n上面都是直接在变量后面追加类型定义，很方便，但是不方便复用。这个时候你就可以考虑类型别名。\n\n```typescript\n// 对象类型 别名Point\ntype Point = {\n  x: number;\n  y: number;\n};\n\n// 联合类型 别名ID\ntype ID = string | number;\n```\n\n<a name=\"d1ef6fc6\"></a>\n### 接口类型（Interfaces）\n\n还有一种方式定义对象类型的别名。\n\n```typescript\ninterface Point {\n  x: number;\n  y: number;\n}\n```\n\n接口类型和类型别名的差异\n\n![](https://zackdkblog.oss-cn-beijing.aliyuncs.com/images/typescript-intro/interface-type-diff.png#id=UFqqg&originHeight=1269&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)\n\n搬官网的，<br />interface 可以使用 extends 继承。定义多个同名 interface 可以合并属性。\n\nType 可以使用 & 进行继承合并。多个同名 Type 会报错。\n\n个人补充一点，类型计算一般都使用的 Type . 无法使用 interface .\n\n```typescript\n// 以下会报错\ninterface I<T>{\n   [i in keyof T] : T[i]\n}\n\n// 以下不会\nexport type D<T> = {\n  [i in keyof T]: T[i];\n};\n```\n\n<a name=\"89a8faee\"></a>\n### 类型断言\n\n有些时候，typescript 并不能推断出具体的类型。\n\n像下面这样的\n\n```typescript\nconst myCanvas = document.getElementById('main_canvas');\n```\n\ntypescript 只能推断出它属于`HTMLElement`类型，但你是明确知道元素是`HTMLCanvasElement`。这种时候你就可以使用类型断言，像下面这样\n\n```typescript\nconst myCanvas = document.getElementById('main_canvas') as HTMLCanvasElement;\n```\n\n<a name=\"7d4bfe47\"></a>\n### 字面量类型\n\n字面量类型，顾名思义就是像下面这样，`a`的类型就固定为`test`了，不是`string`。\n\n```typescript\nlet a: 'test' = 'test';\n```\n\n需要特别注意的是，取决于 Javascript 声明变量的方式，TS 会推断出不同的类型。`let`、`var`声明的变量都允许修改。`const`则不允许。\n\n因此对于`let`、`var`声明的变量：\n\n```typescript\nlet str = 'str'; // 推断为 string 类型\nlet num = 'num'; // 推断为 number 类型\nlet b = true; // 推断为 boolean 类型\n```\n\n对于`const`声明的变量：\n\n```typescript\nconst str = 'str'; // 推断为字面量 'str' 类型\nconst num = 'num'; // 推断为字面量 'num' 类型\nconst b = true; // 推断为字面量 true 类型\n```\n\n但当在用 const 声明一个对象时，TS 会默认该对象的属性都是可以修改的。所以推断出的类型都是基本类型。如果你想推断为字面量的类型，需要在后面加上`as const`，示例如下：\n\n```typescript\n// 以下推断出的类型为\ninterface {\n  url : string;\n  method : string;\n}\nconst req = { url: \"https://example.com\", method: \"GET\" };\n\n// 以下推断出的类型为\ninterface {\n  url : \"https://example.com\";\n  method : \"GET\";\n}\n\nconst req = { url: \"https://example.com\", method: \"GET\" } as const;\n```\n\n<a name=\"741a5868\"></a>\n### null、undefined\n\n`JavaScript`有两个特殊的类型`null`和`undefined`用于代表不存在或者未初始化。\n\n`TypeScript`也有这两个相对应的类型的定义`null`和`undefined`。\n\n这两个类型和`strictNullChecks`配置相关，当配置为`off`时，这两个类型可以赋值给任意类型，不会报错。当配置为`on`时，使用之前需要先检查是否为空，否则`TS`会提示错误。\n\n```typescript\nfunction doSomething(x: string | null) {\n  if (x === null) {\n    // do nothing\n  } else {\n    console.log('Hello, ' + x.toUpperCase());\n  }\n}\n```\n\n你也可以使用`!`进行非空断言，但需要注意的是，类型断言不会影响代码运行时的行为，你需要自己确保这个值不会为空值。\n\n```typescript\nfunction liveDangerously(x?: number | null) {\n  // No error\n  console.log(x!.toFixed());\n}\n```\n\n<a name=\"enum\"></a>\n### enum\n\n枚举是 `TypeScript` 添加到 `JavaScript` 的一项功能，与其它类型不同的是，枚举是会添加代码到运行时的，也就是说会影响你的代码。所以在使用枚举之前，确保你知道自己在做什么。\n\n",
  "body_draft": "",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><h2 id=\"28672e27\"><span class=\"ne-text\">基础类型</span></h2><p id=\"uf1c87962\" class=\"ne-p\"><br></p><h3 id=\"5e44db3d\"><span class=\"ne-text\">原始值类型</span></h3><p id=\"u5998f88c\" class=\"ne-p\"><br></p><p id=\"uf9a69c1f\" class=\"ne-p\"><span class=\"ne-text\">原始值类型，ts 会自动推导出来。</span></p><p id=\"ucdbe69ab\" class=\"ne-p\"><br></p><p id=\"u8b4f5025\" class=\"ne-p\"><span class=\"ne-text\">类型语法：string，number，boolean</span></p><p id=\"u9e6de61d\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"677d76b6\" class=\"ne-codeblock language-typescript\">const a: string = 'hello ts';\nconst b: number = 2;\nconst c: boolean = true;</pre><p id=\"u89f85bb1\" class=\"ne-p\"><br></p><p id=\"u830cc471\" class=\"ne-p\"><span class=\"ne-text\">需要注意的是：String, Number, Boolean 在 TS 里都是有效值，但平时使用中几乎不会用到。</span></p><p id=\"ue9524baf\" class=\"ne-p\"><br></p><h3 id=\"f45a735a\"><span class=\"ne-text\">数组类型</span></h3><p id=\"ucc1c2f0f\" class=\"ne-p\"><br></p><p id=\"u30a49844\" class=\"ne-p\"><span class=\"ne-text\">如下定义：</span></p><p id=\"udddffda6\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"95564848\" class=\"ne-codeblock language-typescript\">// 可以使用[]进行类型定义\nconst numArr: number[] = [1, 2, 3];\nconst strArr: string[] = ['1', '2', '3'];\nconst booleanArr: boolean[] = [true, false];\n\n// 也可以使用Array&lt;T&gt;进行类型定义\nconst numArr: Arrary&lt;number&gt; = [1, 2, 3];\nconst strArr: Arrary&lt;string&gt; = ['1', '2', '3'];\nconst booleanArr: Arrary&lt;boolean&gt; = [true, false];</pre><p id=\"u90a27ecf\" class=\"ne-p\"><br></p><h3 id=\"25009be8\"><span class=\"ne-text\">函数类型</span></h3><p id=\"ub6658238\" class=\"ne-p\"><br></p><p id=\"u906dda83\" class=\"ne-p\"><span class=\"ne-text\">函数主要定义入参和出参的类型：</span></p><p id=\"u60ac9e43\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"860a65fd\" class=\"ne-codeblock language-typescript\">// function 定义\nfunction identify(params: string): string {\n  return params;\n}\n\nconst identify2 = function (params: number): number {\n  return params;\n};\n\n// 箭头函数\nconst arrowFunc = (i: boolean): boolean =&gt; {\n  return i;\n};\n\nexport type identifyType = typeof identify;\nexport type identify2Type = typeof identify2;\nexport type identify3Type = typeof arrowFunc;</pre><p id=\"u4bf5a346\" class=\"ne-p\"><br></p><p id=\"ud73061ed\" class=\"ne-p\"><span class=\"ne-text\">todo-函数重载</span></p><p id=\"uec35696d\" class=\"ne-p\"><br></p><h3 id=\"1e767357\"><span class=\"ne-text\">对象类型</span></h3><p id=\"uf0eb3119\" class=\"ne-p\"><br></p><p id=\"u884c3afe\" class=\"ne-p\"><span class=\"ne-text\">最常用的类型，使用 ?: 可以让某个属性可选。</span></p><p id=\"ue2cc6507\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"e21ed8cf\" class=\"ne-codeblock language-typescript\">const obj: {\n  x: number;\n  z: boolean;\n  c?: string;\n} = {\n  x: 1,\n  z: false,\n  c: '',\n};</pre><p id=\"u147b7f6a\" class=\"ne-p\"><br></p><h3 id=\"0359e3b7\"><span class=\"ne-text\">联合类型（Union Types）</span></h3><p id=\"uc7080120\" class=\"ne-p\"><br></p><p id=\"u1a6ea3ba\" class=\"ne-p\"><span class=\"ne-text\">简单来说就是，一个变量可能有多个类型选项。</span></p><p id=\"u468331fb\" class=\"ne-p\"><br></p><p id=\"ubc95ccaa\" class=\"ne-p\"><span class=\"ne-text\">当一个函数入参可能是这种类型，或者是那种类型。就可以使用联合类型。如下：</span></p><p id=\"u4b400116\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"f2f008e5\" class=\"ne-codeblock language-typescript\">const printId = (id: number | string) =&gt; {\n  console.log('Your ID is: ' + id);\n};\n\nprintId(1);\nprintId('str');\n// printId(true); 此处会提示类型错误</pre><p id=\"u0a94105e\" class=\"ne-p\"><br></p><p id=\"u6baf8282\" class=\"ne-p\"><span class=\"ne-text\">有一个问题，既然变量可能有多个类型定义，你就不能只使用属于某个类型定义的属性。</span></p><p id=\"u8d120474\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"b0916ab2\" class=\"ne-codeblock language-typescript\">const printId = (id: number | string) =&gt; {\n  console.log(id.toUpperCase()); // 此处会提示类型错误\n};</pre><p id=\"uf2510dd0\" class=\"ne-p\"><br></p><p id=\"uc51f5fcf\" class=\"ne-p\"><span class=\"ne-text\">此时你需要做一个操作，类型收窄，即判断了类型再使用相应类型的属性。</span></p><p id=\"ufaa44c9e\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"be9b3fb5\" class=\"ne-codeblock language-typescript\">const printId = (id: number | string) =&gt; {\n  if (typeof id === 'string') {\n    // In this branch, id is of type 'string'\n    console.log(id.toUpperCase());\n  } else {\n    // Here, id is of type 'number'\n    console.log(id);\n  }\n};</pre><p id=\"u0ec42a2e\" class=\"ne-p\"><br></p><h3 id=\"0733e651\"><span class=\"ne-text\">类型别名（Type Aliases）</span></h3><p id=\"u8bd40fd2\" class=\"ne-p\"><br></p><p id=\"u37fc212c\" class=\"ne-p\"><span class=\"ne-text\">上面都是直接在变量后面追加类型定义，很方便，但是不方便复用。这个时候你就可以考虑类型别名。</span></p><p id=\"u1bd02291\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"d669f63b\" class=\"ne-codeblock language-typescript\">// 对象类型 别名Point\ntype Point = {\n  x: number;\n  y: number;\n};\n\n// 联合类型 别名ID\ntype ID = string | number;</pre><p id=\"u7c96e8cd\" class=\"ne-p\"><br></p><h3 id=\"d1ef6fc6\"><span class=\"ne-text\">接口类型（Interfaces）</span></h3><p id=\"ua506e23e\" class=\"ne-p\"><br></p><p id=\"u6a2d0d92\" class=\"ne-p\"><span class=\"ne-text\">还有一种方式定义对象类型的别名。</span></p><p id=\"u9413af32\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"43023d1a\" class=\"ne-codeblock language-typescript\">interface Point {\n  x: number;\n  y: number;\n}</pre><p id=\"u44833188\" class=\"ne-p\"><br></p><p id=\"u60773a5c\" class=\"ne-p\"><span class=\"ne-text\">接口类型和类型别名的差异</span></p><p id=\"u865b8514\" class=\"ne-p\"><br></p><p id=\"u6386d0c8\" class=\"ne-p\"><img src=\"https://zackdkblog.oss-cn-beijing.aliyuncs.com/images/typescript-intro/interface-type-diff.png\" width=\"1500\" id=\"UFqqg\" class=\"ne-image\"></p><p id=\"ud9bd3c5e\" class=\"ne-p\"><br></p><p id=\"uf8a7b728\" class=\"ne-p\"><span class=\"ne-text\">搬官网的，<br /></span><span class=\"ne-text\">interface 可以使用 extends 继承。定义多个同名 interface 可以合并属性。</span></p><p id=\"u53742022\" class=\"ne-p\"><br></p><p id=\"u4d5aee12\" class=\"ne-p\"><span class=\"ne-text\">Type 可以使用 &amp; 进行继承合并。多个同名 Type 会报错。</span></p><p id=\"u873a5b4e\" class=\"ne-p\"><br></p><p id=\"u26bbc8e3\" class=\"ne-p\"><span class=\"ne-text\">个人补充一点，类型计算一般都使用的 Type . 无法使用 interface .</span></p><p id=\"u7f7d9e75\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"11fe1c12\" class=\"ne-codeblock language-typescript\">// 以下会报错\ninterface I&lt;T&gt;{\n   [i in keyof T] : T[i]\n}\n\n// 以下不会\nexport type D&lt;T&gt; = {\n  [i in keyof T]: T[i];\n};</pre><p id=\"uc5bf7c03\" class=\"ne-p\"><br></p><h3 id=\"89a8faee\"><span class=\"ne-text\">类型断言</span></h3><p id=\"ubc0e1f2c\" class=\"ne-p\"><br></p><p id=\"u047bd968\" class=\"ne-p\"><span class=\"ne-text\">有些时候，typescript 并不能推断出具体的类型。</span></p><p id=\"u168b5ebb\" class=\"ne-p\"><br></p><p id=\"uf5c7756d\" class=\"ne-p\"><span class=\"ne-text\">像下面这样的</span></p><p id=\"u5a525fcd\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"0f45b6b8\" class=\"ne-codeblock language-typescript\">const myCanvas = document.getElementById('main_canvas');</pre><p id=\"ub01bec64\" class=\"ne-p\"><br></p><p id=\"u8fb47a2d\" class=\"ne-p\"><span class=\"ne-text\">typescript 只能推断出它属于</span><code class=\"ne-code\"><span class=\"ne-text\">HTMLElement</span></code><span class=\"ne-text\">类型，但你是明确知道元素是</span><code class=\"ne-code\"><span class=\"ne-text\">HTMLCanvasElement</span></code><span class=\"ne-text\">。这种时候你就可以使用类型断言，像下面这样</span></p><p id=\"ueb3f5672\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"c27e8f4f\" class=\"ne-codeblock language-typescript\">const myCanvas = document.getElementById('main_canvas') as HTMLCanvasElement;</pre><p id=\"ud0cda606\" class=\"ne-p\"><br></p><h3 id=\"7d4bfe47\"><span class=\"ne-text\">字面量类型</span></h3><p id=\"u3f633d29\" class=\"ne-p\"><br></p><p id=\"udee52d49\" class=\"ne-p\"><span class=\"ne-text\">字面量类型，顾名思义就是像下面这样，</span><code class=\"ne-code\"><span class=\"ne-text\">a</span></code><span class=\"ne-text\">的类型就固定为</span><code class=\"ne-code\"><span class=\"ne-text\">test</span></code><span class=\"ne-text\">了，不是</span><code class=\"ne-code\"><span class=\"ne-text\">string</span></code><span class=\"ne-text\">。</span></p><p id=\"u6def4482\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"16cd7e17\" class=\"ne-codeblock language-typescript\">let a: 'test' = 'test';</pre><p id=\"u55f1101b\" class=\"ne-p\"><br></p><p id=\"u205ee16e\" class=\"ne-p\"><span class=\"ne-text\">需要特别注意的是，取决于 Javascript 声明变量的方式，TS 会推断出不同的类型。</span><code class=\"ne-code\"><span class=\"ne-text\">let</span></code><span class=\"ne-text\">、</span><code class=\"ne-code\"><span class=\"ne-text\">var</span></code><span class=\"ne-text\">声明的变量都允许修改。</span><code class=\"ne-code\"><span class=\"ne-text\">const</span></code><span class=\"ne-text\">则不允许。</span></p><p id=\"u88f4b85b\" class=\"ne-p\"><br></p><p id=\"u50758f33\" class=\"ne-p\"><span class=\"ne-text\">因此对于</span><code class=\"ne-code\"><span class=\"ne-text\">let</span></code><span class=\"ne-text\">、</span><code class=\"ne-code\"><span class=\"ne-text\">var</span></code><span class=\"ne-text\">声明的变量：</span></p><p id=\"u0217c3d0\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"46f35a33\" class=\"ne-codeblock language-typescript\">let str = 'str'; // 推断为 string 类型\nlet num = 'num'; // 推断为 number 类型\nlet b = true; // 推断为 boolean 类型</pre><p id=\"u02ec065d\" class=\"ne-p\"><br></p><p id=\"u7e43974b\" class=\"ne-p\"><span class=\"ne-text\">对于</span><code class=\"ne-code\"><span class=\"ne-text\">const</span></code><span class=\"ne-text\">声明的变量：</span></p><p id=\"u099ed47c\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"8b2df2c9\" class=\"ne-codeblock language-typescript\">const str = 'str'; // 推断为字面量 'str' 类型\nconst num = 'num'; // 推断为字面量 'num' 类型\nconst b = true; // 推断为字面量 true 类型</pre><p id=\"u3df3b06e\" class=\"ne-p\"><br></p><p id=\"u55b1741c\" class=\"ne-p\"><span class=\"ne-text\">但当在用 const 声明一个对象时，TS 会默认该对象的属性都是可以修改的。所以推断出的类型都是基本类型。如果你想推断为字面量的类型，需要在后面加上</span><code class=\"ne-code\"><span class=\"ne-text\">as const</span></code><span class=\"ne-text\">，示例如下：</span></p><p id=\"u3ff86263\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"4dbfcdc5\" class=\"ne-codeblock language-typescript\">// 以下推断出的类型为\ninterface {\n  url : string;\n  method : string;\n}\nconst req = { url: &quot;https://example.com&quot;, method: &quot;GET&quot; };\n\n// 以下推断出的类型为\ninterface {\n  url : &quot;https://example.com&quot;;\n  method : &quot;GET&quot;;\n}\n\nconst req = { url: &quot;https://example.com&quot;, method: &quot;GET&quot; } as const;</pre><p id=\"ua8e4aa42\" class=\"ne-p\"><br></p><h3 id=\"741a5868\"><span class=\"ne-text\">null、undefined</span></h3><p id=\"ud09a5550\" class=\"ne-p\"><br></p><p id=\"ua08fa75d\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">JavaScript</span></code><span class=\"ne-text\">有两个特殊的类型</span><code class=\"ne-code\"><span class=\"ne-text\">null</span></code><span class=\"ne-text\">和</span><code class=\"ne-code\"><span class=\"ne-text\">undefined</span></code><span class=\"ne-text\">用于代表不存在或者未初始化。</span></p><p id=\"ua13b689a\" class=\"ne-p\"><br></p><p id=\"u4bd116e6\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">TypeScript</span></code><span class=\"ne-text\">也有这两个相对应的类型的定义</span><code class=\"ne-code\"><span class=\"ne-text\">null</span></code><span class=\"ne-text\">和</span><code class=\"ne-code\"><span class=\"ne-text\">undefined</span></code><span class=\"ne-text\">。</span></p><p id=\"u70171c13\" class=\"ne-p\"><br></p><p id=\"u0dcf418f\" class=\"ne-p\"><span class=\"ne-text\">这两个类型和</span><code class=\"ne-code\"><span class=\"ne-text\">strictNullChecks</span></code><span class=\"ne-text\">配置相关，当配置为</span><code class=\"ne-code\"><span class=\"ne-text\">off</span></code><span class=\"ne-text\">时，这两个类型可以赋值给任意类型，不会报错。当配置为</span><code class=\"ne-code\"><span class=\"ne-text\">on</span></code><span class=\"ne-text\">时，使用之前需要先检查是否为空，否则</span><code class=\"ne-code\"><span class=\"ne-text\">TS</span></code><span class=\"ne-text\">会提示错误。</span></p><p id=\"ucb037e1b\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"f0b4c2d5\" class=\"ne-codeblock language-typescript\">function doSomething(x: string | null) {\n  if (x === null) {\n    // do nothing\n  } else {\n    console.log('Hello, ' + x.toUpperCase());\n  }\n}</pre><p id=\"ubdb66666\" class=\"ne-p\"><br></p><p id=\"u52fc7c31\" class=\"ne-p\"><span class=\"ne-text\">你也可以使用</span><code class=\"ne-code\"><span class=\"ne-text\">!</span></code><span class=\"ne-text\">进行非空断言，但需要注意的是，类型断言不会影响代码运行时的行为，你需要自己确保这个值不会为空值。</span></p><p id=\"u98a8f9e7\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"2cc74dd0\" class=\"ne-codeblock language-typescript\">function liveDangerously(x?: number | null) {\n  // No error\n  console.log(x!.toFixed());\n}</pre><p id=\"u77e7dc66\" class=\"ne-p\"><br></p><h3 id=\"enum\"><span class=\"ne-text\">enum</span></h3><p id=\"u7e9a4737\" class=\"ne-p\"><br></p><p id=\"u46b00eac\" class=\"ne-p\"><span class=\"ne-text\">枚举是 </span><code class=\"ne-code\"><span class=\"ne-text\">TypeScript</span></code><span class=\"ne-text\"> 添加到 </span><code class=\"ne-code\"><span class=\"ne-text\">JavaScript</span></code><span class=\"ne-text\"> 的一项功能，与其它类型不同的是，枚举是会添加代码到运行时的，也就是说会影响你的代码。所以在使用枚举之前，确保你知道自己在做什么。</span></p><p id=\"1f33b176a87862bcfe0ccc4aca6987a4\" class=\"ne-p\"><br></p></div>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"fixed\" /><h2 data-lake-id=\"28672e27\" id=\"28672e27\"><span data-lake-id=\"u587e0697\" id=\"u587e0697\">基础类型</span></h2><p data-lake-id=\"uf1c87962\" id=\"uf1c87962\"><br></p><h3 data-lake-id=\"5e44db3d\" id=\"5e44db3d\"><span data-lake-id=\"u0cffb119\" id=\"u0cffb119\">原始值类型</span></h3><p data-lake-id=\"u5998f88c\" id=\"u5998f88c\"><br></p><p data-lake-id=\"uf9a69c1f\" id=\"uf9a69c1f\"><span data-lake-id=\"u21fabada\" id=\"u21fabada\">原始值类型，ts 会自动推导出来。</span></p><p data-lake-id=\"ucdbe69ab\" id=\"ucdbe69ab\"><br></p><p data-lake-id=\"u8b4f5025\" id=\"u8b4f5025\"><span data-lake-id=\"ufdea8146\" id=\"ufdea8146\">类型语法：string，number，boolean</span></p><p data-lake-id=\"u9e6de61d\" id=\"u9e6de61d\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22typescript%22%2C%22code%22%3A%22const%20a%3A%20string%20%3D%20'hello%20ts'%3B%5Cnconst%20b%3A%20number%20%3D%202%3B%5Cnconst%20c%3A%20boolean%20%3D%20true%3B%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22677d76b6%22%7D\"></card><p data-lake-id=\"u89f85bb1\" id=\"u89f85bb1\"><br></p><p data-lake-id=\"u830cc471\" id=\"u830cc471\"><span data-lake-id=\"u1e11bdc5\" id=\"u1e11bdc5\">需要注意的是：String, Number, Boolean 在 TS 里都是有效值，但平时使用中几乎不会用到。</span></p><p data-lake-id=\"ue9524baf\" id=\"ue9524baf\"><br></p><h3 data-lake-id=\"f45a735a\" id=\"f45a735a\"><span data-lake-id=\"u4bb9c2c2\" id=\"u4bb9c2c2\">数组类型</span></h3><p data-lake-id=\"ucc1c2f0f\" id=\"ucc1c2f0f\"><br></p><p data-lake-id=\"u30a49844\" id=\"u30a49844\"><span data-lake-id=\"uacb78d74\" id=\"uacb78d74\">如下定义：</span></p><p data-lake-id=\"udddffda6\" id=\"udddffda6\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22typescript%22%2C%22code%22%3A%22%2F%2F%20%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%5B%5D%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%5Cnconst%20numArr%3A%20number%5B%5D%20%3D%20%5B1%2C%202%2C%203%5D%3B%5Cnconst%20strArr%3A%20string%5B%5D%20%3D%20%5B'1'%2C%20'2'%2C%20'3'%5D%3B%5Cnconst%20booleanArr%3A%20boolean%5B%5D%20%3D%20%5Btrue%2C%20false%5D%3B%5Cn%5Cn%2F%2F%20%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8Array%3CT%3E%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%5Cnconst%20numArr%3A%20Arrary%3Cnumber%3E%20%3D%20%5B1%2C%202%2C%203%5D%3B%5Cnconst%20strArr%3A%20Arrary%3Cstring%3E%20%3D%20%5B'1'%2C%20'2'%2C%20'3'%5D%3B%5Cnconst%20booleanArr%3A%20Arrary%3Cboolean%3E%20%3D%20%5Btrue%2C%20false%5D%3B%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%2295564848%22%7D\"></card><p data-lake-id=\"u90a27ecf\" id=\"u90a27ecf\"><br></p><h3 data-lake-id=\"25009be8\" id=\"25009be8\"><span data-lake-id=\"u0846e045\" id=\"u0846e045\">函数类型</span></h3><p data-lake-id=\"ub6658238\" id=\"ub6658238\"><br></p><p data-lake-id=\"u906dda83\" id=\"u906dda83\"><span data-lake-id=\"ufee12a06\" id=\"ufee12a06\">函数主要定义入参和出参的类型：</span></p><p data-lake-id=\"u60ac9e43\" id=\"u60ac9e43\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22typescript%22%2C%22code%22%3A%22%2F%2F%20function%20%E5%AE%9A%E4%B9%89%5Cnfunction%20identify(params%3A%20string)%3A%20string%20%7B%5Cn%20%20return%20params%3B%5Cn%7D%5Cn%5Cnconst%20identify2%20%3D%20function%20(params%3A%20number)%3A%20number%20%7B%5Cn%20%20return%20params%3B%5Cn%7D%3B%5Cn%5Cn%2F%2F%20%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%5Cnconst%20arrowFunc%20%3D%20(i%3A%20boolean)%3A%20boolean%20%3D%3E%20%7B%5Cn%20%20return%20i%3B%5Cn%7D%3B%5Cn%5Cnexport%20type%20identifyType%20%3D%20typeof%20identify%3B%5Cnexport%20type%20identify2Type%20%3D%20typeof%20identify2%3B%5Cnexport%20type%20identify3Type%20%3D%20typeof%20arrowFunc%3B%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22860a65fd%22%7D\"></card><p data-lake-id=\"u4bf5a346\" id=\"u4bf5a346\"><br></p><p data-lake-id=\"ud73061ed\" id=\"ud73061ed\"><span data-lake-id=\"u41e644f2\" id=\"u41e644f2\">todo-函数重载</span></p><p data-lake-id=\"uec35696d\" id=\"uec35696d\"><br></p><h3 data-lake-id=\"1e767357\" id=\"1e767357\"><span data-lake-id=\"u28351fff\" id=\"u28351fff\">对象类型</span></h3><p data-lake-id=\"uf0eb3119\" id=\"uf0eb3119\"><br></p><p data-lake-id=\"u884c3afe\" id=\"u884c3afe\"><span data-lake-id=\"u7581013e\" id=\"u7581013e\">最常用的类型，使用 ?: 可以让某个属性可选。</span></p><p data-lake-id=\"ue2cc6507\" id=\"ue2cc6507\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22typescript%22%2C%22code%22%3A%22const%20obj%3A%20%7B%5Cn%20%20x%3A%20number%3B%5Cn%20%20z%3A%20boolean%3B%5Cn%20%20c%3F%3A%20string%3B%5Cn%7D%20%3D%20%7B%5Cn%20%20x%3A%201%2C%5Cn%20%20z%3A%20false%2C%5Cn%20%20c%3A%20''%2C%5Cn%7D%3B%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22e21ed8cf%22%7D\"></card><p data-lake-id=\"u147b7f6a\" id=\"u147b7f6a\"><br></p><h3 data-lake-id=\"0359e3b7\" id=\"0359e3b7\"><span data-lake-id=\"u490152b6\" id=\"u490152b6\">联合类型（Union Types）</span></h3><p data-lake-id=\"uc7080120\" id=\"uc7080120\"><br></p><p data-lake-id=\"u1a6ea3ba\" id=\"u1a6ea3ba\"><span data-lake-id=\"ufbe5f684\" id=\"ufbe5f684\">简单来说就是，一个变量可能有多个类型选项。</span></p><p data-lake-id=\"u468331fb\" id=\"u468331fb\"><br></p><p data-lake-id=\"ubc95ccaa\" id=\"ubc95ccaa\"><span data-lake-id=\"u7c61a9f4\" id=\"u7c61a9f4\">当一个函数入参可能是这种类型，或者是那种类型。就可以使用联合类型。如下：</span></p><p data-lake-id=\"u4b400116\" id=\"u4b400116\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22typescript%22%2C%22code%22%3A%22const%20printId%20%3D%20(id%3A%20number%20%7C%20string)%20%3D%3E%20%7B%5Cn%20%20console.log('Your%20ID%20is%3A%20'%20%2B%20id)%3B%5Cn%7D%3B%5Cn%5CnprintId(1)%3B%5CnprintId('str')%3B%5Cn%2F%2F%20printId(true)%3B%20%E6%AD%A4%E5%A4%84%E4%BC%9A%E6%8F%90%E7%A4%BA%E7%B1%BB%E5%9E%8B%E9%94%99%E8%AF%AF%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22f2f008e5%22%7D\"></card><p data-lake-id=\"u0a94105e\" id=\"u0a94105e\"><br></p><p data-lake-id=\"u6baf8282\" id=\"u6baf8282\"><span data-lake-id=\"u53645c9a\" id=\"u53645c9a\">有一个问题，既然变量可能有多个类型定义，你就不能只使用属于某个类型定义的属性。</span></p><p data-lake-id=\"u8d120474\" id=\"u8d120474\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22typescript%22%2C%22code%22%3A%22const%20printId%20%3D%20(id%3A%20number%20%7C%20string)%20%3D%3E%20%7B%5Cn%20%20console.log(id.toUpperCase())%3B%20%2F%2F%20%E6%AD%A4%E5%A4%84%E4%BC%9A%E6%8F%90%E7%A4%BA%E7%B1%BB%E5%9E%8B%E9%94%99%E8%AF%AF%5Cn%7D%3B%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22b0916ab2%22%7D\"></card><p data-lake-id=\"uf2510dd0\" id=\"uf2510dd0\"><br></p><p data-lake-id=\"uc51f5fcf\" id=\"uc51f5fcf\"><span data-lake-id=\"uaf4b2372\" id=\"uaf4b2372\">此时你需要做一个操作，类型收窄，即判断了类型再使用相应类型的属性。</span></p><p data-lake-id=\"ufaa44c9e\" id=\"ufaa44c9e\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22typescript%22%2C%22code%22%3A%22const%20printId%20%3D%20(id%3A%20number%20%7C%20string)%20%3D%3E%20%7B%5Cn%20%20if%20(typeof%20id%20%3D%3D%3D%20'string')%20%7B%5Cn%20%20%20%20%2F%2F%20In%20this%20branch%2C%20id%20is%20of%20type%20'string'%5Cn%20%20%20%20console.log(id.toUpperCase())%3B%5Cn%20%20%7D%20else%20%7B%5Cn%20%20%20%20%2F%2F%20Here%2C%20id%20is%20of%20type%20'number'%5Cn%20%20%20%20console.log(id)%3B%5Cn%20%20%7D%5Cn%7D%3B%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22be9b3fb5%22%7D\"></card><p data-lake-id=\"u0ec42a2e\" id=\"u0ec42a2e\"><br></p><h3 data-lake-id=\"0733e651\" id=\"0733e651\"><span data-lake-id=\"u81c57409\" id=\"u81c57409\">类型别名（Type Aliases）</span></h3><p data-lake-id=\"u8bd40fd2\" id=\"u8bd40fd2\"><br></p><p data-lake-id=\"u37fc212c\" id=\"u37fc212c\"><span data-lake-id=\"uf23e773f\" id=\"uf23e773f\">上面都是直接在变量后面追加类型定义，很方便，但是不方便复用。这个时候你就可以考虑类型别名。</span></p><p data-lake-id=\"u1bd02291\" id=\"u1bd02291\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22typescript%22%2C%22code%22%3A%22%2F%2F%20%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%20%E5%88%AB%E5%90%8DPoint%5Cntype%20Point%20%3D%20%7B%5Cn%20%20x%3A%20number%3B%5Cn%20%20y%3A%20number%3B%5Cn%7D%3B%5Cn%5Cn%2F%2F%20%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%20%E5%88%AB%E5%90%8DID%5Cntype%20ID%20%3D%20string%20%7C%20number%3B%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22d669f63b%22%7D\"></card><p data-lake-id=\"u7c96e8cd\" id=\"u7c96e8cd\"><br></p><h3 data-lake-id=\"d1ef6fc6\" id=\"d1ef6fc6\"><span data-lake-id=\"u8b135464\" id=\"u8b135464\">接口类型（Interfaces）</span></h3><p data-lake-id=\"ua506e23e\" id=\"ua506e23e\"><br></p><p data-lake-id=\"u6a2d0d92\" id=\"u6a2d0d92\"><span data-lake-id=\"udf45d26c\" id=\"udf45d26c\">还有一种方式定义对象类型的别名。</span></p><p data-lake-id=\"u9413af32\" id=\"u9413af32\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22typescript%22%2C%22code%22%3A%22interface%20Point%20%7B%5Cn%20%20x%3A%20number%3B%5Cn%20%20y%3A%20number%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%2243023d1a%22%7D\"></card><p data-lake-id=\"u44833188\" id=\"u44833188\"><br></p><p data-lake-id=\"u60773a5c\" id=\"u60773a5c\"><span data-lake-id=\"uf9afc917\" id=\"uf9afc917\">接口类型和类型别名的差异</span></p><p data-lake-id=\"u865b8514\" id=\"u865b8514\"><br></p><p data-lake-id=\"u6386d0c8\" id=\"u6386d0c8\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fzackdkblog.oss-cn-beijing.aliyuncs.com%2Fimages%2Ftypescript-intro%2Finterface-type-diff.png%22%2C%22originalType%22%3A%22binary%22%2C%22linkTarget%22%3A%22%22%2C%22originWidth%22%3A1500%2C%22originHeight%22%3A1269%2C%22ratio%22%3A1%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22showTitle%22%3Afalse%2C%22title%22%3A%22%22%2C%22rotation%22%3A0%2C%22crop%22%3A%5B0%2C0%2C1%2C1%5D%2C%22id%22%3A%22UFqqg%22%7D\"></card></p><p data-lake-id=\"ud9bd3c5e\" id=\"ud9bd3c5e\"><br></p><p data-lake-id=\"uf8a7b728\" id=\"uf8a7b728\"><span data-lake-id=\"ud47d4fec\" id=\"ud47d4fec\">搬官网的，<br /></span><span data-lake-id=\"u099cf2e6\" id=\"u099cf2e6\">interface 可以使用 extends 继承。定义多个同名 interface 可以合并属性。</span></p><p data-lake-id=\"u53742022\" id=\"u53742022\"><br></p><p data-lake-id=\"u4d5aee12\" id=\"u4d5aee12\"><span data-lake-id=\"uaa983cac\" id=\"uaa983cac\">Type 可以使用 &amp; 进行继承合并。多个同名 Type 会报错。</span></p><p data-lake-id=\"u873a5b4e\" id=\"u873a5b4e\"><br></p><p data-lake-id=\"u26bbc8e3\" id=\"u26bbc8e3\"><span data-lake-id=\"u3812850e\" id=\"u3812850e\">个人补充一点，类型计算一般都使用的 Type . 无法使用 interface .</span></p><p data-lake-id=\"u7f7d9e75\" id=\"u7f7d9e75\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22typescript%22%2C%22code%22%3A%22%2F%2F%20%E4%BB%A5%E4%B8%8B%E4%BC%9A%E6%8A%A5%E9%94%99%5Cninterface%20I%3CT%3E%7B%5Cn%20%20%20%5Bi%20in%20keyof%20T%5D%20%3A%20T%5Bi%5D%5Cn%7D%5Cn%5Cn%2F%2F%20%E4%BB%A5%E4%B8%8B%E4%B8%8D%E4%BC%9A%5Cnexport%20type%20D%3CT%3E%20%3D%20%7B%5Cn%20%20%5Bi%20in%20keyof%20T%5D%3A%20T%5Bi%5D%3B%5Cn%7D%3B%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%2211fe1c12%22%7D\"></card><p data-lake-id=\"uc5bf7c03\" id=\"uc5bf7c03\"><br></p><h3 data-lake-id=\"89a8faee\" id=\"89a8faee\"><span data-lake-id=\"uec021856\" id=\"uec021856\">类型断言</span></h3><p data-lake-id=\"ubc0e1f2c\" id=\"ubc0e1f2c\"><br></p><p data-lake-id=\"u047bd968\" id=\"u047bd968\"><span data-lake-id=\"u626acfa0\" id=\"u626acfa0\">有些时候，typescript 并不能推断出具体的类型。</span></p><p data-lake-id=\"u168b5ebb\" id=\"u168b5ebb\"><br></p><p data-lake-id=\"uf5c7756d\" id=\"uf5c7756d\"><span data-lake-id=\"u7bfbd62f\" id=\"u7bfbd62f\">像下面这样的</span></p><p data-lake-id=\"u5a525fcd\" id=\"u5a525fcd\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22typescript%22%2C%22code%22%3A%22const%20myCanvas%20%3D%20document.getElementById('main_canvas')%3B%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%220f45b6b8%22%7D\"></card><p data-lake-id=\"ub01bec64\" id=\"ub01bec64\"><br></p><p data-lake-id=\"u8fb47a2d\" id=\"u8fb47a2d\"><span data-lake-id=\"ub2466f92\" id=\"ub2466f92\">typescript 只能推断出它属于</span><code data-lake-id=\"u46c29de7\" id=\"u46c29de7\"><span data-lake-id=\"ubdb6fa8e\" id=\"ubdb6fa8e\">HTMLElement</span></code><span data-lake-id=\"u064d8304\" id=\"u064d8304\">类型，但你是明确知道元素是</span><code data-lake-id=\"ua58f94fe\" id=\"ua58f94fe\"><span data-lake-id=\"u3f802384\" id=\"u3f802384\">HTMLCanvasElement</span></code><span data-lake-id=\"u8cdb1006\" id=\"u8cdb1006\">。这种时候你就可以使用类型断言，像下面这样</span></p><p data-lake-id=\"ueb3f5672\" id=\"ueb3f5672\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22typescript%22%2C%22code%22%3A%22const%20myCanvas%20%3D%20document.getElementById('main_canvas')%20as%20HTMLCanvasElement%3B%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22c27e8f4f%22%7D\"></card><p data-lake-id=\"ud0cda606\" id=\"ud0cda606\"><br></p><h3 data-lake-id=\"7d4bfe47\" id=\"7d4bfe47\"><span data-lake-id=\"u85750a3b\" id=\"u85750a3b\">字面量类型</span></h3><p data-lake-id=\"u3f633d29\" id=\"u3f633d29\"><br></p><p data-lake-id=\"udee52d49\" id=\"udee52d49\"><span data-lake-id=\"u0768c1af\" id=\"u0768c1af\">字面量类型，顾名思义就是像下面这样，</span><code data-lake-id=\"u3bf72fe3\" id=\"u3bf72fe3\"><span data-lake-id=\"ue8f777d9\" id=\"ue8f777d9\">a</span></code><span data-lake-id=\"u02aa0c73\" id=\"u02aa0c73\">的类型就固定为</span><code data-lake-id=\"u37862afe\" id=\"u37862afe\"><span data-lake-id=\"u7b111bdd\" id=\"u7b111bdd\">test</span></code><span data-lake-id=\"uc0d01523\" id=\"uc0d01523\">了，不是</span><code data-lake-id=\"u245003c0\" id=\"u245003c0\"><span data-lake-id=\"ucba5073a\" id=\"ucba5073a\">string</span></code><span data-lake-id=\"u9d071963\" id=\"u9d071963\">。</span></p><p data-lake-id=\"u6def4482\" id=\"u6def4482\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22typescript%22%2C%22code%22%3A%22let%20a%3A%20'test'%20%3D%20'test'%3B%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%2216cd7e17%22%7D\"></card><p data-lake-id=\"u55f1101b\" id=\"u55f1101b\"><br></p><p data-lake-id=\"u205ee16e\" id=\"u205ee16e\"><span data-lake-id=\"uf8bebe55\" id=\"uf8bebe55\">需要特别注意的是，取决于 Javascript 声明变量的方式，TS 会推断出不同的类型。</span><code data-lake-id=\"u72c07129\" id=\"u72c07129\"><span data-lake-id=\"u4edb04c5\" id=\"u4edb04c5\">let</span></code><span data-lake-id=\"u382e579b\" id=\"u382e579b\">、</span><code data-lake-id=\"u4493f738\" id=\"u4493f738\"><span data-lake-id=\"u1c0d4ed2\" id=\"u1c0d4ed2\">var</span></code><span data-lake-id=\"u4387b577\" id=\"u4387b577\">声明的变量都允许修改。</span><code data-lake-id=\"ubcb06683\" id=\"ubcb06683\"><span data-lake-id=\"uafef036d\" id=\"uafef036d\">const</span></code><span data-lake-id=\"u6ce1a6b6\" id=\"u6ce1a6b6\">则不允许。</span></p><p data-lake-id=\"u88f4b85b\" id=\"u88f4b85b\"><br></p><p data-lake-id=\"u50758f33\" id=\"u50758f33\"><span data-lake-id=\"uec6cd956\" id=\"uec6cd956\">因此对于</span><code data-lake-id=\"ue5403a3e\" id=\"ue5403a3e\"><span data-lake-id=\"u2011a1ce\" id=\"u2011a1ce\">let</span></code><span data-lake-id=\"ua136f928\" id=\"ua136f928\">、</span><code data-lake-id=\"u73f500a1\" id=\"u73f500a1\"><span data-lake-id=\"u0a6e8f43\" id=\"u0a6e8f43\">var</span></code><span data-lake-id=\"ucc70091a\" id=\"ucc70091a\">声明的变量：</span></p><p data-lake-id=\"u0217c3d0\" id=\"u0217c3d0\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22typescript%22%2C%22code%22%3A%22let%20str%20%3D%20'str'%3B%20%2F%2F%20%E6%8E%A8%E6%96%AD%E4%B8%BA%20string%20%E7%B1%BB%E5%9E%8B%5Cnlet%20num%20%3D%20'num'%3B%20%2F%2F%20%E6%8E%A8%E6%96%AD%E4%B8%BA%20number%20%E7%B1%BB%E5%9E%8B%5Cnlet%20b%20%3D%20true%3B%20%2F%2F%20%E6%8E%A8%E6%96%AD%E4%B8%BA%20boolean%20%E7%B1%BB%E5%9E%8B%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%2246f35a33%22%7D\"></card><p data-lake-id=\"u02ec065d\" id=\"u02ec065d\"><br></p><p data-lake-id=\"u7e43974b\" id=\"u7e43974b\"><span data-lake-id=\"u7b79636f\" id=\"u7b79636f\">对于</span><code data-lake-id=\"u8ed58a2b\" id=\"u8ed58a2b\"><span data-lake-id=\"u5e9f8012\" id=\"u5e9f8012\">const</span></code><span data-lake-id=\"uc21454d6\" id=\"uc21454d6\">声明的变量：</span></p><p data-lake-id=\"u099ed47c\" id=\"u099ed47c\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22typescript%22%2C%22code%22%3A%22const%20str%20%3D%20'str'%3B%20%2F%2F%20%E6%8E%A8%E6%96%AD%E4%B8%BA%E5%AD%97%E9%9D%A2%E9%87%8F%20'str'%20%E7%B1%BB%E5%9E%8B%5Cnconst%20num%20%3D%20'num'%3B%20%2F%2F%20%E6%8E%A8%E6%96%AD%E4%B8%BA%E5%AD%97%E9%9D%A2%E9%87%8F%20'num'%20%E7%B1%BB%E5%9E%8B%5Cnconst%20b%20%3D%20true%3B%20%2F%2F%20%E6%8E%A8%E6%96%AD%E4%B8%BA%E5%AD%97%E9%9D%A2%E9%87%8F%20true%20%E7%B1%BB%E5%9E%8B%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%228b2df2c9%22%7D\"></card><p data-lake-id=\"u3df3b06e\" id=\"u3df3b06e\"><br></p><p data-lake-id=\"u55b1741c\" id=\"u55b1741c\"><span data-lake-id=\"u8beec4d6\" id=\"u8beec4d6\">但当在用 const 声明一个对象时，TS 会默认该对象的属性都是可以修改的。所以推断出的类型都是基本类型。如果你想推断为字面量的类型，需要在后面加上</span><code data-lake-id=\"uef09836f\" id=\"uef09836f\"><span data-lake-id=\"ubc6016b3\" id=\"ubc6016b3\">as const</span></code><span data-lake-id=\"u5af09120\" id=\"u5af09120\">，示例如下：</span></p><p data-lake-id=\"u3ff86263\" id=\"u3ff86263\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22typescript%22%2C%22code%22%3A%22%2F%2F%20%E4%BB%A5%E4%B8%8B%E6%8E%A8%E6%96%AD%E5%87%BA%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%B8%BA%5Cninterface%20%7B%5Cn%20%20url%20%3A%20string%3B%5Cn%20%20method%20%3A%20string%3B%5Cn%7D%5Cnconst%20req%20%3D%20%7B%20url%3A%20%5C%22https%3A%2F%2Fexample.com%5C%22%2C%20method%3A%20%5C%22GET%5C%22%20%7D%3B%5Cn%5Cn%2F%2F%20%E4%BB%A5%E4%B8%8B%E6%8E%A8%E6%96%AD%E5%87%BA%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%B8%BA%5Cninterface%20%7B%5Cn%20%20url%20%3A%20%5C%22https%3A%2F%2Fexample.com%5C%22%3B%5Cn%20%20method%20%3A%20%5C%22GET%5C%22%3B%5Cn%7D%5Cn%5Cnconst%20req%20%3D%20%7B%20url%3A%20%5C%22https%3A%2F%2Fexample.com%5C%22%2C%20method%3A%20%5C%22GET%5C%22%20%7D%20as%20const%3B%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%224dbfcdc5%22%7D\"></card><p data-lake-id=\"ua8e4aa42\" id=\"ua8e4aa42\"><br></p><h3 data-lake-id=\"741a5868\" id=\"741a5868\"><span data-lake-id=\"u5d94373a\" id=\"u5d94373a\">null、undefined</span></h3><p data-lake-id=\"ud09a5550\" id=\"ud09a5550\"><br></p><p data-lake-id=\"ua08fa75d\" id=\"ua08fa75d\"><code data-lake-id=\"u1e885931\" id=\"u1e885931\"><span data-lake-id=\"u9f095c5d\" id=\"u9f095c5d\">JavaScript</span></code><span data-lake-id=\"u7422148c\" id=\"u7422148c\">有两个特殊的类型</span><code data-lake-id=\"uc41697c9\" id=\"uc41697c9\"><span data-lake-id=\"u0bce9c82\" id=\"u0bce9c82\">null</span></code><span data-lake-id=\"ub2d8611c\" id=\"ub2d8611c\">和</span><code data-lake-id=\"u7360b60e\" id=\"u7360b60e\"><span data-lake-id=\"u14033dfc\" id=\"u14033dfc\">undefined</span></code><span data-lake-id=\"uef192abb\" id=\"uef192abb\">用于代表不存在或者未初始化。</span></p><p data-lake-id=\"ua13b689a\" id=\"ua13b689a\"><br></p><p data-lake-id=\"u4bd116e6\" id=\"u4bd116e6\"><code data-lake-id=\"u306e96ac\" id=\"u306e96ac\"><span data-lake-id=\"u6d0aaaeb\" id=\"u6d0aaaeb\">TypeScript</span></code><span data-lake-id=\"u6c1d40c5\" id=\"u6c1d40c5\">也有这两个相对应的类型的定义</span><code data-lake-id=\"u72eecbd6\" id=\"u72eecbd6\"><span data-lake-id=\"u22d63af9\" id=\"u22d63af9\">null</span></code><span data-lake-id=\"uade2df86\" id=\"uade2df86\">和</span><code data-lake-id=\"uf56081a5\" id=\"uf56081a5\"><span data-lake-id=\"u5871a883\" id=\"u5871a883\">undefined</span></code><span data-lake-id=\"u3cba4911\" id=\"u3cba4911\">。</span></p><p data-lake-id=\"u70171c13\" id=\"u70171c13\"><br></p><p data-lake-id=\"u0dcf418f\" id=\"u0dcf418f\"><span data-lake-id=\"u8febf21d\" id=\"u8febf21d\">这两个类型和</span><code data-lake-id=\"u66d4de05\" id=\"u66d4de05\"><span data-lake-id=\"ue79292e4\" id=\"ue79292e4\">strictNullChecks</span></code><span data-lake-id=\"ud23e3f89\" id=\"ud23e3f89\">配置相关，当配置为</span><code data-lake-id=\"uef12d4ec\" id=\"uef12d4ec\"><span data-lake-id=\"ud33ff142\" id=\"ud33ff142\">off</span></code><span data-lake-id=\"ub3a9e71d\" id=\"ub3a9e71d\">时，这两个类型可以赋值给任意类型，不会报错。当配置为</span><code data-lake-id=\"ua8a5d37a\" id=\"ua8a5d37a\"><span data-lake-id=\"u6a2204ae\" id=\"u6a2204ae\">on</span></code><span data-lake-id=\"ub8edfa8d\" id=\"ub8edfa8d\">时，使用之前需要先检查是否为空，否则</span><code data-lake-id=\"u32817cc3\" id=\"u32817cc3\"><span data-lake-id=\"u8c8c5da3\" id=\"u8c8c5da3\">TS</span></code><span data-lake-id=\"u506e58ab\" id=\"u506e58ab\">会提示错误。</span></p><p data-lake-id=\"ucb037e1b\" id=\"ucb037e1b\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22typescript%22%2C%22code%22%3A%22function%20doSomething(x%3A%20string%20%7C%20null)%20%7B%5Cn%20%20if%20(x%20%3D%3D%3D%20null)%20%7B%5Cn%20%20%20%20%2F%2F%20do%20nothing%5Cn%20%20%7D%20else%20%7B%5Cn%20%20%20%20console.log('Hello%2C%20'%20%2B%20x.toUpperCase())%3B%5Cn%20%20%7D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22f0b4c2d5%22%7D\"></card><p data-lake-id=\"ubdb66666\" id=\"ubdb66666\"><br></p><p data-lake-id=\"u52fc7c31\" id=\"u52fc7c31\"><span data-lake-id=\"udf47d8d6\" id=\"udf47d8d6\">你也可以使用</span><code data-lake-id=\"udb28cc9f\" id=\"udb28cc9f\"><span data-lake-id=\"ucc134367\" id=\"ucc134367\">!</span></code><span data-lake-id=\"u4fea9934\" id=\"u4fea9934\">进行非空断言，但需要注意的是，类型断言不会影响代码运行时的行为，你需要自己确保这个值不会为空值。</span></p><p data-lake-id=\"u98a8f9e7\" id=\"u98a8f9e7\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22typescript%22%2C%22code%22%3A%22function%20liveDangerously(x%3F%3A%20number%20%7C%20null)%20%7B%5Cn%20%20%2F%2F%20No%20error%5Cn%20%20console.log(x!.toFixed())%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%222cc74dd0%22%7D\"></card><p data-lake-id=\"u77e7dc66\" id=\"u77e7dc66\"><br></p><h3 data-lake-id=\"enum\" id=\"enum\"><span data-lake-id=\"u98b0b991\" id=\"u98b0b991\">enum</span></h3><p data-lake-id=\"u7e9a4737\" id=\"u7e9a4737\"><br></p><p data-lake-id=\"u46b00eac\" id=\"u46b00eac\"><span data-lake-id=\"u1116aae9\" id=\"u1116aae9\">枚举是 </span><code data-lake-id=\"ue23aa63d\" id=\"ue23aa63d\"><span data-lake-id=\"u723f4659\" id=\"u723f4659\">TypeScript</span></code><span data-lake-id=\"uad5eb876\" id=\"uad5eb876\"> 添加到 </span><code data-lake-id=\"uce62fa78\" id=\"uce62fa78\"><span data-lake-id=\"uf5c68c81\" id=\"uf5c68c81\">JavaScript</span></code><span data-lake-id=\"u2dd0e491\" id=\"u2dd0e491\"> 的一项功能，与其它类型不同的是，枚举是会添加代码到运行时的，也就是说会影响你的代码。所以在使用枚举之前，确保你知道自己在做什么。</span></p><p data-lake-id=\"1f33b176a87862bcfe0ccc4aca6987a4\" id=\"1f33b176a87862bcfe0ccc4aca6987a4\"><br></p>",
  "body_draft_lake": "",
  "public": 1,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2023-02-01T12:16:10.000Z",
  "deleted_at": null,
  "created_at": "2021-06-15T12:13:33.000Z",
  "updated_at": "2023-02-01T12:16:57.000Z",
  "published_at": "2023-02-01T12:16:57.000Z",
  "first_published_at": "2023-02-01T12:16:09.565Z",
  "word_count": 1425,
  "cover": null,
  "description": "基础类型原始值类型原始值类型，ts 会自动推导出来。类型语法：string，number，booleanconst a: string = 'hello ts'; const b: number = 2; const c: boolean = true;需要注意的是：String, Numbe...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}