{
  "id": 11834613,
  "slug": "uwmx59",
  "title": "虚拟DOM的一些概念",
  "book_id": 231593,
  "book": {
    "id": 231593,
    "type": "Book",
    "slug": "web",
    "name": "WEB",
    "user_id": 284138,
    "description": "前端知识点记录",
    "creator_id": 284138,
    "public": 1,
    "items_count": 58,
    "likes_count": 0,
    "watches_count": 3,
    "content_updated_at": "2023-02-02T09:09:21.426Z",
    "updated_at": "2023-02-02T09:09:21.000Z",
    "created_at": "2019-03-07T05:05:08.000Z",
    "namespace": "zackdk/web",
    "user": {
      "id": 284138,
      "type": "User",
      "login": "zackdk",
      "name": "行一度空山",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1551934932702-d412771d-8d33-4694-9186-a749a3b4e05b.jpeg",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 5,
      "following_count": 0,
      "created_at": "2019-03-07T05:02:38.000Z",
      "updated_at": "2023-02-01T12:18:25.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 284138,
  "creator": {
    "id": 284138,
    "type": "User",
    "login": "zackdk",
    "name": "行一度空山",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1551934932702-d412771d-8d33-4694-9186-a749a3b4e05b.jpeg",
    "books_count": 2,
    "public_books_count": 1,
    "followers_count": 5,
    "following_count": 0,
    "created_at": "2019-03-07T05:02:38.000Z",
    "updated_at": "2023-02-01T12:18:25.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "\n<a name=\"PvVA4\"></a>\n## 虚拟dom的由来\n\n虚拟dom最开始是出现在react里的，因为当时facebook想把后端的模板迁移到js里，然后就有了jsx。但是在处理更新的时候需要手动去操作dom（把模板翻译成真实dom），传统 DOM API 细节又太多，操作复杂，所以就很容易出现 Bug，而且代码难以维护。<br />然后就有了react的核心思想，**始终整体“刷新”页面当发生前后状态变化时，React 会自动更新 UI**。让我们从复杂的 UI 操作中解放出来，使我们只需关于状态以及最终 UI 长什么样。**只需要关系我的状态（数据是什么），以及 UI 长什么样（布局），不再需要关系操作细节**。具体可以参考这篇文章[react是怎样练成的](https://segmentfault.com/a/1190000013365426#item-4)。\n\n这种方法有两个问题<br />1.毫无疑问的很慢，一点更新就需要更新整个dom树。<br />2.还有一个问题就是这样无法包含节点的状态。比如它会失去当前聚焦的元素和光标，以及文本选择和页面滚动位置，这些都是页面的当前状态。\n\n为了解决上面说的问题，facebook提出了对于没有改变的 DOM 节点，让它保持原样不动，仅仅创建并替换变更过的 DOM 节点。这种方式实现了 DOM 节点**复用**（Reuse）。<br />至此，只要能够**识别**出哪些节点改变了，那么就可以实现对 DOM 的更新。于是问题就转化为**如何比对两个 DOM 的差异**。也就是diff。\n\n对了上面好像没提到虚拟dom，其实jsx在js里存在形态就是一个对象，这个对象一般就叫做虚拟dom了。\n\n<a name=\"HQ7XC\"></a>\n## 虚拟DOM 就是一个js对象\n\n虚拟dom实际上就是一个js对象，没有什么神奇，大概就长下面这样。属性个数视具体实现而定。但肯定比真实dom轻量多了。<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/284138/1597740538842-cffb0fa3-45f9-4677-a975-ad2a70b87d2e.png#align=left&display=inline&height=212&name=image.png&originHeight=212&originWidth=217&size=10918&status=done&style=none&width=217)<br />type（tag）-元素类型<br />props - 其它一些用户添加的属性（比如style啥的）<br />children - 存放该dom下的子元素。（dom是树形结构嘛）<br />key - 做diff时会用到，能降低diff算法的复杂度\n\n<a name=\"xE36p\"></a>\n## 虚拟dom 优缺点\n\n优点：<br />1.对比真实dom，轻量。带来的好处就是读取访问的性能快多了可以忽略不计了。<br />2.抽象出了一层虚拟dom（ui）层，隔离了真实dom，即隔离了渲染端，方便渲染到多端。也更方便上层组件的抽象化。<br />3.真实dom的操作全由使用虚拟dom的框架进行，方便进行各种统一，具有普适性的优化。比个人所做的优化大多数情况下是要好的。\n\n缺点：<br />所有操作先是在虚拟dom层，然后再统一翻译到真实dom上，尤其是第一次初始化的时候，全量虚拟dom都需要翻译到真实dom。比起直接操作dom，肯定多了一层虚拟dom层上的计算和操作。但是之后的更新，由于虚拟dom层会做一次diff，只会操作必要更新的dom，会比第一次好很多。当然直接操作dom你也可以做到只更新必要的dom，但其中的细节是不甚繁琐的，通常情况下，你根本不会考虑那么多。\n\n第一次初始化的时候：<br />虚拟dom        数据 -> 虚拟dom ->真实dom<br />直接操作dom 数据 -> 真实dom\n\n后续更新的时候：<br />虚拟dom        数据 -> 虚拟dom -> diff -> 更新必要的dom<br />直接操作dom 数据 -> 你的算法 -> 真实dom\n\n<a name=\"5t4az\"></a>\n## diff 是怎么从O(n^3)到O(n)的\n<a name=\"YUo5H\"></a>\n## \n上面说过diff 就是如何比对两个DOM树的差异。两颗树形结构对比的话，复杂度是O(n^3)。这个复杂度的话代表1000个dom节点你要计算 1000 * 1000 * 1000 次，这几乎是不可能接受的。<br />所以react里dom树的diff，针对性的做了些优化，让复杂度降低到了O(n)。这下就可以接受了。具体的优化手段如下。\n\n1.前端dom树跨层级操作比较少见，常见的操作在于子元素之间的移动，比如列表中的移动，删除，新增。所以有了第一次的优化，只对比同级的元素。然后复杂度降低到了O(n^2)。<br />![bV4e6N.png](https://cdn.nlark.com/yuque/0/2020/png/284138/1597804649516-7340c6ce-8ad5-4d1a-9eac-92ccd8b5d726.png#align=left&display=inline&height=174&name=bV4e6N.png&originHeight=174&originWidth=544&size=22866&status=done&style=none&width=544)<br />2.优化掉了跨级元素的比较，再来看看同级元素还有没有可以优化的。同级元素比较，不同元素标签可以直接判断是不同的，但是相同元素标签就比较麻烦了，三个input，变两个input，你是删除哪一个呢？或者你也可以直接全部删除，然后新建。为了避免这种情况，react使用在虚拟dom上加上一个key属性，来辅助做diff。这样比较的时候就能明确的知道哪个是哪个了。然后结合hash表。复杂度就下降到了O(n)<br />![bV4e6Z.png](https://cdn.nlark.com/yuque/0/2020/png/284138/1597805222138-0a4ee536-0f2c-46a0-8d30-f7cc2dd3ad05.png#align=left&display=inline&height=223&name=bV4e6Z.png&originHeight=223&originWidth=570&size=23681&status=done&style=none&width=570)\n\n\n<a name=\"wBrOi\"></a>\n## \n图片摘自[react是怎样练成的](https://segmentfault.com/a/1190000013365426#item-4)。\n",
  "body_draft": "",
  "body_html": "<!doctype html><div class=\"lake-content-editor-core lake-engine lake-typography-traditional\" data-lake-element=\"root\" data-selection-undefined=\"%7B%22path%22%3A%5B%5B2%2C0%5D%2C%5B2%2C0%5D%5D%2C%22active%22%3Atrue%7D\"><p data-lake-id=\"d03b999554d9cbdce757e5c7317183a9\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><br></p><h2 data-lake-id=\"4bed3fc86bd853b0f7f15cd09a09e527\" id=\"PvVA4\" style=\"padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;\">虚拟dom的由来</h2><p data-lake-id=\"c53b97d440fb9696476ac812e8b1f443\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><br></p><p data-lake-id=\"67460100f7029edb7d1b84903a8aca44\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">虚拟dom最开始是出现在react里的，因为当时facebook想把后端的模板迁移到js里，然后就有了jsx。但是在处理更新的时候需要手动去操作dom（把模板翻译成真实dom），传统 DOM API 细节又太多，操作复杂，所以就很容易出现 Bug，而且代码难以维护。</p><p data-lake-id=\"53a365ce9d5108328ac7fc8010deab6f\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">然后就有了react的核心思想，<strong>始终整体“刷新”页面当发生前后状态变化时，React 会自动更新 UI</strong>。让我们从复杂的 UI 操作中解放出来，使我们只需关于状态以及最终 UI 长什么样。<strong>只需要关系我的状态（数据是什么），以及 UI 长什么样（布局），不再需要关系操作细节</strong>。具体可以参考这篇文章<a target=\"_blank\" href=\"https://segmentfault.com/a/1190000013365426#item-4\">react是怎样练成的</a>。</p><p data-lake-id=\"d59afc0a42c9b2a1012480445455ebde\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><br></p><p data-lake-id=\"ec61f131927b718112514e0a7118b4ee\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">这种方法有两个问题</p><p data-lake-id=\"51b4ec75d01eb5c2810e8ad4afae616e\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">1.毫无疑问的很慢，一点更新就需要更新整个dom树。</p><p data-lake-id=\"6414e069697b130d700690ca9465a6f8\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">2.还有一个问题就是这样无法包含节点的状态。比如它会失去当前聚焦的元素和光标，以及文本选择和页面滚动位置，这些都是页面的当前状态。</p><p data-lake-id=\"eed118edb54b5687f89b82f82754995a\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><br></p><p data-lake-id=\"03f1af541976dea4ba026a1fcb6a5195\" style=\"text-align: left; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">为了解决上面说的问题，facebook提出了对于没有改变的 DOM 节点，让它保持原样不动，仅仅创建并替换变更过的 DOM 节点。这种方式实现了 DOM 节点<strong>复用</strong>（Reuse）。</p><p data-lake-id=\"4fef1b4e22191211abdcaf8f95da8b4c\" style=\"text-align: left; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">至此，只要能够<strong>识别</strong>出哪些节点改变了，那么就可以实现对 DOM 的更新。于是问题就转化为<strong>如何比对两个 DOM 的差异</strong>。也就是diff。</p><p data-lake-id=\"e0eb522e0656957a0052bc30cb83c9a0\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><br></p><p data-lake-id=\"983ad08c1d7cbe8f95a870014d704a12\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">对了上面好像没提到虚拟dom，其实jsx在js里存在形态就是一个对象，这个对象一般就叫做虚拟dom了。</p><p data-lake-id=\"54ccc9a5cb8bf2a5b36733c72a6a17b0\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><br></p><h2 data-lake-id=\"e3506d402b910a539e6e27e01adc99cb\" id=\"HQ7XC\" style=\"padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;\">虚拟DOM 就是一个js对象</h2><p data-lake-id=\"c185178a48de6c54d45cdb284bca088d\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><br></p><p data-lake-id=\"f491a8ad9caec4ffa84e2229d2a2c51d\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">虚拟dom实际上就是一个js对象，没有什么神奇，大概就长下面这样。属性个数视具体实现而定。但肯定比真实dom轻量多了。</p><p data-lake-id=\"0f3240ffc71871036e8047ddb33cf8db\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><span data-card-type=\"inline\" data-lake-card=\"image\" class=\"lake-card-margin-top lake-card-margin-bottom\"><img data-role=\"image\" src=\"https://cdn.nlark.com/yuque/0/2020/png/284138/1597740538842-cffb0fa3-45f9-4677-a975-ad2a70b87d2e.png\" data-raw-src=\"\" class=\"image lake-drag-image\" alt=\"image.png\" title=\"image.png\" style=\"visibility: visible; width: 217px; height: 212px;\"></span></p><p data-lake-id=\"1ad6e8ac02cbb2c7f1ba028c3d82971f\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">type（tag）-元素类型</p><p data-lake-id=\"fd52ab4409ed4345c9c87c18dd1528fa\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">props - 其它一些用户添加的属性（比如style啥的）</p><p data-lake-id=\"54a8733598365b3fe013036e40360ddd\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">children - 存放该dom下的子元素。（dom是树形结构嘛）</p><p data-lake-id=\"8b533bde71e3a182cb9fc82899d8d53c\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">key - 做diff时会用到，能降低diff算法的复杂度</p><p data-lake-id=\"cac292e2f07a7db38fe06d0126c34286\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><br></p><h2 data-lake-id=\"d66fa4ba5e9aa3c7fe209d130e6b5dc3\" id=\"xE36p\" style=\"padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;\">虚拟dom 优缺点</h2><p data-lake-id=\"88c27f2310e7ea22adb7e36092cb3d3d\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><br></p><p data-lake-id=\"a40cbf85e2a13a2a3875895e63ba5eee\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">优点：</p><p data-lake-id=\"62fa76ba2e7dd9c4530ae695562c5082\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">1.对比真实dom，轻量。带来的好处就是读取访问的性能快多了可以忽略不计了。</p><p data-lake-id=\"0b78c10f5c985b1a02652bebe38a5b2d\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">2.抽象出了一层虚拟dom（ui）层，隔离了真实dom，即隔离了渲染端，方便渲染到多端。也更方便上层组件的抽象化。</p><p data-lake-id=\"05cd8be61ef9de162b55e46ad7fb75ce\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">3.真实dom的操作全由使用虚拟dom的框架进行，方便进行各种统一，具有普适性<span>的优化。比个人所做的优化大多数情况下是要好的。</span></p><p data-lake-id=\"4febf432fb400b9e2a79047b2af7af5b\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><br></p><p data-lake-id=\"747364dd34fd04bd22e4f06f71565453\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">缺点：</p><p data-lake-id=\"c1ee80b158106a4b45a4cc47e1b294bb\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">所有操作先是在虚拟dom层，然后再统一翻译到真实dom上，尤其是第一次初始化的时候，全量虚拟dom都需要翻译到真实dom。比起直接操作dom，肯定多了一层虚拟dom层上的计算和操作。但是之后的更新，由于虚拟dom层会做一次diff，只会操作必要更新的dom，会比第一次好很多。当然直接操作dom你也可以做到只更新必要的dom，但其中的细节是不甚繁琐的，通常情况下，你根本不会考虑那么多。</p><p data-lake-id=\"db751fe43919947d72b8f187d8280447\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><br></p><p data-lake-id=\"c9c6a9975bab0e298edae3a6d20b1853\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">第一次初始化的时候：</p><p data-lake-id=\"72723dc15a826f5535a752eb211a236e\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">虚拟dom        数据 -&gt; 虚拟dom -&gt;真实dom</p><p data-lake-id=\"e8142d4eac286bf44dfa66e5a4671298\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">直接操作dom 数据 -&gt; 真实dom</p><p data-lake-id=\"d747a123204d008bc29557f9e437ca63\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><br></p><p data-lake-id=\"370ffc073d6c5fe42d5728254ef6eae7\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">后续更新的时候：</p><p data-lake-id=\"b2914d3566fce73436bf7c088629bc7e\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">虚拟dom        数据 -&gt; 虚拟dom -&gt; diff -&gt; 更新必要的dom</p><p data-lake-id=\"bd7ce33ad0c87fa72f65ae40b96392e3\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">直接操作dom 数据 -&gt; 你的算法 <span>-&gt;</span> 真实dom</p><p data-lake-id=\"3f999f630dfba36b71ef3e0230d832b6\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><br></p><h2 data-lake-id=\"e333ca8d6912562a0a47c32df20b9666\" id=\"5t4az\" style=\"padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;\">diff 是怎么从O(n^3)到O(n)的</h2><h2 data-lake-id=\"056a0d85d01a800cb623c380cba9ef0b\" id=\"YUo5H\" style=\"padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;\"><br></h2><p data-lake-id=\"f14631b2ddbd5658f680b2aa6bf2f96f\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">上面说过diff 就是如何比对两个DOM树的差异。两颗树形结构对比的话，复杂度是O(n^3)。这个复杂度的话代表1000个dom节点你要计算 1000 * 1000 * 1000 次，这几乎是不可能接受的。</p><p data-lake-id=\"d04464a0a23734dffd19c7e72e30e902\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">所以react里dom树的diff，针对性的做了些优化，让复杂度降低到了O(n)。这下就可以接受了。具体的优化手段如下。</p><p data-lake-id=\"8df3fc126878ac83e56e02d04edf6f71\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><br></p><p data-lake-id=\"40f6237e2a6a99df5d2f8208d049df8c\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">1.前端dom树跨层级操作比较少见，常见的操作在于子元素之间的移动，比如列表中的移动，删除，新增。所以有了第一次的优化，只对比同级的元素。然后复杂度降低到了O(n^2)。</p><p data-lake-id=\"639f8ce62091e24898d936b26e211d69\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><span data-card-type=\"inline\" data-lake-card=\"image\" class=\"lake-card-margin-top lake-card-margin-bottom\"><img data-role=\"image\" src=\"https://cdn.nlark.com/yuque/0/2020/png/284138/1597804649516-7340c6ce-8ad5-4d1a-9eac-92ccd8b5d726.png\" data-raw-src=\"\" class=\"image lake-drag-image\" alt=\"bV4e6N.png\" title=\"bV4e6N.png\" style=\"visibility: visible; width: 544px; height: 174px;\"></span></p><p data-lake-id=\"b03dc1751bec397d3a8b19b406c9823e\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">2.优化掉了跨级元素的比较，再来看看同级元素还有没有可以优化的。同级元素比较，不同元素标签可以直接判断是不同的，但是相同元素标签就比较麻烦了，三个input，变两个input，你是删除哪一个呢？或者你也可以直接全部删除，然后新建。为了避免这种情况，react使用在虚拟dom上加上一个key属性，来辅助做diff。这样比较的时候就能明确的知道哪个是哪个了。然后结合hash表。复杂度就下降到了O(n)</p><p data-lake-id=\"8e0f01023a328dd4e149b49565edaa72\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><span data-card-type=\"inline\" data-lake-card=\"image\" class=\"lake-card-margin-top lake-card-margin-bottom\"><img data-role=\"image\" src=\"https://cdn.nlark.com/yuque/0/2020/png/284138/1597805222138-0a4ee536-0f2c-46a0-8d30-f7cc2dd3ad05.png\" data-raw-src=\"\" class=\"image lake-drag-image\" alt=\"bV4e6Z.png\" title=\"bV4e6Z.png\" style=\"visibility: visible; width: 570px; height: 223px;\"></span></p><p data-lake-id=\"32521194bf641bebac917b119c976665\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><br></p><p data-lake-id=\"6d22cde7a4a7b26af58d637054a3efe6\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><br></p><h2 data-lake-id=\"93643d8a1695f32ee12e87f1c05cb3f5\" id=\"wBrOi\" style=\"padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;\"><br></h2><p data-lake-id=\"4122b0dc9f8e6724a4821e05dab9edff\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">图片摘自<a target=\"_blank\" href=\"https://segmentfault.com/a/1190000013365426#item-4\">react是怎样练成的</a>。</p></div>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"viewport\" content=\"fixed\" /><meta name=\"typography\" content=\"traditional\" /><p data-lake-id=\"d03b999554d9cbdce757e5c7317183a9\"><br /></p><h2 data-lake-id=\"4bed3fc86bd853b0f7f15cd09a09e527\" id=\"PvVA4\">虚拟dom的由来</h2><p data-lake-id=\"c53b97d440fb9696476ac812e8b1f443\"><br /></p><p data-lake-id=\"67460100f7029edb7d1b84903a8aca44\">虚拟dom最开始是出现在react里的，因为当时facebook想把后端的模板迁移到js里，然后就有了jsx。但是在处理更新的时候需要手动去操作dom（把模板翻译成真实dom），传统 DOM API 细节又太多，操作复杂，所以就很容易出现 Bug，而且代码难以维护。</p><p data-lake-id=\"53a365ce9d5108328ac7fc8010deab6f\">然后就有了react的核心思想，<strong>始终整体“刷新”页面当发生前后状态变化时，React 会自动更新 UI</strong>。让我们从复杂的 UI 操作中解放出来，使我们只需关于状态以及最终 UI 长什么样。<strong>只需要关系我的状态（数据是什么），以及 UI 长什么样（布局），不再需要关系操作细节</strong>。具体可以参考这篇文章<a target=\"_blank\" href=\"https://segmentfault.com/a/1190000013365426#item-4\">react是怎样练成的</a>。</p><p data-lake-id=\"d59afc0a42c9b2a1012480445455ebde\"><br /></p><p data-lake-id=\"ec61f131927b718112514e0a7118b4ee\">这种方法有两个问题</p><p data-lake-id=\"51b4ec75d01eb5c2810e8ad4afae616e\">1.毫无疑问的很慢，一点更新就需要更新整个dom树。</p><p data-lake-id=\"6414e069697b130d700690ca9465a6f8\">2.还有一个问题就是这样无法包含节点的状态。比如它会失去当前聚焦的元素和光标，以及文本选择和页面滚动位置，这些都是页面的当前状态。</p><p data-lake-id=\"eed118edb54b5687f89b82f82754995a\"><br /></p><p data-lake-id=\"03f1af541976dea4ba026a1fcb6a5195\" style=\"text-align: left;\">为了解决上面说的问题，facebook提出了对于没有改变的 DOM 节点，让它保持原样不动，仅仅创建并替换变更过的 DOM 节点。这种方式实现了 DOM 节点<strong>复用</strong>（Reuse）。</p><p data-lake-id=\"4fef1b4e22191211abdcaf8f95da8b4c\" style=\"text-align: left;\">至此，只要能够<strong>识别</strong>出哪些节点改变了，那么就可以实现对 DOM 的更新。于是问题就转化为<strong>如何比对两个 DOM 的差异</strong>。也就是diff。</p><p data-lake-id=\"e0eb522e0656957a0052bc30cb83c9a0\"><br /></p><p data-lake-id=\"983ad08c1d7cbe8f95a870014d704a12\">对了上面好像没提到虚拟dom，其实jsx在js里存在形态就是一个对象，这个对象一般就叫做虚拟dom了。</p><p data-lake-id=\"54ccc9a5cb8bf2a5b36733c72a6a17b0\"><br /></p><h2 data-lake-id=\"e3506d402b910a539e6e27e01adc99cb\" id=\"HQ7XC\">虚拟DOM 就是一个js对象</h2><p data-lake-id=\"c185178a48de6c54d45cdb284bca088d\"><br /></p><p data-lake-id=\"f491a8ad9caec4ffa84e2229d2a2c51d\">虚拟dom实际上就是一个js对象，没有什么神奇，大概就长下面这样。属性个数视具体实现而定。但肯定比真实dom轻量多了。</p><p data-lake-id=\"0f3240ffc71871036e8047ddb33cf8db\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2020%2Fpng%2F284138%2F1597740538842-cffb0fa3-45f9-4677-a975-ad2a70b87d2e.png%22%2C%22originWidth%22%3A217%2C%22originHeight%22%3A212%2C%22name%22%3A%22image.png%22%2C%22size%22%3A10918%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A20.89834%2C%22y%22%3A57.656467%2C%22width%22%3A170.36434%2C%22height%22%3A16.090263%2C%22text%22%3A%22constvirtuatDom-%22%7D%2C%7B%22x%22%3A54.011135%2C%22y%22%3A77.44107%2C%22width%22%3A110.39534499999999%2C%22height%22%3A14.949920000000006%2C%22text%22%3A%22type%3A'div%2C%22%7D%2C%7B%22x%22%3A54.11304%2C%22y%22%3A97.23267%2C%22width%22%3A77.09686%2C%22height%22%3A12.904930000000007%2C%22text%22%3A%22props%3A%22%7D%2C%7B%22x%22%3A88.7829%2C%22y%22%3A113.64911%2C%22width%22%3A84.82673000000001%2C%22height%22%3A14.324910000000003%2C%22text%22%3A%22style%3A0%22%7D%2C%7B%22x%22%3A53.047848%2C%22y%22%3A131.65422%2C%22width%22%3A16.503861999999998%2C%22height%22%3A16.120359999999977%2C%22text%22%3A%22%E5%AD%90%2C%22%7D%2C%7B%22x%22%3A146.13963%2C%22y%22%3A149.05168%2C%22width%22%3A17.38951%2C%22height%22%3A16.7226%2C%22text%22%3A%22%E9%97%A8%22%7D%2C%7B%22x%22%3A54.19018%2C%22y%22%3A150.08308%2C%22width%22%3A68.86292%2C%22height%22%3A13.40392%2C%22text%22%3A%22children%22%7D%5D%2C%22style%22%3A%22none%22%2C%22search%22%3A%22constvirtuatDom-%20type%3A'div%2C%20props%3A%20style%3A0%20%E5%AD%90%2C%20%E9%97%A8%20children%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22width%22%3A217%2C%22height%22%3A212%7D\"></card></p><p data-lake-id=\"1ad6e8ac02cbb2c7f1ba028c3d82971f\">type（tag）-元素类型</p><p data-lake-id=\"fd52ab4409ed4345c9c87c18dd1528fa\">props - 其它一些用户添加的属性（比如style啥的）</p><p data-lake-id=\"54a8733598365b3fe013036e40360ddd\">children - 存放该dom下的子元素。（dom是树形结构嘛）</p><p data-lake-id=\"8b533bde71e3a182cb9fc82899d8d53c\">key - 做diff时会用到，能降低diff算法的复杂度</p><p data-lake-id=\"cac292e2f07a7db38fe06d0126c34286\"><br /></p><h2 data-lake-id=\"d66fa4ba5e9aa3c7fe209d130e6b5dc3\" id=\"xE36p\">虚拟dom 优缺点</h2><p data-lake-id=\"88c27f2310e7ea22adb7e36092cb3d3d\"><br /></p><p data-lake-id=\"a40cbf85e2a13a2a3875895e63ba5eee\">优点：</p><p data-lake-id=\"62fa76ba2e7dd9c4530ae695562c5082\">1.对比真实dom，轻量。带来的好处就是读取访问的性能快多了可以忽略不计了。</p><p data-lake-id=\"0b78c10f5c985b1a02652bebe38a5b2d\">2.抽象出了一层虚拟dom（ui）层，隔离了真实dom，即隔离了渲染端，方便渲染到多端。也更方便上层组件的抽象化。</p><p data-lake-id=\"05cd8be61ef9de162b55e46ad7fb75ce\">3.真实dom的操作全由使用虚拟dom的框架进行，方便进行各种统一，具有普适性<span>的优化。比个人所做的优化大多数情况下是要好的。</span></p><p data-lake-id=\"4febf432fb400b9e2a79047b2af7af5b\"><br /></p><p data-lake-id=\"747364dd34fd04bd22e4f06f71565453\">缺点：</p><p data-lake-id=\"c1ee80b158106a4b45a4cc47e1b294bb\">所有操作先是在虚拟dom层，然后再统一翻译到真实dom上，尤其是第一次初始化的时候，全量虚拟dom都需要翻译到真实dom。比起直接操作dom，肯定多了一层虚拟dom层上的计算和操作。但是之后的更新，由于虚拟dom层会做一次diff，只会操作必要更新的dom，会比第一次好很多。当然直接操作dom你也可以做到只更新必要的dom，但其中的细节是不甚繁琐的，通常情况下，你根本不会考虑那么多。</p><p data-lake-id=\"db751fe43919947d72b8f187d8280447\"><br /></p><p data-lake-id=\"c9c6a9975bab0e298edae3a6d20b1853\">第一次初始化的时候：</p><p data-lake-id=\"72723dc15a826f5535a752eb211a236e\">虚拟dom        数据 -&gt; 虚拟dom -&gt;真实dom</p><p data-lake-id=\"e8142d4eac286bf44dfa66e5a4671298\">直接操作dom 数据 -&gt; 真实dom</p><p data-lake-id=\"d747a123204d008bc29557f9e437ca63\"><br /></p><p data-lake-id=\"370ffc073d6c5fe42d5728254ef6eae7\">后续更新的时候：</p><p data-lake-id=\"b2914d3566fce73436bf7c088629bc7e\">虚拟dom        数据 -&gt; 虚拟dom -&gt; diff -&gt; 更新必要的dom</p><p data-lake-id=\"bd7ce33ad0c87fa72f65ae40b96392e3\">直接操作dom 数据 -&gt; 你的算法 <span>-&gt;</span> 真实dom</p><p data-lake-id=\"3f999f630dfba36b71ef3e0230d832b6\"><br /></p><h2 data-lake-id=\"e333ca8d6912562a0a47c32df20b9666\" id=\"5t4az\">diff 是怎么从O(n^3)到O(n)的</h2><h2 data-lake-id=\"056a0d85d01a800cb623c380cba9ef0b\" id=\"YUo5H\"><br /></h2><p data-lake-id=\"f14631b2ddbd5658f680b2aa6bf2f96f\">上面说过diff 就是如何比对两个DOM树的差异。两颗树形结构对比的话，复杂度是O(n^3)。这个复杂度的话代表1000个dom节点你要计算 1000 * 1000 * 1000 次，这几乎是不可能接受的。</p><p data-lake-id=\"d04464a0a23734dffd19c7e72e30e902\">所以react里dom树的diff，针对性的做了些优化，让复杂度降低到了O(n)。这下就可以接受了。具体的优化手段如下。</p><p data-lake-id=\"8df3fc126878ac83e56e02d04edf6f71\"><br /></p><p data-lake-id=\"40f6237e2a6a99df5d2f8208d049df8c\">1.前端dom树跨层级操作比较少见，常见的操作在于子元素之间的移动，比如列表中的移动，删除，新增。所以有了第一次的优化，只对比同级的元素。然后复杂度降低到了O(n^2)。</p><p data-lake-id=\"639f8ce62091e24898d936b26e211d69\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2020%2Fpng%2F284138%2F1597804649516-7340c6ce-8ad5-4d1a-9eac-92ccd8b5d726.png%22%2C%22originWidth%22%3A544%2C%22originHeight%22%3A174%2C%22name%22%3A%22bV4e6N.png%22%2C%22size%22%3A22866%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A238.92058%2C%22y%22%3A31.205816%2C%22width%22%3A66.27651999999998%2C%22height%22%3A30.511832%2C%22text%22%3A%22O(n-)%22%7D%2C%7B%22x%22%3A239.23097%2C%22y%22%3A75.1386%2C%22width%22%3A66.63538999999997%2C%22height%22%3A34.86316000000001%2C%22text%22%3A%22O(n-%22%7D%2C%7B%22x%22%3A286.9916%2C%22y%22%3A123.47297%2C%22width%22%3A64.88193999999999%2C%22height%22%3A31.5599%2C%22text%22%3A%22O(n%22%7D%2C%7B%22x%22%3A189.06018%2C%22y%22%3A124.67691%2C%22width%22%3A71.82422000000003%2C%22height%22%3A33.56451%2C%22text%22%3A%22O(n%22%7D%5D%2C%22style%22%3A%22none%22%2C%22search%22%3A%22O(n-)%20O(n-%20O(n%20O(n%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22width%22%3A544%2C%22height%22%3A174%7D\"></card></p><p data-lake-id=\"b03dc1751bec397d3a8b19b406c9823e\">2.优化掉了跨级元素的比较，再来看看同级元素还有没有可以优化的。同级元素比较，不同元素标签可以直接判断是不同的，但是相同元素标签就比较麻烦了，三个input，变两个input，你是删除哪一个呢？或者你也可以直接全部删除，然后新建。为了避免这种情况，react使用在虚拟dom上加上一个key属性，来辅助做diff。这样比较的时候就能明确的知道哪个是哪个了。然后结合hash表。复杂度就下降到了O(n)</p><p data-lake-id=\"8e0f01023a328dd4e149b49565edaa72\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2020%2Fpng%2F284138%2F1597805222138-0a4ee536-0f2c-46a0-8d30-f7cc2dd3ad05.png%22%2C%22originWidth%22%3A570%2C%22originHeight%22%3A223%2C%22name%22%3A%22bV4e6Z.png%22%2C%22size%22%3A23681%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A254.13434%2C%22y%22%3A38.542316%2C%22width%22%3A58.74349999999998%2C%22height%22%3A26.316288%2C%22text%22%3A%22On)%22%7D%2C%7B%22x%22%3A253.33698%2C%22y%22%3A82.47173%2C%22width%22%3A58.723780000000005%2C%22height%22%3A33.60224000000001%2C%22text%22%3A%22on)%22%7D%2C%7B%22x%22%3A271.13525%2C%22y%22%3A113.55279%2C%22width%22%3A22.090370000000007%2C%22height%22%3A20.660999999999987%2C%22text%22%3A%22%2B%22%7D%2C%7B%22x%22%3A300.02438%2C%22y%22%3A128.39856%2C%22width%22%3A60.185580000000016%2C%22height%22%3A35.22278%2C%22text%22%3A%22O(n)%22%7D%2C%7B%22x%22%3A206.2218%2C%22y%22%3A130.4724%2C%22width%22%3A57.63976999999997%2C%22height%22%3A28.774959999999993%2C%22text%22%3A%22On)%22%7D%2C%7B%22x%22%3A243.92107%2C%22y%22%3A176.85722%2C%22width%22%3A78.30867%2C%22height%22%3A38.10843%2C%22text%22%3A%22O(n)%22%7D%5D%2C%22style%22%3A%22none%22%2C%22search%22%3A%22On)%20on)%20%2B%20O(n)%20On)%20O(n)%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22width%22%3A570%2C%22height%22%3A223%7D\"></card></p><p data-lake-id=\"32521194bf641bebac917b119c976665\"><br /></p><p data-lake-id=\"6d22cde7a4a7b26af58d637054a3efe6\"><br /></p><h2 data-lake-id=\"93643d8a1695f32ee12e87f1c05cb3f5\" id=\"wBrOi\"><br /></h2><p data-lake-id=\"4122b0dc9f8e6724a4821e05dab9edff\">图片摘自<a target=\"_blank\" href=\"https://segmentfault.com/a/1190000013365426#item-4\">react是怎样练成的</a>。</p>",
  "body_draft_lake": "",
  "public": 1,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2020-08-19T02:51:29.000Z",
  "deleted_at": null,
  "created_at": "2020-08-18T08:22:59.000Z",
  "updated_at": "2020-08-19T02:51:30.000Z",
  "published_at": "2020-08-19T02:51:29.000Z",
  "first_published_at": "2020-08-19T02:51:29.000Z",
  "word_count": 1430,
  "cover": "https://cdn.nlark.com/yuque/0/2020/png/284138/1597740538842-cffb0fa3-45f9-4677-a975-ad2a70b87d2e.png",
  "description": "虚拟dom的由来虚拟dom最开始是出现在react里的，因为当时facebook想把后端的模板迁移到js里，然后就有了jsx。但是在处理更新的时候需要手动去操作dom（把模板翻译成真实dom），传统 DOM API 细节又太多，操作复杂，所以就很容易出现 Bug，而且代码难以维护。然后就有了r...",
  "custom_description": null,
  "hits": 32,
  "_serializer": "v2.doc_detail"
}