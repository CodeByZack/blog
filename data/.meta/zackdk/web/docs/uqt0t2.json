{
  "id": 2027375,
  "slug": "uqt0t2",
  "title": "JS知识点之Generator执行异步任务",
  "book_id": 231593,
  "book": {
    "id": 231593,
    "type": "Book",
    "slug": "web",
    "name": "WEB",
    "user_id": 284138,
    "description": "前端知识点记录",
    "creator_id": 284138,
    "public": 1,
    "items_count": 58,
    "likes_count": 0,
    "watches_count": 3,
    "content_updated_at": "2023-02-02T09:09:21.426Z",
    "updated_at": "2023-02-02T09:09:21.000Z",
    "created_at": "2019-03-07T05:05:08.000Z",
    "namespace": "zackdk/web",
    "user": {
      "id": 284138,
      "type": "User",
      "login": "zackdk",
      "name": "行一度空山",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1551934932702-d412771d-8d33-4694-9186-a749a3b4e05b.jpeg",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 5,
      "following_count": 0,
      "created_at": "2019-03-07T05:02:38.000Z",
      "updated_at": "2023-02-01T12:18:25.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 284138,
  "creator": {
    "id": 284138,
    "type": "User",
    "login": "zackdk",
    "name": "行一度空山",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1551934932702-d412771d-8d33-4694-9186-a749a3b4e05b.jpeg",
    "books_count": 2,
    "public_books_count": 1,
    "followers_count": 5,
    "following_count": 0,
    "created_at": "2019-03-07T05:02:38.000Z",
    "updated_at": "2023-02-01T12:18:25.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "\n<a name=\"c8ff2c48\"></a>\n### Generator基本的语法\n\n```javascript\nfunction* a(){\n\tconsole.log('hello generator');\n}\nvar a1 = a();//这里不会执行函数内部任何代码，只会返回一个迭代器\na1.next();//这里会打印hello generator，返回值为{value:undefined,done:true}\nfunction* b(){\n    yield 1;\n    yield 2;\n    return 3;\n}\nvar b1 = b();\nb1.next();//{value:1,done:false}\nb1.next();//{value:2,done:false}\nb1.next();//{value:3,done:true}\n```\n<a name=\"9fdc86c9\"></a>\n#### generator可以向外输出数据\n\n```javascript\nfunction* b(){\n    yield 1;\n    yield 2;\n    return 3;\n}\nvar b1 = b();\nb1.next();//{value:1,done:false}\nb1.next();//{value:2,done:false}\nb1.next();//{value:3,done:true}\n```\n\n其中value的值 有几种情况。\n\n1. 遇到yield ：value为 yield后表达式的值，done为false。\n2. 遇到return ：value为 return 后表达式的值，done为true。\n3. 函数执行完毕，没有return ： value为undfined，done为true。\n\n<a name=\"a53b1d21\"></a>\n#### generator可以接受外部的输入数据\n\nyield本身并没有返回值，但next可以接收一个参数。<br />该参数会被当作上一个yield的返回值。\n\n```javascript\nfunction* c(){\n    let a = yield 1;\n    let b = yield a;\n\treturn b;\n}\nvar c1 = c();\nc1.next();//{value:1,done:false}\nc1.next(2);//{value:2,done:false}\nc1.next(3);//{value:3,done:true}\n```\n\n<a name=\"d3cb8f20\"></a>\n#### generator特别的地方\n\n1. 可控制代片段的暂停与执行，遇到yield暂停执行代码，外部手动调用next恢复执行。\n2. 对于每一个代码段，你可以通过next函数的返回值获得代码段的输出，通过next函数传参，向代码段输入参数。\n3. generator函数调用后，返回的是一个迭代器，迭代器每一次迭代都是执行某段代码片段，获得返回值。\n\n<a name=\"ceed1589\"></a>\n### generator的执行器\n\ngenerator遇到yield后回暂停执行，并不会自动恢复执行，恢复执行必须手动调用next。像下面这样。\n\n```javascript\nfunction *main(){\n    let a = yield 1 + 2;\n    let b = yield 3 + a;\n    let c = yield 7 + b;\n\tconsole.log(c);\n}\n//这里生成迭代器，并不会执行任何函数内的代码\nlet m = main();\n//执行到第一个yield表达式\nlet resObj = m.next();//{value:3,done:false}\n//执行到第二个yield表达式,并把上一个yield获得的值传入，作为yield的返回值\nresObj = m.next(resObj.value);//{value:6,done:false}\nresObj = m.next(resObj.value);//{value:13,done:false}\n```\n\n观察上面的表达式，可以看到，手动调用next，显得很繁琐，而且其中有重复的逻辑。<br />把next获得的返回值作为下一次next的入参，传进generator内部。\n\n<a name=\"adeca386\"></a>\n#### 同步任务的自动执行\n\n所以可以写一个自动执行器，像下面这样\n\n```javascript\nfunction makeCall(num){\n    console.log(`${num} 进行*2操作`)\n    return num * 2\n}\nfunction run(generator){\n    let it = generator();\n    let resObj = it.next();\n    while(!resObj.done){\n        resObj = it.next(resObj.value);\n    }\n}\nfunction *main(){\n    let a = yield makeCall(2);\n    let b = yield makeCall(a);\n    let c = yield makeCall(b);\n\tconsole.log(c);\n}\nrun(main);\n```\n\n因为每一次判断还可以迭代的时候，是立马执行下一个it.next()的。所以这个执行器是只能执行同步的任务。假如任务是异步的，是没法一个接一个的执行的。\n\n<a name=\"c3846e8c\"></a>\n#### 异步任务的自动执行\n\n异步任务，简单理解就是，发请求，请求回来过后会有一个callback来处理返回结果。<br />有些时候下一个异步任务需要依赖于上一个异步任务的返回值。这样的依赖一多，就会形成callback hell了。\n\n```javascript\nfunction makeCall(arg,callback){\n    console.log(`${arg} 进行*2操作,并在1s后通知操作完成`)\n\tsetTimeout(()=>{callback(arg*2)},1000);\n}\n//经典的callback形式\nmakeCall(111,(arg)=>{\n\tconsole.log(arg)\n});\n//经典的回掉地狱\nmakeCall(111,(res)=>{\n\tconsole.log(res)\n\tmakeCall(res,(res2)=>{\n    \tconsole.log(res2);\n\t})\n});\n```\n\n**利用thunk结合generator处理异步任务：**<br />原有的makeCall函数，callback是作为函数参数传入的，异步的请求和返回结果处理在一个函数，没有分开。在结合yield时候很不方便，或者说复杂。<br />所以这里需要对callback形式做一些改变，引入thunk，thunk函数介绍[链接](http://es6.ruanyifeng.com/#docs/generator-async#Thunk-%E5%87%BD%E6%95%B0)\n\n```javascript\nfunction makeCall(arg,callback){\n    console.log(`${arg} 进行*2操作,并在1s后通知操作完成`)\n\tsetTimeout(()=>{callback(arg*2)},1000);\n}\n//改造makeCall为thunk形式\nfunction makeCallThunk (arg) {\n    return function (callback) {\n        return makeCall(arg, callback);\n    };\n};\n//调用应该像下面这样\nmakeCallThunk(arg)(cb);\n```\n\n函数thunk化后，如果需要发起请求，需要调用两次。<br />第一次调用返回的是函数<br />第二次调用才会真正发起请求<br />有了thunk函数，写一个针对异步操作的自动执行器就容易多了\n\n```javascript\n//thunk版本的自动执行器\nfunction run(fn) {\n    let it = fn();\n    function next(data) {\n        var resObj = it.next(data);\n        if (resObj.done) return;\n        resObj.value(next);\n    }\n    next();\n}\n//可以仔细看下面这个代码，和执行同步任务的时候并没有什么差别。\nfunction *makeCallGenerator(){\n    let res = yield makeCallThunk(2);\n    let res2 = yield makeCallThunk(res);\n    let res3 = yield makeCallThunk(res2);\n    console.log(res3)\n}\nrun(makeCallGenerator)\n```\n\n**利用promise结合generator处理异步任务：**<br />promise都比较熟悉了，先给makeCall包装一层promise。\n\n```javascript\nfunction makeCall(arg,callback){\n    console.log(`${arg} 进行*2操作,并在1s后通知操作完成`)\nsetTimeout(()=>{callback(arg*2)},1000);\n}\n//makeCall 包装一层promise\nfunction makeCallPromise(arg){\n\treturn new Promise((resolve,reject)=>{\n\t\tmakeCall(arg,(res)=>{\n\t\t\tif(res>1000){reject(res);}else{resolve(res);}\n\t\t});\n\t})\n}\n//promise形式调用。\nmakeCallPromise(111)\n\t.then((res)=>{console.log(res)});\n//promise让回调减少了一些层级，好看一些了。\nmakeCallPromise(111)\n\t.then((res)=>makeCallPromise(222))\n\t.then((res)=>console.log(res));\n```\n\npromise版本的执行器\n\n```javascript\nfunction* makeCallGenerator(){\nlet res = yield makeCallPromise(2);\n    let res2 = yield makeCallPromise(res);\n    let res3 = yield makeCallPromise(res2);\n    console.log(res3)\n}\n//执行器\nfunction run(gen){\n\tlet it = gen();\n\tfunction next(data){\n    \tlet resObj = it.next(data);\n        if(resObj.done)return;\n        resObj.value.then((res)=>next(res));\n\t}\n    next();\n}\nrun(makeCallGenerator)\n```\n\n<a name=\"23abcbd1\"></a>\n### 两个问题\n\n1. **使用generator执行异步操作的好处。**\n2. **与async，await的差异。**\n\n<a name=\"04b6391b\"></a>\n#### 使用generator执行异步操作的好处。\n\n```javascript\n//异步任务\nfunction* makeCallGenerator(){\n\tlet res = yield makeCallPromise(2);\n    let res2 = yield makeCallPromise(res);\n    let res3 = yield makeCallPromise(res2);\n    console.log(res3)\n}\nrun(makeCallGenerator)\nconsole.log(1);\n//同步任务\nfunction *main(){\n    let a = yield makeCall(2);\n    let b = yield makeCall(a);\n    let c = yield makeCall(b);\n\tconsole.log(c);\n}\nrun(main);\nconsole.log(1);\n```\n\n抛开generator的执行器不看，异步任务和同步任务的写法几乎一模一样。\n\n<a name=\"923a5f2b\"></a>\n#### 与async，await的差异。\n\n```javascript\n//generator\nfunction* makeCallGenerator(){\n\tlet res = yield makeCallPromise(2);\n    let res2 = yield makeCallPromise(res);\n    let res3 = yield makeCallPromise(res2);\n    console.log(res3)\n}\nrun(makeCallGenerator)\n//async await\nasync function makeCallCopy(){\n    let res = await makeCallPromise(2);\n    let res2 = await makeCallPromise(res);\n    let res3 = await makeCallPromise(res2);\n    console.log(res3)\n}\nmakeCallCopy();\n```\n\n写法几乎一模一样，只不过 * 号变成了 async，yield 变成了 await。<br />但async/await执行器是自带的，generator执行器需要自己去手写，但也意味着更多可能。<br />另外 async/await 默认是 使用的 generator + promise的形式执行异步任务，是这个模式之上的语法糖，能很好的解决异步任务。<br />但generator除了结合promise 和可以结合类似thunk之类的去执行异步任务。\n<a name=\"end\"></a>\n# \n",
  "body_draft": "",
  "body_html": "<!doctype html><p><br /></p><h3 id=\"c8ff2c48\">Generator基本的语法</h3><p><br /></p><pre data-lang=\"javascript\"><code>function* a(){\n\tconsole.log('hello generator');\n}\nvar a1 = a();//这里不会执行函数内部任何代码，只会返回一个迭代器\na1.next();//这里会打印hello generator，返回值为{value:undefined,done:true}\nfunction* b(){\n    yield 1;\n    yield 2;\n    return 3;\n}\nvar b1 = b();\nb1.next();//{value:1,done:false}\nb1.next();//{value:2,done:false}\nb1.next();//{value:3,done:true}</code></pre><h4 id=\"9fdc86c9\">generator可以向外输出数据</h4><p><br /></p><pre data-lang=\"javascript\"><code>function* b(){\n    yield 1;\n    yield 2;\n    return 3;\n}\nvar b1 = b();\nb1.next();//{value:1,done:false}\nb1.next();//{value:2,done:false}\nb1.next();//{value:3,done:true}</code></pre><p><br /></p><p>其中value的值 有几种情况。</p><p><br /></p><ol start=\"1\"><li>遇到yield ：value为 yield后表达式的值，done为false。</li><li>遇到return ：value为 return 后表达式的值，done为true。</li><li>函数执行完毕，没有return ： value为undfined，done为true。</li></ol><p><br /></p><h4 id=\"a53b1d21\">generator可以接受外部的输入数据</h4><p><br /></p><p>yield本身并没有返回值，但next可以接收一个参数。</p><p>该参数会被当作上一个yield的返回值。</p><p><br /></p><pre data-lang=\"javascript\"><code>function* c(){\n    let a = yield 1;\n    let b = yield a;\n\treturn b;\n}\nvar c1 = c();\nc1.next();//{value:1,done:false}\nc1.next(2);//{value:2,done:false}\nc1.next(3);//{value:3,done:true}</code></pre><p><br /></p><h4 id=\"d3cb8f20\">generator特别的地方</h4><p><br /></p><ol start=\"1\"><li>可控制代片段的暂停与执行，遇到yield暂停执行代码，外部手动调用next恢复执行。</li><li>对于每一个代码段，你可以通过next函数的返回值获得代码段的输出，通过next函数传参，向代码段输入参数。</li><li>generator函数调用后，返回的是一个迭代器，迭代器每一次迭代都是执行某段代码片段，获得返回值。</li></ol><p><br /></p><h3 id=\"ceed1589\">generator的执行器</h3><p><br /></p><p>generator遇到yield后回暂停执行，并不会自动恢复执行，恢复执行必须手动调用next。像下面这样。</p><p><br /></p><pre data-lang=\"javascript\"><code>function *main(){\n    let a = yield 1 + 2;\n    let b = yield 3 + a;\n    let c = yield 7 + b;\n\tconsole.log(c);\n}\n//这里生成迭代器，并不会执行任何函数内的代码\nlet m = main();\n//执行到第一个yield表达式\nlet resObj = m.next();//{value:3,done:false}\n//执行到第二个yield表达式,并把上一个yield获得的值传入，作为yield的返回值\nresObj = m.next(resObj.value);//{value:6,done:false}\nresObj = m.next(resObj.value);//{value:13,done:false}</code></pre><p><br /></p><p>观察上面的表达式，可以看到，手动调用next，显得很繁琐，而且其中有重复的逻辑。</p><p>把next获得的返回值作为下一次next的入参，传进generator内部。</p><p><br /></p><h4 id=\"adeca386\">同步任务的自动执行</h4><p><br /></p><p>所以可以写一个自动执行器，像下面这样</p><p><br /></p><pre data-lang=\"javascript\"><code>function makeCall(num){\n    console.log(`${num} 进行*2操作`)\n    return num * 2\n}\nfunction run(generator){\n    let it = generator();\n    let resObj = it.next();\n    while(!resObj.done){\n        resObj = it.next(resObj.value);\n    }\n}\nfunction *main(){\n    let a = yield makeCall(2);\n    let b = yield makeCall(a);\n    let c = yield makeCall(b);\n\tconsole.log(c);\n}\nrun(main);</code></pre><p><br /></p><p>因为每一次判断还可以迭代的时候，是立马执行下一个it.next()的。所以这个执行器是只能执行同步的任务。假如任务是异步的，是没法一个接一个的执行的。</p><p><br /></p><h4 id=\"c3846e8c\">异步任务的自动执行</h4><p><br /></p><p>异步任务，简单理解就是，发请求，请求回来过后会有一个callback来处理返回结果。</p><p>有些时候下一个异步任务需要依赖于上一个异步任务的返回值。这样的依赖一多，就会形成callback hell了。</p><p><br /></p><pre data-lang=\"javascript\"><code>function makeCall(arg,callback){\n    console.log(`${arg} 进行*2操作,并在1s后通知操作完成`)\n\tsetTimeout(()=&gt;{callback(arg*2)},1000);\n}\n//经典的callback形式\nmakeCall(111,(arg)=&gt;{\n\tconsole.log(arg)\n});\n//经典的回掉地狱\nmakeCall(111,(res)=&gt;{\n\tconsole.log(res)\n\tmakeCall(res,(res2)=&gt;{\n    \tconsole.log(res2);\n\t})\n});</code></pre><p><br /></p><p><strong>利用thunk结合generator处理异步任务：</strong></p><p>原有的makeCall函数，callback是作为函数参数传入的，异步的请求和返回结果处理在一个函数，没有分开。在结合yield时候很不方便，或者说复杂。</p><p>所以这里需要对callback形式做一些改变，引入thunk，thunk函数介绍<a href=\"http://es6.ruanyifeng.com/#docs/generator-async#Thunk-%E5%87%BD%E6%95%B0\" target=\"_blank\">链接</a></p><p><br /></p><pre data-lang=\"javascript\"><code>function makeCall(arg,callback){\n    console.log(`${arg} 进行*2操作,并在1s后通知操作完成`)\n\tsetTimeout(()=&gt;{callback(arg*2)},1000);\n}\n//改造makeCall为thunk形式\nfunction makeCallThunk (arg) {\n    return function (callback) {\n        return makeCall(arg, callback);\n    };\n};\n//调用应该像下面这样\nmakeCallThunk(arg)(cb);</code></pre><p><br /></p><p>函数thunk化后，如果需要发起请求，需要调用两次。</p><p>第一次调用返回的是函数</p><p>第二次调用才会真正发起请求</p><p>有了thunk函数，写一个针对异步操作的自动执行器就容易多了</p><p><br /></p><pre data-lang=\"javascript\"><code>//thunk版本的自动执行器\nfunction run(fn) {\n    let it = fn();\n    function next(data) {\n        var resObj = it.next(data);\n        if (resObj.done) return;\n        resObj.value(next);\n    }\n    next();\n}\n//可以仔细看下面这个代码，和执行同步任务的时候并没有什么差别。\nfunction *makeCallGenerator(){\n    let res = yield makeCallThunk(2);\n    let res2 = yield makeCallThunk(res);\n    let res3 = yield makeCallThunk(res2);\n    console.log(res3)\n}\nrun(makeCallGenerator)</code></pre><p><br /></p><p><strong>利用promise结合generator处理异步任务：</strong></p><p>promise都比较熟悉了，先给makeCall包装一层promise。</p><p><br /></p><pre data-lang=\"javascript\"><code>function makeCall(arg,callback){\n    console.log(`${arg} 进行*2操作,并在1s后通知操作完成`)\nsetTimeout(()=&gt;{callback(arg*2)},1000);\n}\n//makeCall 包装一层promise\nfunction makeCallPromise(arg){\n\treturn new Promise((resolve,reject)=&gt;{\n\t\tmakeCall(arg,(res)=&gt;{\n\t\t\tif(res&gt;1000){reject(res);}else{resolve(res);}\n\t\t});\n\t})\n}\n//promise形式调用。\nmakeCallPromise(111)\n\t.then((res)=&gt;{console.log(res)});\n//promise让回调减少了一些层级，好看一些了。\nmakeCallPromise(111)\n\t.then((res)=&gt;makeCallPromise(222))\n\t.then((res)=&gt;console.log(res));</code></pre><p><br /></p><p>promise版本的执行器</p><p><br /></p><pre data-lang=\"javascript\"><code>function* makeCallGenerator(){\nlet res = yield makeCallPromise(2);\n    let res2 = yield makeCallPromise(res);\n    let res3 = yield makeCallPromise(res2);\n    console.log(res3)\n}\n//执行器\nfunction run(gen){\n\tlet it = gen();\n\tfunction next(data){\n    \tlet resObj = it.next(data);\n        if(resObj.done)return;\n        resObj.value.then((res)=&gt;next(res));\n\t}\n    next();\n}\nrun(makeCallGenerator)</code></pre><p><br /></p><h3 id=\"23abcbd1\">两个问题</h3><p><br /></p><ol start=\"1\"><li><strong>使用generator执行异步操作的好处。</strong></li><li><strong>与async，await的差异。</strong></li></ol><p><br /></p><h4 id=\"04b6391b\">使用generator执行异步操作的好处。</h4><p><br /></p><pre data-lang=\"javascript\"><code>//异步任务\nfunction* makeCallGenerator(){\n\tlet res = yield makeCallPromise(2);\n    let res2 = yield makeCallPromise(res);\n    let res3 = yield makeCallPromise(res2);\n    console.log(res3)\n}\nrun(makeCallGenerator)\nconsole.log(1);\n//同步任务\nfunction *main(){\n    let a = yield makeCall(2);\n    let b = yield makeCall(a);\n    let c = yield makeCall(b);\n\tconsole.log(c);\n}\nrun(main);\nconsole.log(1);</code></pre><p><br /></p><p>抛开generator的执行器不看，异步任务和同步任务的写法几乎一模一样。</p><p><br /></p><h4 id=\"923a5f2b\">与async，await的差异。</h4><p><br /></p><pre data-lang=\"javascript\"><code>//generator\nfunction* makeCallGenerator(){\n\tlet res = yield makeCallPromise(2);\n    let res2 = yield makeCallPromise(res);\n    let res3 = yield makeCallPromise(res2);\n    console.log(res3)\n}\nrun(makeCallGenerator)\n//async await\nasync function makeCallCopy(){\n    let res = await makeCallPromise(2);\n    let res2 = await makeCallPromise(res);\n    let res3 = await makeCallPromise(res2);\n    console.log(res3)\n}\nmakeCallCopy();</code></pre><p><br /></p><p>写法几乎一模一样，只不过 * 号变成了 async，yield 变成了 await。</p><p>但async/await执行器是自带的，generator执行器需要自己去手写，但也意味着更多可能。</p><p>另外 async/await 默认是 使用的 generator + promise的形式执行异步任务，是这个模式之上的语法糖，能很好的解决异步任务。</p><p>但generator除了结合promise 和可以结合类似thunk之类的去执行异步任务。</p><h1 id=\"end\"><br /></h1>",
  "body_lake": "<!doctype lake><p><br /></p><h3 id=\"c8ff2c48\">Generator基本的语法</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%2226ed9206%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function*%20a()%7B%5Cn%5Ctconsole.log('hello%20generator')%3B%5Cn%7D%5Cnvar%20a1%20%3D%20a()%3B%2F%2F%E8%BF%99%E9%87%8C%E4%B8%8D%E4%BC%9A%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E4%BB%BB%E4%BD%95%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%8F%AA%E4%BC%9A%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E8%BF%AD%E4%BB%A3%E5%99%A8%5Cna1.next()%3B%2F%2F%E8%BF%99%E9%87%8C%E4%BC%9A%E6%89%93%E5%8D%B0hello%20generator%EF%BC%8C%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%BA%7Bvalue%3Aundefined%2Cdone%3Atrue%7D%5Cnfunction*%20b()%7B%5Cn%20%20%20%20yield%201%3B%5Cn%20%20%20%20yield%202%3B%5Cn%20%20%20%20return%203%3B%5Cn%7D%5Cnvar%20b1%20%3D%20b()%3B%5Cnb1.next()%3B%2F%2F%7Bvalue%3A1%2Cdone%3Afalse%7D%5Cnb1.next()%3B%2F%2F%7Bvalue%3A2%2Cdone%3Afalse%7D%5Cnb1.next()%3B%2F%2F%7Bvalue%3A3%2Cdone%3Atrue%7D%22%7D\"></card><h4 id=\"9fdc86c9\">generator可以向外输出数据</h4><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22cc7af61e%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function*%20b()%7B%5Cn%20%20%20%20yield%201%3B%5Cn%20%20%20%20yield%202%3B%5Cn%20%20%20%20return%203%3B%5Cn%7D%5Cnvar%20b1%20%3D%20b()%3B%5Cnb1.next()%3B%2F%2F%7Bvalue%3A1%2Cdone%3Afalse%7D%5Cnb1.next()%3B%2F%2F%7Bvalue%3A2%2Cdone%3Afalse%7D%5Cnb1.next()%3B%2F%2F%7Bvalue%3A3%2Cdone%3Atrue%7D%22%7D\"></card><p><br /></p><p>其中value的值 有几种情况。</p><p><br /></p><ol start=\"1\"><li>遇到yield ：value为 yield后表达式的值，done为false。</li><li>遇到return ：value为 return 后表达式的值，done为true。</li><li>函数执行完毕，没有return ： value为undfined，done为true。</li></ol><p><br /></p><h4 id=\"a53b1d21\">generator可以接受外部的输入数据</h4><p><br /></p><p>yield本身并没有返回值，但next可以接收一个参数。</p><p>该参数会被当作上一个yield的返回值。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22e20e5e49%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function*%20c()%7B%5Cn%20%20%20%20let%20a%20%3D%20yield%201%3B%5Cn%20%20%20%20let%20b%20%3D%20yield%20a%3B%5Cn%5Ctreturn%20b%3B%5Cn%7D%5Cnvar%20c1%20%3D%20c()%3B%5Cnc1.next()%3B%2F%2F%7Bvalue%3A1%2Cdone%3Afalse%7D%5Cnc1.next(2)%3B%2F%2F%7Bvalue%3A2%2Cdone%3Afalse%7D%5Cnc1.next(3)%3B%2F%2F%7Bvalue%3A3%2Cdone%3Atrue%7D%22%7D\"></card><p><br /></p><h4 id=\"d3cb8f20\">generator特别的地方</h4><p><br /></p><ol start=\"1\"><li>可控制代片段的暂停与执行，遇到yield暂停执行代码，外部手动调用next恢复执行。</li><li>对于每一个代码段，你可以通过next函数的返回值获得代码段的输出，通过next函数传参，向代码段输入参数。</li><li>generator函数调用后，返回的是一个迭代器，迭代器每一次迭代都是执行某段代码片段，获得返回值。</li></ol><p><br /></p><h3 id=\"ceed1589\">generator的执行器</h3><p><br /></p><p>generator遇到yield后回暂停执行，并不会自动恢复执行，恢复执行必须手动调用next。像下面这样。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22b9fae235%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20*main()%7B%5Cn%20%20%20%20let%20a%20%3D%20yield%201%20%2B%202%3B%5Cn%20%20%20%20let%20b%20%3D%20yield%203%20%2B%20a%3B%5Cn%20%20%20%20let%20c%20%3D%20yield%207%20%2B%20b%3B%5Cn%5Ctconsole.log(c)%3B%5Cn%7D%5Cn%2F%2F%E8%BF%99%E9%87%8C%E7%94%9F%E6%88%90%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%8C%E5%B9%B6%E4%B8%8D%E4%BC%9A%E6%89%A7%E8%A1%8C%E4%BB%BB%E4%BD%95%E5%87%BD%E6%95%B0%E5%86%85%E7%9A%84%E4%BB%A3%E7%A0%81%5Cnlet%20m%20%3D%20main()%3B%5Cn%2F%2F%E6%89%A7%E8%A1%8C%E5%88%B0%E7%AC%AC%E4%B8%80%E4%B8%AAyield%E8%A1%A8%E8%BE%BE%E5%BC%8F%5Cnlet%20resObj%20%3D%20m.next()%3B%2F%2F%7Bvalue%3A3%2Cdone%3Afalse%7D%5Cn%2F%2F%E6%89%A7%E8%A1%8C%E5%88%B0%E7%AC%AC%E4%BA%8C%E4%B8%AAyield%E8%A1%A8%E8%BE%BE%E5%BC%8F%2C%E5%B9%B6%E6%8A%8A%E4%B8%8A%E4%B8%80%E4%B8%AAyield%E8%8E%B7%E5%BE%97%E7%9A%84%E5%80%BC%E4%BC%A0%E5%85%A5%EF%BC%8C%E4%BD%9C%E4%B8%BAyield%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%5CnresObj%20%3D%20m.next(resObj.value)%3B%2F%2F%7Bvalue%3A6%2Cdone%3Afalse%7D%5CnresObj%20%3D%20m.next(resObj.value)%3B%2F%2F%7Bvalue%3A13%2Cdone%3Afalse%7D%22%7D\"></card><p><br /></p><p>观察上面的表达式，可以看到，手动调用next，显得很繁琐，而且其中有重复的逻辑。</p><p>把next获得的返回值作为下一次next的入参，传进generator内部。</p><p><br /></p><h4 id=\"adeca386\">同步任务的自动执行</h4><p><br /></p><p>所以可以写一个自动执行器，像下面这样</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%2274f46d0c%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20makeCall(num)%7B%5Cn%20%20%20%20console.log(%60%24%7Bnum%7D%20%E8%BF%9B%E8%A1%8C*2%E6%93%8D%E4%BD%9C%60)%5Cn%20%20%20%20return%20num%20*%202%5Cn%7D%5Cnfunction%20run(generator)%7B%5Cn%20%20%20%20let%20it%20%3D%20generator()%3B%5Cn%20%20%20%20let%20resObj%20%3D%20it.next()%3B%5Cn%20%20%20%20while(!resObj.done)%7B%5Cn%20%20%20%20%20%20%20%20resObj%20%3D%20it.next(resObj.value)%3B%5Cn%20%20%20%20%7D%5Cn%7D%5Cnfunction%20*main()%7B%5Cn%20%20%20%20let%20a%20%3D%20yield%20makeCall(2)%3B%5Cn%20%20%20%20let%20b%20%3D%20yield%20makeCall(a)%3B%5Cn%20%20%20%20let%20c%20%3D%20yield%20makeCall(b)%3B%5Cn%5Ctconsole.log(c)%3B%5Cn%7D%5Cnrun(main)%3B%22%7D\"></card><p><br /></p><p>因为每一次判断还可以迭代的时候，是立马执行下一个it.next()的。所以这个执行器是只能执行同步的任务。假如任务是异步的，是没法一个接一个的执行的。</p><p><br /></p><h4 id=\"c3846e8c\">异步任务的自动执行</h4><p><br /></p><p>异步任务，简单理解就是，发请求，请求回来过后会有一个callback来处理返回结果。</p><p>有些时候下一个异步任务需要依赖于上一个异步任务的返回值。这样的依赖一多，就会形成callback hell了。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%227efa753d%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20makeCall(arg%2Ccallback)%7B%5Cn%20%20%20%20console.log(%60%24%7Barg%7D%20%E8%BF%9B%E8%A1%8C*2%E6%93%8D%E4%BD%9C%2C%E5%B9%B6%E5%9C%A81s%E5%90%8E%E9%80%9A%E7%9F%A5%E6%93%8D%E4%BD%9C%E5%AE%8C%E6%88%90%60)%5Cn%5CtsetTimeout(()%3D%3E%7Bcallback(arg*2)%7D%2C1000)%3B%5Cn%7D%5Cn%2F%2F%E7%BB%8F%E5%85%B8%E7%9A%84callback%E5%BD%A2%E5%BC%8F%5CnmakeCall(111%2C(arg)%3D%3E%7B%5Cn%5Ctconsole.log(arg)%5Cn%7D)%3B%5Cn%2F%2F%E7%BB%8F%E5%85%B8%E7%9A%84%E5%9B%9E%E6%8E%89%E5%9C%B0%E7%8B%B1%5CnmakeCall(111%2C(res)%3D%3E%7B%5Cn%5Ctconsole.log(res)%5Cn%5CtmakeCall(res%2C(res2)%3D%3E%7B%5Cn%20%20%20%20%5Ctconsole.log(res2)%3B%5Cn%5Ct%7D)%5Cn%7D)%3B%22%7D\"></card><p><br /></p><p><strong>利用thunk结合generator处理异步任务：</strong></p><p>原有的makeCall函数，callback是作为函数参数传入的，异步的请求和返回结果处理在一个函数，没有分开。在结合yield时候很不方便，或者说复杂。</p><p>所以这里需要对callback形式做一些改变，引入thunk，thunk函数介绍<a href=\"http://es6.ruanyifeng.com/#docs/generator-async#Thunk-%E5%87%BD%E6%95%B0\" target=\"_blank\">链接</a></p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%224a33abea%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20makeCall(arg%2Ccallback)%7B%5Cn%20%20%20%20console.log(%60%24%7Barg%7D%20%E8%BF%9B%E8%A1%8C*2%E6%93%8D%E4%BD%9C%2C%E5%B9%B6%E5%9C%A81s%E5%90%8E%E9%80%9A%E7%9F%A5%E6%93%8D%E4%BD%9C%E5%AE%8C%E6%88%90%60)%5Cn%5CtsetTimeout(()%3D%3E%7Bcallback(arg*2)%7D%2C1000)%3B%5Cn%7D%5Cn%2F%2F%E6%94%B9%E9%80%A0makeCall%E4%B8%BAthunk%E5%BD%A2%E5%BC%8F%5Cnfunction%20makeCallThunk%20(arg)%20%7B%5Cn%20%20%20%20return%20function%20(callback)%20%7B%5Cn%20%20%20%20%20%20%20%20return%20makeCall(arg%2C%20callback)%3B%5Cn%20%20%20%20%7D%3B%5Cn%7D%3B%5Cn%2F%2F%E8%B0%83%E7%94%A8%E5%BA%94%E8%AF%A5%E5%83%8F%E4%B8%8B%E9%9D%A2%E8%BF%99%E6%A0%B7%5CnmakeCallThunk(arg)(cb)%3B%22%7D\"></card><p><br /></p><p>函数thunk化后，如果需要发起请求，需要调用两次。</p><p>第一次调用返回的是函数</p><p>第二次调用才会真正发起请求</p><p>有了thunk函数，写一个针对异步操作的自动执行器就容易多了</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22b8f6e170%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2Fthunk%E7%89%88%E6%9C%AC%E7%9A%84%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8C%E5%99%A8%5Cnfunction%20run(fn)%20%7B%5Cn%20%20%20%20let%20it%20%3D%20fn()%3B%5Cn%20%20%20%20function%20next(data)%20%7B%5Cn%20%20%20%20%20%20%20%20var%20resObj%20%3D%20it.next(data)%3B%5Cn%20%20%20%20%20%20%20%20if%20(resObj.done)%20return%3B%5Cn%20%20%20%20%20%20%20%20resObj.value(next)%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20next()%3B%5Cn%7D%5Cn%2F%2F%E5%8F%AF%E4%BB%A5%E4%BB%94%E7%BB%86%E7%9C%8B%E4%B8%8B%E9%9D%A2%E8%BF%99%E4%B8%AA%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%92%8C%E6%89%A7%E8%A1%8C%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%97%B6%E5%80%99%E5%B9%B6%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%B7%AE%E5%88%AB%E3%80%82%5Cnfunction%20*makeCallGenerator()%7B%5Cn%20%20%20%20let%20res%20%3D%20yield%20makeCallThunk(2)%3B%5Cn%20%20%20%20let%20res2%20%3D%20yield%20makeCallThunk(res)%3B%5Cn%20%20%20%20let%20res3%20%3D%20yield%20makeCallThunk(res2)%3B%5Cn%20%20%20%20console.log(res3)%5Cn%7D%5Cnrun(makeCallGenerator)%22%7D\"></card><p><br /></p><p><strong>利用promise结合generator处理异步任务：</strong></p><p>promise都比较熟悉了，先给makeCall包装一层promise。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22f68dad00%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20makeCall(arg%2Ccallback)%7B%5Cn%20%20%20%20console.log(%60%24%7Barg%7D%20%E8%BF%9B%E8%A1%8C*2%E6%93%8D%E4%BD%9C%2C%E5%B9%B6%E5%9C%A81s%E5%90%8E%E9%80%9A%E7%9F%A5%E6%93%8D%E4%BD%9C%E5%AE%8C%E6%88%90%60)%5CnsetTimeout(()%3D%3E%7Bcallback(arg*2)%7D%2C1000)%3B%5Cn%7D%5Cn%2F%2FmakeCall%20%E5%8C%85%E8%A3%85%E4%B8%80%E5%B1%82promise%5Cnfunction%20makeCallPromise(arg)%7B%5Cn%5Ctreturn%20new%20Promise((resolve%2Creject)%3D%3E%7B%5Cn%5Ct%5CtmakeCall(arg%2C(res)%3D%3E%7B%5Cn%5Ct%5Ct%5Ctif(res%3E1000)%7Breject(res)%3B%7Delse%7Bresolve(res)%3B%7D%5Cn%5Ct%5Ct%7D)%3B%5Cn%5Ct%7D)%5Cn%7D%5Cn%2F%2Fpromise%E5%BD%A2%E5%BC%8F%E8%B0%83%E7%94%A8%E3%80%82%5CnmakeCallPromise(111)%5Cn%5Ct.then((res)%3D%3E%7Bconsole.log(res)%7D)%3B%5Cn%2F%2Fpromise%E8%AE%A9%E5%9B%9E%E8%B0%83%E5%87%8F%E5%B0%91%E4%BA%86%E4%B8%80%E4%BA%9B%E5%B1%82%E7%BA%A7%EF%BC%8C%E5%A5%BD%E7%9C%8B%E4%B8%80%E4%BA%9B%E4%BA%86%E3%80%82%5CnmakeCallPromise(111)%5Cn%5Ct.then((res)%3D%3EmakeCallPromise(222))%5Cn%5Ct.then((res)%3D%3Econsole.log(res))%3B%22%7D\"></card><p><br /></p><p>promise版本的执行器</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22b9c174c7%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function*%20makeCallGenerator()%7B%5Cnlet%20res%20%3D%20yield%20makeCallPromise(2)%3B%5Cn%20%20%20%20let%20res2%20%3D%20yield%20makeCallPromise(res)%3B%5Cn%20%20%20%20let%20res3%20%3D%20yield%20makeCallPromise(res2)%3B%5Cn%20%20%20%20console.log(res3)%5Cn%7D%5Cn%2F%2F%E6%89%A7%E8%A1%8C%E5%99%A8%5Cnfunction%20run(gen)%7B%5Cn%5Ctlet%20it%20%3D%20gen()%3B%5Cn%5Ctfunction%20next(data)%7B%5Cn%20%20%20%20%5Ctlet%20resObj%20%3D%20it.next(data)%3B%5Cn%20%20%20%20%20%20%20%20if(resObj.done)return%3B%5Cn%20%20%20%20%20%20%20%20resObj.value.then((res)%3D%3Enext(res))%3B%5Cn%5Ct%7D%5Cn%20%20%20%20next()%3B%5Cn%7D%5Cnrun(makeCallGenerator)%22%7D\"></card><p><br /></p><h3 id=\"23abcbd1\">两个问题</h3><p><br /></p><ol start=\"1\"><li><strong>使用generator执行异步操作的好处。</strong></li><li><strong>与async，await的差异。</strong></li></ol><p><br /></p><h4 id=\"04b6391b\">使用generator执行异步操作的好处。</h4><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22d14d0382%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%5Cnfunction*%20makeCallGenerator()%7B%5Cn%5Ctlet%20res%20%3D%20yield%20makeCallPromise(2)%3B%5Cn%20%20%20%20let%20res2%20%3D%20yield%20makeCallPromise(res)%3B%5Cn%20%20%20%20let%20res3%20%3D%20yield%20makeCallPromise(res2)%3B%5Cn%20%20%20%20console.log(res3)%5Cn%7D%5Cnrun(makeCallGenerator)%5Cnconsole.log(1)%3B%5Cn%2F%2F%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1%5Cnfunction%20*main()%7B%5Cn%20%20%20%20let%20a%20%3D%20yield%20makeCall(2)%3B%5Cn%20%20%20%20let%20b%20%3D%20yield%20makeCall(a)%3B%5Cn%20%20%20%20let%20c%20%3D%20yield%20makeCall(b)%3B%5Cn%5Ctconsole.log(c)%3B%5Cn%7D%5Cnrun(main)%3B%5Cnconsole.log(1)%3B%22%7D\"></card><p><br /></p><p>抛开generator的执行器不看，异步任务和同步任务的写法几乎一模一样。</p><p><br /></p><h4 id=\"923a5f2b\">与async，await的差异。</h4><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22id%22%3A%22d8e4ec0d%22%2C%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2Fgenerator%5Cnfunction*%20makeCallGenerator()%7B%5Cn%5Ctlet%20res%20%3D%20yield%20makeCallPromise(2)%3B%5Cn%20%20%20%20let%20res2%20%3D%20yield%20makeCallPromise(res)%3B%5Cn%20%20%20%20let%20res3%20%3D%20yield%20makeCallPromise(res2)%3B%5Cn%20%20%20%20console.log(res3)%5Cn%7D%5Cnrun(makeCallGenerator)%5Cn%2F%2Fasync%20await%5Cnasync%20function%20makeCallCopy()%7B%5Cn%20%20%20%20let%20res%20%3D%20await%20makeCallPromise(2)%3B%5Cn%20%20%20%20let%20res2%20%3D%20await%20makeCallPromise(res)%3B%5Cn%20%20%20%20let%20res3%20%3D%20await%20makeCallPromise(res2)%3B%5Cn%20%20%20%20console.log(res3)%5Cn%7D%5CnmakeCallCopy()%3B%22%7D\"></card><p><br /></p><p>写法几乎一模一样，只不过 * 号变成了 async，yield 变成了 await。</p><p>但async/await执行器是自带的，generator执行器需要自己去手写，但也意味着更多可能。</p><p>另外 async/await 默认是 使用的 generator + promise的形式执行异步任务，是这个模式之上的语法糖，能很好的解决异步任务。</p><p>但generator除了结合promise 和可以结合类似thunk之类的去执行异步任务。</p><h1 id=\"end\"><br /></h1>",
  "body_draft_lake": "",
  "public": 1,
  "status": 0,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 1,
  "content_updated_at": "2020-12-25T07:50:32.000Z",
  "deleted_at": null,
  "created_at": "2019-07-03T01:38:05.000Z",
  "updated_at": "2023-02-02T09:07:58.000Z",
  "published_at": "2019-07-10T01:50:53.000Z",
  "first_published_at": "2019-07-08T07:42:38.000Z",
  "word_count": 1699,
  "cover": null,
  "description": "Generator基本的语法function* a(){ \tconsole.log('hello generator'); } var a1 = a();//这里不会执行函数内部任何代码，只会返回一个迭代器 a1.next();//这里会打印hello generator，返回值为{value...",
  "custom_description": null,
  "hits": 63,
  "_serializer": "v2.doc_detail"
}