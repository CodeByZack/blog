{
  "id": 97690330,
  "slug": "ru1ema",
  "title": "使用 Esbuild 在浏览器内编译 React",
  "book_id": 231593,
  "book": {
    "id": 231593,
    "type": "Book",
    "slug": "web",
    "name": "WEB",
    "user_id": 284138,
    "description": "前端知识点记录",
    "creator_id": 284138,
    "public": 1,
    "items_count": 58,
    "likes_count": 0,
    "watches_count": 3,
    "content_updated_at": "2023-02-02T09:09:21.426Z",
    "updated_at": "2023-02-02T09:09:21.000Z",
    "created_at": "2019-03-07T05:05:08.000Z",
    "namespace": "zackdk/web",
    "user": {
      "id": 284138,
      "type": "User",
      "login": "zackdk",
      "name": "行一度空山",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1551934932702-d412771d-8d33-4694-9186-a749a3b4e05b.jpeg",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 5,
      "following_count": 0,
      "created_at": "2019-03-07T05:02:38.000Z",
      "updated_at": "2023-02-01T12:18:25.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 284138,
  "creator": {
    "id": 284138,
    "type": "User",
    "login": "zackdk",
    "name": "行一度空山",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1551934932702-d412771d-8d33-4694-9186-a749a3b4e05b.jpeg",
    "books_count": 2,
    "public_books_count": 1,
    "followers_count": 5,
    "following_count": 0,
    "created_at": "2019-03-07T05:02:38.000Z",
    "updated_at": "2023-02-01T12:18:25.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "---\n\n<a name=\"32429250\"></a>\n## 为什么要在浏览器内编译 React ?\n\n博客编写时需要实时预览，使用的 MDX 需要经过编译，预览则采用了 iframe 进行预览，所以我需要把 MDX 编译成 JavaScript ，放到 iframe 里。\n\n<a name=\"89269a88\"></a>\n## esbuild 怎么跑在浏览器内的 ?\n\nesbuild 提供了 wasm 版本，是支持在浏览器内运行的，具体可以参考[官网](https://esbuild.github.io/api/#running-in-the-browser)。\n\n<a name=\"bac5e51d\"></a>\n## esbuild 在浏览器内运行，有啥问题么 ?\n\n有的，浏览器内没有文件系统，所以你会看到如下的错误：\n\n```javascript\nUncaught (in promise) Error: Build failed with 3 errors:\nerror: Cannot read directory \".\": not implemented on js\nerror: Cannot read directory \".\": not implemented on js\nerror: Could not resolve \"index.jsx\"\n```\n\n但可以通过 esbuild 提供的插件机制来解决。\n\n<a name=\"5eb14931\"></a>\n## 亲手尝试一下在浏览器内使用 esbuild 编译\n\n1. 引入 esbuild\n\n```html\n<script src=\"https://www.unpkg.com/esbuild-wasm/lib/browser.min.js\"></script>\n<script>\n    esbuild\n    .initialize({\n        wasmURL: 'https://www.unpkg.com/esbuild-wasm/esbuild.wasm',\n    })\n    .then(() => {\n        build();\n    });\n\n    const build = () => {\n        console.log(esbuild);\n    };\n</script>\n```\n\n2. 使用 esbuild\n\n```javascript\n\nesbuild.build({\n    entryPoints: ['index.jsx'],\n    bundle: true,\n    write: false,\n});\n```\n\n不出意外，你就能看到上面那个错误了，因为在浏览器里， esbuild 并不知道去那里读取 `index.jsx` 这个文件。\n\n3. 使用插件解决在浏览器内读取文件的问题\n\nesbuild 插件格式如下：\n\n```javascript\nconst myPlugin = {\n    name: 'myPlugin',\n    setup: (build) => {\n        build.onResolve({ filter: /.*/ }, (args) => {});\n        build.onLoad({ filter: /.*/ }, (args) => {});\n    },\n};\n```\n\n`onResolve` 是用来解析引入模块的地址的，要求模块的具体地址， `onLoad` 则是根据 `onResolve` 返回的 path 去拿到实际的文件内容。\n\n这个机制正好能解决我们的问题。\n\n```javascript\nconst files = {\n    '/index.jsx': indexJSX,\n    '/App.jsx': appJSX,\n};\nconst myPlugin = {\n    name: 'myPlugin',\n    setup: (build) => {\n        build.onResolve({ filter: /.*/ }, (args) => {\n            // 入口文件单独处理\n            if (args.kind === 'entry-point') {\n                return { path: '/' + args.path };\n            }\n            // 这里只是简单处理一下\n            if (args.path === './App.jsx') {\n                return { path: '/App.jsx' };\n            }\n        });\n        build.onLoad({ filter: /.*/ }, (args) => {\n            if (args.path === '/index.jsx') {\n                return {\n                contents: files['/index.jsx'],\n                loader: 'jsx',\n                };\n            }\n            if (args.path === '/App.jsx') {\n                return {\n                contents: files['/App.jsx'],\n                loader: 'jsx',\n                };\n            }\n            return null;\n        });\n    },\n};\nesbuild.build({\n    entryPoints: ['index.jsx'],\n    bundle: true,\n    write: false,\n    plugins: [myPlugin],\n\n});\n```\n\n如上的插件能解决我们自己的文件引入问题，但控制台还有个错误\n\n```javascript\nUncaught (in promise) Error: Build failed with 2 errors:\nerror: Cannot read directory \".\": not implemented on js\nindex.jsx:1:18: ERROR: Could not resolve \"react\"\n```\n\n针对第三方包，我们并没有处理。我们当然可以继续沿着上面的逻辑处理，去引入 cdn 上的 React 文件，因为 `onLoad` 可以是异步的。<br />这里我们换一种方式，使用 script 标签引入 React 和 ReactDOM ， esbuild 直接使用 window 上的变量。所以继续对插件进行改造。\n\n```javascript\nconst files = {\n    '/index.jsx': indexJSX,\n    '/App.jsx': appJSX,\n};\n\nconst externals = {\n    react: 'React',\n    'react-dom/client': 'ReactDOM',\n};\n\nconst myPlugin = {\n    name: 'myPlugin',\n    setup: (build) => {\n        build.onResolve({ filter: /.*/ }, (args) => {\n            // 入口文件单独处理\n            if (args.kind === 'entry-point') {\n                return { path: '/' + args.path };\n            }\n            // 这里只是简单处理一下\n            if (args.path === './App.jsx') {\n                return { path: '/App.jsx' };\n            }\n            if (Object.keys(externals).includes(args.path)) {\n                return { path: `/externals/${args.path}` };\n            }\n        });\n        build.onLoad({ filter: /.*/ }, (args) => {\n            if (args.path === '/index.jsx') {\n                return {\n                contents: files['/index.jsx'],\n                loader: 'jsx',\n                };\n            }\n            if (args.path === '/App.jsx') {\n                return {\n                contents: files['/App.jsx'],\n                loader: 'jsx',\n                };\n            }\n            if (args.path.startsWith('/externals/')) {\n                const libName = args.path.replace('/externals/', '');\n                const contents = `module.exports = ${externals[libName]}`;\n                return { contents };\n            }\n            return null;\n        });\n    },\n};\n\nconst res = await esbuild.build({\n    entryPoints: ['index.jsx'],\n    bundle: true,\n    write: false,\n    plugins: [myPlugin],\n});\n\nconsole.log(res);\n```\n\n好了能正常编译出来了。但输出的是 `Uint8Array` 。需要 decode 一下。\n\n```javascript\nconst contents = res.outputFiles[0].contents;\nconst decoder = new TextDecoder();\nconst text = decoder.decode(contents);\n```\n\n<a name=\"72d84f85\"></a>\n## 以上最终代码的集合\n\n\n\n/\n",
  "body_draft": "",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><hr id=\"wx8es\" class=\"ne-hr\"><h2 id=\"32429250\"><span class=\"ne-text\">为什么要在浏览器内编译 React ?</span></h2><p id=\"u07a8bf3a\" class=\"ne-p\"><br></p><p id=\"uadb6bced\" class=\"ne-p\"><span class=\"ne-text\">博客编写时需要实时预览，使用的 MDX 需要经过编译，预览则采用了 iframe 进行预览，所以我需要把 MDX 编译成 JavaScript ，放到 iframe 里。</span></p><p id=\"u12c94844\" class=\"ne-p\"><br></p><h2 id=\"89269a88\"><span class=\"ne-text\">esbuild 怎么跑在浏览器内的 ?</span></h2><p id=\"u82bf60f2\" class=\"ne-p\"><br></p><p id=\"u2f77ab4c\" class=\"ne-p\"><span class=\"ne-text\">esbuild 提供了 wasm 版本，是支持在浏览器内运行的，具体可以参考</span><a href=\"https://esbuild.github.io/api/#running-in-the-browser\" data-href=\"https://esbuild.github.io/api/#running-in-the-browser\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">官网</span></a><span class=\"ne-text\">。</span></p><p id=\"uae09a87a\" class=\"ne-p\"><br></p><h2 id=\"bac5e51d\"><span class=\"ne-text\">esbuild 在浏览器内运行，有啥问题么 ?</span></h2><p id=\"u75e6b619\" class=\"ne-p\"><br></p><p id=\"u3be2371c\" class=\"ne-p\"><span class=\"ne-text\">有的，浏览器内没有文件系统，所以你会看到如下的错误：</span></p><p id=\"ua21ca630\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"1522c139\" class=\"ne-codeblock language-javascript\">Uncaught (in promise) Error: Build failed with 3 errors:\nerror: Cannot read directory &quot;.&quot;: not implemented on js\nerror: Cannot read directory &quot;.&quot;: not implemented on js\nerror: Could not resolve &quot;index.jsx&quot;</pre><p id=\"u03b19d9e\" class=\"ne-p\"><br></p><p id=\"u1308f566\" class=\"ne-p\"><span class=\"ne-text\">但可以通过 esbuild 提供的插件机制来解决。</span></p><p id=\"u6769d376\" class=\"ne-p\"><br></p><h2 id=\"5eb14931\"><span class=\"ne-text\">亲手尝试一下在浏览器内使用 esbuild 编译</span></h2><p id=\"u8633737a\" class=\"ne-p\"><br></p><ol class=\"ne-ol\"><li id=\"u0e261132\"><span class=\"ne-text\">引入 esbuild</span></li></ol><p id=\"u36a9bf3c\" class=\"ne-p\"><br></p><pre data-language=\"html\" id=\"3a4d43bd\" class=\"ne-codeblock language-html\">&lt;script src=&quot;https://www.unpkg.com/esbuild-wasm/lib/browser.min.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n    esbuild\n    .initialize({\n        wasmURL: 'https://www.unpkg.com/esbuild-wasm/esbuild.wasm',\n    })\n    .then(() =&gt; {\n        build();\n    });\n\n    const build = () =&gt; {\n        console.log(esbuild);\n    };\n&lt;/script&gt;</pre><p id=\"ua75deb1e\" class=\"ne-p\"><br></p><ol start=\"2\" class=\"ne-ol\"><li id=\"uf501d6f9\"><span class=\"ne-text\">使用 esbuild</span></li></ol><p id=\"u1958b5f1\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"ca9361c4\" class=\"ne-codeblock language-javascript\">\nesbuild.build({\n    entryPoints: ['index.jsx'],\n    bundle: true,\n    write: false,\n});</pre><p id=\"uf632e0d2\" class=\"ne-p\"><br></p><p id=\"u5aa10c7d\" class=\"ne-p\"><span class=\"ne-text\">不出意外，你就能看到上面那个错误了，因为在浏览器里， esbuild 并不知道去那里读取 </span><code class=\"ne-code\"><span class=\"ne-text\">index.jsx</span></code><span class=\"ne-text\"> 这个文件。</span></p><p id=\"u717472e1\" class=\"ne-p\"><br></p><ol start=\"3\" class=\"ne-ol\"><li id=\"ud26c36f3\"><span class=\"ne-text\">使用插件解决在浏览器内读取文件的问题</span></li></ol><p id=\"ub9902f0f\" class=\"ne-p\"><br></p><p id=\"u98979996\" class=\"ne-p\"><span class=\"ne-text\">esbuild 插件格式如下：</span></p><p id=\"u132fde04\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"ddb767b8\" class=\"ne-codeblock language-javascript\">const myPlugin = {\n    name: 'myPlugin',\n    setup: (build) =&gt; {\n        build.onResolve({ filter: /.*/ }, (args) =&gt; {});\n        build.onLoad({ filter: /.*/ }, (args) =&gt; {});\n    },\n};</pre><p id=\"u4ad93555\" class=\"ne-p\"><br></p><p id=\"ubcafdac7\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">onResolve</span></code><span class=\"ne-text\"> 是用来解析引入模块的地址的，要求模块的具体地址， </span><code class=\"ne-code\"><span class=\"ne-text\">onLoad</span></code><span class=\"ne-text\"> 则是根据 </span><code class=\"ne-code\"><span class=\"ne-text\">onResolve</span></code><span class=\"ne-text\"> 返回的 path 去拿到实际的文件内容。</span></p><p id=\"u25c80046\" class=\"ne-p\"><br></p><p id=\"uee743221\" class=\"ne-p\"><span class=\"ne-text\">这个机制正好能解决我们的问题。</span></p><p id=\"u70a9fcba\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"4b7ded62\" class=\"ne-codeblock language-javascript\">const files = {\n    '/index.jsx': indexJSX,\n    '/App.jsx': appJSX,\n};\nconst myPlugin = {\n    name: 'myPlugin',\n    setup: (build) =&gt; {\n        build.onResolve({ filter: /.*/ }, (args) =&gt; {\n            // 入口文件单独处理\n            if (args.kind === 'entry-point') {\n                return { path: '/' + args.path };\n            }\n            // 这里只是简单处理一下\n            if (args.path === './App.jsx') {\n                return { path: '/App.jsx' };\n            }\n        });\n        build.onLoad({ filter: /.*/ }, (args) =&gt; {\n            if (args.path === '/index.jsx') {\n                return {\n                contents: files['/index.jsx'],\n                loader: 'jsx',\n                };\n            }\n            if (args.path === '/App.jsx') {\n                return {\n                contents: files['/App.jsx'],\n                loader: 'jsx',\n                };\n            }\n            return null;\n        });\n    },\n};\nesbuild.build({\n    entryPoints: ['index.jsx'],\n    bundle: true,\n    write: false,\n    plugins: [myPlugin],\n\n});</pre><p id=\"u042ebcc8\" class=\"ne-p\"><br></p><p id=\"ub2560a05\" class=\"ne-p\"><span class=\"ne-text\">如上的插件能解决我们自己的文件引入问题，但控制台还有个错误</span></p><p id=\"u29ad5094\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"5dca8641\" class=\"ne-codeblock language-javascript\">Uncaught (in promise) Error: Build failed with 2 errors:\nerror: Cannot read directory &quot;.&quot;: not implemented on js\nindex.jsx:1:18: ERROR: Could not resolve &quot;react&quot;</pre><p id=\"u8c8a0cab\" class=\"ne-p\"><br></p><p id=\"u79f35b08\" class=\"ne-p\"><span class=\"ne-text\">针对第三方包，我们并没有处理。我们当然可以继续沿着上面的逻辑处理，去引入 cdn 上的 React 文件，因为 </span><code class=\"ne-code\"><span class=\"ne-text\">onLoad</span></code><span class=\"ne-text\"> 可以是异步的。<br /></span><span class=\"ne-text\">这里我们换一种方式，使用 script 标签引入 React 和 ReactDOM ， esbuild 直接使用 window 上的变量。所以继续对插件进行改造。</span></p><p id=\"u7d4b0971\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"f1fc0020\" class=\"ne-codeblock language-javascript\">const files = {\n    '/index.jsx': indexJSX,\n    '/App.jsx': appJSX,\n};\n\nconst externals = {\n    react: 'React',\n    'react-dom/client': 'ReactDOM',\n};\n\nconst myPlugin = {\n    name: 'myPlugin',\n    setup: (build) =&gt; {\n        build.onResolve({ filter: /.*/ }, (args) =&gt; {\n            // 入口文件单独处理\n            if (args.kind === 'entry-point') {\n                return { path: '/' + args.path };\n            }\n            // 这里只是简单处理一下\n            if (args.path === './App.jsx') {\n                return { path: '/App.jsx' };\n            }\n            if (Object.keys(externals).includes(args.path)) {\n                return { path: `/externals/${args.path}` };\n            }\n        });\n        build.onLoad({ filter: /.*/ }, (args) =&gt; {\n            if (args.path === '/index.jsx') {\n                return {\n                contents: files['/index.jsx'],\n                loader: 'jsx',\n                };\n            }\n            if (args.path === '/App.jsx') {\n                return {\n                contents: files['/App.jsx'],\n                loader: 'jsx',\n                };\n            }\n            if (args.path.startsWith('/externals/')) {\n                const libName = args.path.replace('/externals/', '');\n                const contents = `module.exports = ${externals[libName]}`;\n                return { contents };\n            }\n            return null;\n        });\n    },\n};\n\nconst res = await esbuild.build({\n    entryPoints: ['index.jsx'],\n    bundle: true,\n    write: false,\n    plugins: [myPlugin],\n});\n\nconsole.log(res);</pre><p id=\"u91ca2a06\" class=\"ne-p\"><br></p><p id=\"u79b03f21\" class=\"ne-p\"><span class=\"ne-text\">好了能正常编译出来了。但输出的是 </span><code class=\"ne-code\"><span class=\"ne-text\">Uint8Array</span></code><span class=\"ne-text\"> 。需要 decode 一下。</span></p><p id=\"uf3c29c17\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"91020cb8\" class=\"ne-codeblock language-javascript\">const contents = res.outputFiles[0].contents;\nconst decoder = new TextDecoder();\nconst text = decoder.decode(contents);</pre><p id=\"u7a9b54fe\" class=\"ne-p\"><br></p><h2 id=\"72d84f85\"><span class=\"ne-text\">以上最终代码的集合</span></h2><p id=\"ue04d860a\" class=\"ne-p\"><br></p><p id=\"u1f9d4878\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: #d4d4d4; background-color: #1e1e1e; font-size: 12px\"><br /></span></p><p id=\"ue2c5b660\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 12px\">/</span></p></div>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"fixed\" /><meta name=\"paragraphSpacing\" content=\"relax\" /><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22wx8es%22%7D\"></card><h2 data-lake-id=\"32429250\" id=\"32429250\"><span data-lake-id=\"uaf13b483\" id=\"uaf13b483\">为什么要在浏览器内编译 React ?</span></h2><p data-lake-id=\"u07a8bf3a\" id=\"u07a8bf3a\"><br></p><p data-lake-id=\"uadb6bced\" id=\"uadb6bced\"><span data-lake-id=\"ub750c7eb\" id=\"ub750c7eb\">博客编写时需要实时预览，使用的 MDX 需要经过编译，预览则采用了 iframe 进行预览，所以我需要把 MDX 编译成 JavaScript ，放到 iframe 里。</span></p><p data-lake-id=\"u12c94844\" id=\"u12c94844\"><br></p><h2 data-lake-id=\"89269a88\" id=\"89269a88\"><span data-lake-id=\"ua394809e\" id=\"ua394809e\">esbuild 怎么跑在浏览器内的 ?</span></h2><p data-lake-id=\"u82bf60f2\" id=\"u82bf60f2\"><br></p><p data-lake-id=\"u2f77ab4c\" id=\"u2f77ab4c\"><span data-lake-id=\"u4cd4d862\" id=\"u4cd4d862\">esbuild 提供了 wasm 版本，是支持在浏览器内运行的，具体可以参考</span><a href=\"https://esbuild.github.io/api/#running-in-the-browser\" target=\"_blank\" data-lake-id=\"u666b3031\" id=\"u666b3031\"><span data-lake-id=\"u2b860bfb\" id=\"u2b860bfb\">官网</span></a><span data-lake-id=\"ud0b3a7ad\" id=\"ud0b3a7ad\">。</span></p><p data-lake-id=\"uae09a87a\" id=\"uae09a87a\"><br></p><h2 data-lake-id=\"bac5e51d\" id=\"bac5e51d\"><span data-lake-id=\"u3bda4353\" id=\"u3bda4353\">esbuild 在浏览器内运行，有啥问题么 ?</span></h2><p data-lake-id=\"u75e6b619\" id=\"u75e6b619\"><br></p><p data-lake-id=\"u3be2371c\" id=\"u3be2371c\"><span data-lake-id=\"u6c2d120b\" id=\"u6c2d120b\">有的，浏览器内没有文件系统，所以你会看到如下的错误：</span></p><p data-lake-id=\"ua21ca630\" id=\"ua21ca630\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22Uncaught%20(in%20promise)%20Error%3A%20Build%20failed%20with%203%20errors%3A%5Cnerror%3A%20Cannot%20read%20directory%20%5C%22.%5C%22%3A%20not%20implemented%20on%20js%5Cnerror%3A%20Cannot%20read%20directory%20%5C%22.%5C%22%3A%20not%20implemented%20on%20js%5Cnerror%3A%20Could%20not%20resolve%20%5C%22index.jsx%5C%22%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%221522c139%22%7D\"></card><p data-lake-id=\"u03b19d9e\" id=\"u03b19d9e\"><br></p><p data-lake-id=\"u1308f566\" id=\"u1308f566\"><span data-lake-id=\"u200e9553\" id=\"u200e9553\">但可以通过 esbuild 提供的插件机制来解决。</span></p><p data-lake-id=\"u6769d376\" id=\"u6769d376\"><br></p><h2 data-lake-id=\"5eb14931\" id=\"5eb14931\"><span data-lake-id=\"u72b18c2f\" id=\"u72b18c2f\">亲手尝试一下在浏览器内使用 esbuild 编译</span></h2><p data-lake-id=\"u8633737a\" id=\"u8633737a\"><br></p><ol list=\"udb74745e\"><li fid=\"ua37e9d53\" data-lake-id=\"u0e261132\" id=\"u0e261132\"><span data-lake-id=\"ufc936afb\" id=\"ufc936afb\">引入 esbuild</span></li></ol><p data-lake-id=\"u36a9bf3c\" id=\"u36a9bf3c\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22html%22%2C%22code%22%3A%22%3Cscript%20src%3D%5C%22https%3A%2F%2Fwww.unpkg.com%2Fesbuild-wasm%2Flib%2Fbrowser.min.js%5C%22%3E%3C%2Fscript%3E%5Cn%3Cscript%3E%5Cn%20%20%20%20esbuild%5Cn%20%20%20%20.initialize(%7B%5Cn%20%20%20%20%20%20%20%20wasmURL%3A%20'https%3A%2F%2Fwww.unpkg.com%2Fesbuild-wasm%2Fesbuild.wasm'%2C%5Cn%20%20%20%20%7D)%5Cn%20%20%20%20.then(()%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20build()%3B%5Cn%20%20%20%20%7D)%3B%5Cn%5Cn%20%20%20%20const%20build%20%3D%20()%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20console.log(esbuild)%3B%5Cn%20%20%20%20%7D%3B%5Cn%3C%2Fscript%3E%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%223a4d43bd%22%7D\"></card><p data-lake-id=\"ua75deb1e\" id=\"ua75deb1e\"><br></p><ol list=\"u66da146e\" start=\"2\"><li fid=\"u154d1f1e\" data-lake-id=\"uf501d6f9\" id=\"uf501d6f9\"><span data-lake-id=\"u65e6df8b\" id=\"u65e6df8b\">使用 esbuild</span></li></ol><p data-lake-id=\"u1958b5f1\" id=\"u1958b5f1\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%5Cnesbuild.build(%7B%5Cn%20%20%20%20entryPoints%3A%20%5B'index.jsx'%5D%2C%5Cn%20%20%20%20bundle%3A%20true%2C%5Cn%20%20%20%20write%3A%20false%2C%5Cn%7D)%3B%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22ca9361c4%22%7D\"></card><p data-lake-id=\"uf632e0d2\" id=\"uf632e0d2\"><br></p><p data-lake-id=\"u5aa10c7d\" id=\"u5aa10c7d\"><span data-lake-id=\"ue13f5577\" id=\"ue13f5577\">不出意外，你就能看到上面那个错误了，因为在浏览器里， esbuild 并不知道去那里读取 </span><code data-lake-id=\"uc920c94c\" id=\"uc920c94c\"><span data-lake-id=\"u706d2279\" id=\"u706d2279\">index.jsx</span></code><span data-lake-id=\"u983d3cc2\" id=\"u983d3cc2\"> 这个文件。</span></p><p data-lake-id=\"u717472e1\" id=\"u717472e1\"><br></p><ol list=\"u372badfe\" start=\"3\"><li fid=\"u49289823\" data-lake-id=\"ud26c36f3\" id=\"ud26c36f3\"><span data-lake-id=\"u9e0b44e2\" id=\"u9e0b44e2\">使用插件解决在浏览器内读取文件的问题</span></li></ol><p data-lake-id=\"ub9902f0f\" id=\"ub9902f0f\"><br></p><p data-lake-id=\"u98979996\" id=\"u98979996\"><span data-lake-id=\"u4c4bccb9\" id=\"u4c4bccb9\">esbuild 插件格式如下：</span></p><p data-lake-id=\"u132fde04\" id=\"u132fde04\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20myPlugin%20%3D%20%7B%5Cn%20%20%20%20name%3A%20'myPlugin'%2C%5Cn%20%20%20%20setup%3A%20(build)%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20build.onResolve(%7B%20filter%3A%20%2F.*%2F%20%7D%2C%20(args)%20%3D%3E%20%7B%7D)%3B%5Cn%20%20%20%20%20%20%20%20build.onLoad(%7B%20filter%3A%20%2F.*%2F%20%7D%2C%20(args)%20%3D%3E%20%7B%7D)%3B%5Cn%20%20%20%20%7D%2C%5Cn%7D%3B%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22ddb767b8%22%7D\"></card><p data-lake-id=\"u4ad93555\" id=\"u4ad93555\"><br></p><p data-lake-id=\"ubcafdac7\" id=\"ubcafdac7\"><code data-lake-id=\"u654ccdb3\" id=\"u654ccdb3\"><span data-lake-id=\"u3cbf691f\" id=\"u3cbf691f\">onResolve</span></code><span data-lake-id=\"u6d25ea69\" id=\"u6d25ea69\"> 是用来解析引入模块的地址的，要求模块的具体地址， </span><code data-lake-id=\"u6905306b\" id=\"u6905306b\"><span data-lake-id=\"ud41dbc50\" id=\"ud41dbc50\">onLoad</span></code><span data-lake-id=\"u4f022ee4\" id=\"u4f022ee4\"> 则是根据 </span><code data-lake-id=\"u3c32014e\" id=\"u3c32014e\"><span data-lake-id=\"u3b2a8efe\" id=\"u3b2a8efe\">onResolve</span></code><span data-lake-id=\"ueb580f41\" id=\"ueb580f41\"> 返回的 path 去拿到实际的文件内容。</span></p><p data-lake-id=\"u25c80046\" id=\"u25c80046\"><br></p><p data-lake-id=\"uee743221\" id=\"uee743221\"><span data-lake-id=\"u80a85198\" id=\"u80a85198\">这个机制正好能解决我们的问题。</span></p><p data-lake-id=\"u70a9fcba\" id=\"u70a9fcba\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20files%20%3D%20%7B%5Cn%20%20%20%20'%2Findex.jsx'%3A%20indexJSX%2C%5Cn%20%20%20%20'%2FApp.jsx'%3A%20appJSX%2C%5Cn%7D%3B%5Cnconst%20myPlugin%20%3D%20%7B%5Cn%20%20%20%20name%3A%20'myPlugin'%2C%5Cn%20%20%20%20setup%3A%20(build)%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20build.onResolve(%7B%20filter%3A%20%2F.*%2F%20%7D%2C%20(args)%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6%E5%8D%95%E7%8B%AC%E5%A4%84%E7%90%86%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(args.kind%20%3D%3D%3D%20'entry-point')%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20%7B%20path%3A%20'%2F'%20%2B%20args.path%20%7D%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E8%BF%99%E9%87%8C%E5%8F%AA%E6%98%AF%E7%AE%80%E5%8D%95%E5%A4%84%E7%90%86%E4%B8%80%E4%B8%8B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(args.path%20%3D%3D%3D%20'.%2FApp.jsx')%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20%7B%20path%3A%20'%2FApp.jsx'%20%7D%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%7D)%3B%5Cn%20%20%20%20%20%20%20%20build.onLoad(%7B%20filter%3A%20%2F.*%2F%20%7D%2C%20(args)%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(args.path%20%3D%3D%3D%20'%2Findex.jsx')%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20contents%3A%20files%5B'%2Findex.jsx'%5D%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20loader%3A%20'jsx'%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(args.path%20%3D%3D%3D%20'%2FApp.jsx')%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20contents%3A%20files%5B'%2FApp.jsx'%5D%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20loader%3A%20'jsx'%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20return%20null%3B%5Cn%20%20%20%20%20%20%20%20%7D)%3B%5Cn%20%20%20%20%7D%2C%5Cn%7D%3B%5Cnesbuild.build(%7B%5Cn%20%20%20%20entryPoints%3A%20%5B'index.jsx'%5D%2C%5Cn%20%20%20%20bundle%3A%20true%2C%5Cn%20%20%20%20write%3A%20false%2C%5Cn%20%20%20%20plugins%3A%20%5BmyPlugin%5D%2C%5Cn%5Cn%7D)%3B%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%224b7ded62%22%7D\"></card><p data-lake-id=\"u042ebcc8\" id=\"u042ebcc8\"><br></p><p data-lake-id=\"ub2560a05\" id=\"ub2560a05\"><span data-lake-id=\"ud21b19f2\" id=\"ud21b19f2\">如上的插件能解决我们自己的文件引入问题，但控制台还有个错误</span></p><p data-lake-id=\"u29ad5094\" id=\"u29ad5094\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22Uncaught%20(in%20promise)%20Error%3A%20Build%20failed%20with%202%20errors%3A%5Cnerror%3A%20Cannot%20read%20directory%20%5C%22.%5C%22%3A%20not%20implemented%20on%20js%5Cnindex.jsx%3A1%3A18%3A%20ERROR%3A%20Could%20not%20resolve%20%5C%22react%5C%22%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%225dca8641%22%7D\"></card><p data-lake-id=\"u8c8a0cab\" id=\"u8c8a0cab\"><br></p><p data-lake-id=\"u79f35b08\" id=\"u79f35b08\"><span data-lake-id=\"ud70d96b5\" id=\"ud70d96b5\">针对第三方包，我们并没有处理。我们当然可以继续沿着上面的逻辑处理，去引入 cdn 上的 React 文件，因为 </span><code data-lake-id=\"u6d74061a\" id=\"u6d74061a\"><span data-lake-id=\"u1a2fa5d1\" id=\"u1a2fa5d1\">onLoad</span></code><span data-lake-id=\"u5fe24923\" id=\"u5fe24923\"> 可以是异步的。<br /></span><span data-lake-id=\"u6a1433bd\" id=\"u6a1433bd\">这里我们换一种方式，使用 script 标签引入 React 和 ReactDOM ， esbuild 直接使用 window 上的变量。所以继续对插件进行改造。</span></p><p data-lake-id=\"u7d4b0971\" id=\"u7d4b0971\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20files%20%3D%20%7B%5Cn%20%20%20%20'%2Findex.jsx'%3A%20indexJSX%2C%5Cn%20%20%20%20'%2FApp.jsx'%3A%20appJSX%2C%5Cn%7D%3B%5Cn%5Cnconst%20externals%20%3D%20%7B%5Cn%20%20%20%20react%3A%20'React'%2C%5Cn%20%20%20%20'react-dom%2Fclient'%3A%20'ReactDOM'%2C%5Cn%7D%3B%5Cn%5Cnconst%20myPlugin%20%3D%20%7B%5Cn%20%20%20%20name%3A%20'myPlugin'%2C%5Cn%20%20%20%20setup%3A%20(build)%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20build.onResolve(%7B%20filter%3A%20%2F.*%2F%20%7D%2C%20(args)%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6%E5%8D%95%E7%8B%AC%E5%A4%84%E7%90%86%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(args.kind%20%3D%3D%3D%20'entry-point')%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20%7B%20path%3A%20'%2F'%20%2B%20args.path%20%7D%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E8%BF%99%E9%87%8C%E5%8F%AA%E6%98%AF%E7%AE%80%E5%8D%95%E5%A4%84%E7%90%86%E4%B8%80%E4%B8%8B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(args.path%20%3D%3D%3D%20'.%2FApp.jsx')%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20%7B%20path%3A%20'%2FApp.jsx'%20%7D%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(Object.keys(externals).includes(args.path))%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20%7B%20path%3A%20%60%2Fexternals%2F%24%7Bargs.path%7D%60%20%7D%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%7D)%3B%5Cn%20%20%20%20%20%20%20%20build.onLoad(%7B%20filter%3A%20%2F.*%2F%20%7D%2C%20(args)%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(args.path%20%3D%3D%3D%20'%2Findex.jsx')%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20contents%3A%20files%5B'%2Findex.jsx'%5D%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20loader%3A%20'jsx'%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(args.path%20%3D%3D%3D%20'%2FApp.jsx')%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20contents%3A%20files%5B'%2FApp.jsx'%5D%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20loader%3A%20'jsx'%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if%20(args.path.startsWith('%2Fexternals%2F'))%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20const%20libName%20%3D%20args.path.replace('%2Fexternals%2F'%2C%20'')%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20const%20contents%20%3D%20%60module.exports%20%3D%20%24%7Bexternals%5BlibName%5D%7D%60%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20%7B%20contents%20%7D%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20return%20null%3B%5Cn%20%20%20%20%20%20%20%20%7D)%3B%5Cn%20%20%20%20%7D%2C%5Cn%7D%3B%5Cn%5Cnconst%20res%20%3D%20await%20esbuild.build(%7B%5Cn%20%20%20%20entryPoints%3A%20%5B'index.jsx'%5D%2C%5Cn%20%20%20%20bundle%3A%20true%2C%5Cn%20%20%20%20write%3A%20false%2C%5Cn%20%20%20%20plugins%3A%20%5BmyPlugin%5D%2C%5Cn%7D)%3B%5Cn%5Cnconsole.log(res)%3B%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22f1fc0020%22%7D\"></card><p data-lake-id=\"u91ca2a06\" id=\"u91ca2a06\"><br></p><p data-lake-id=\"u79b03f21\" id=\"u79b03f21\"><span data-lake-id=\"u2503ea5d\" id=\"u2503ea5d\">好了能正常编译出来了。但输出的是 </span><code data-lake-id=\"u418d0bd7\" id=\"u418d0bd7\"><span data-lake-id=\"u66fac7e7\" id=\"u66fac7e7\">Uint8Array</span></code><span data-lake-id=\"ua856bbef\" id=\"ua856bbef\"> 。需要 decode 一下。</span></p><p data-lake-id=\"uf3c29c17\" id=\"uf3c29c17\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20contents%20%3D%20res.outputFiles%5B0%5D.contents%3B%5Cnconst%20decoder%20%3D%20new%20TextDecoder()%3B%5Cnconst%20text%20%3D%20decoder.decode(contents)%3B%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%2291020cb8%22%7D\"></card><p data-lake-id=\"u7a9b54fe\" id=\"u7a9b54fe\"><br></p><h2 data-lake-id=\"72d84f85\" id=\"72d84f85\"><span data-lake-id=\"ud02e863a\" id=\"ud02e863a\">以上最终代码的集合</span></h2><p data-lake-id=\"ue04d860a\" id=\"ue04d860a\"><br></p><p data-lake-id=\"u1f9d4878\" id=\"u1f9d4878\"><span data-lake-id=\"uccc15bcc\" id=\"uccc15bcc\" class=\"lake-fontsize-9\" style=\"color: #d4d4d4; background-color: #1e1e1e\"><br /><br /></span></p><p data-lake-id=\"ue2c5b660\" id=\"ue2c5b660\"><span data-lake-id=\"u99d3c10a\" id=\"u99d3c10a\" class=\"lake-fontsize-9\">/</span></p>",
  "body_draft_lake": "",
  "public": 1,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2023-02-02T09:09:21.000Z",
  "deleted_at": null,
  "created_at": "2022-10-24T01:51:37.000Z",
  "updated_at": "2023-02-02T09:09:21.000Z",
  "published_at": "2023-02-02T09:09:21.000Z",
  "first_published_at": "2023-02-02T09:09:21.229Z",
  "word_count": 879,
  "cover": null,
  "description": "为什么要在浏览器内编译 React ?博客编写时需要实时预览，使用的 MDX 需要经过编译，预览则采用了 iframe 进行预览，所以我需要把 MDX 编译成 JavaScript ，放到 iframe 里。esbuild 怎么跑在浏览器内的 ?esbuild 提供了 wasm 版本，是支持在...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}