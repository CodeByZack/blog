{
  "id": 112806670,
  "slug": "yt3eclnknmv2qkct",
  "title": "React 里引起 rernder 的几种情况",
  "book_id": 231593,
  "book": {
    "id": 231593,
    "type": "Book",
    "slug": "web",
    "name": "WEB",
    "user_id": 284138,
    "description": "前端知识点记录",
    "creator_id": 284138,
    "public": 1,
    "items_count": 58,
    "likes_count": 0,
    "watches_count": 3,
    "content_updated_at": "2023-02-02T09:09:21.426Z",
    "updated_at": "2023-02-02T09:09:21.000Z",
    "created_at": "2019-03-07T05:05:08.000Z",
    "namespace": "zackdk/web",
    "user": {
      "id": 284138,
      "type": "User",
      "login": "zackdk",
      "name": "行一度空山",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1551934932702-d412771d-8d33-4694-9186-a749a3b4e05b.jpeg",
      "books_count": 2,
      "public_books_count": 1,
      "followers_count": 5,
      "following_count": 0,
      "created_at": "2019-03-07T05:02:38.000Z",
      "updated_at": "2023-02-01T12:18:25.000Z",
      "_serializer": "v2.user"
    },
    "_serializer": "v2.book"
  },
  "user_id": 284138,
  "creator": {
    "id": 284138,
    "type": "User",
    "login": "zackdk",
    "name": "行一度空山",
    "description": null,
    "avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1551934932702-d412771d-8d33-4694-9186-a749a3b4e05b.jpeg",
    "books_count": 2,
    "public_books_count": 1,
    "followers_count": 5,
    "following_count": 0,
    "created_at": "2019-03-07T05:02:38.000Z",
    "updated_at": "2023-02-01T12:18:25.000Z",
    "_serializer": "v2.user"
  },
  "format": "lake",
  "body": "---\n\n\nReact 组件的生命周期大概是这样：\n\n`mount -> init-render -> re-render -> unmount`\n\n在线demo。可对照着查看。<br />[rerender-in-react](https://stackblitz.com/edit/rerender-in-react)\n\n由于很久不用类组件了，以下都只针对函数式组件。\n\n<a name=\"3a752774\"></a>\n## 1. props 变动，引起的渲染\n\n此处省略。\n\n<a name=\"838b6c0c\"></a>\n## 2. context 变动，引起的渲染\n\n建议先通读一下官方文档 [React Context](https://reactjs.org/docs/context.html) 。\n\n简单来说， context 是用于组件嵌套过深时，避免一层层传递 props ，传递参数用的。\n\n使用 context ， 需要注意的是：\n\n- 传递给 provider 的 value 值，在两次渲染期间是浅对比，类似于 `Object.is` 的实现。\n- 传递给 value 的值， 即便浅对比变动了，是不会触发 React 的 render 的，需要通过其它方式来触发 render 。\n\n<a name=\"adaf08b6\"></a>\n## 3. 父组件渲染引起的子组件重新渲染\n\n这是平常开发中比较容易忽略的一点，前端现在都是组件嵌套组件，形成一个巨大的组件树， React 只要确认了组件需要 render ， 在其之下的所有子组件都会走一遍 render 。\n\n在如今动则上百个组件的页面里，很容易就会引起某些子组件额外的 render ，造成性能浪费。\n\nReact 提供了两个工具来给开发者手动进行这方面的优化。函数组件的 `React.memo` ， 类组件的 `shouldComponentUpdate` 。\n\n<a name=\"370f0ed1\"></a>\n## 4. 组件 unmount -> mount 引起的渲染\n\n这个场景也不常见， unmount 后，再 mount ，触发渲染是理所应当的。所以问题不在触发了渲染，问题在于什么时候触发的 unmount 。\n\n实际遇到的几个场景都写在demo里了。\n\n1.  `xx && <Comp>` 这种写法比较常见，会触发组件的 unmount , 但不会马上紧接着 mount , 所以一般情况下是没啥问题的。 \n2.  列表里长度不一样或者 key 不一样，导致的 unmount 。此外还要分情况，如果列表前后长度不一样了，会导致卸载或者新增的情况，这一般都是期望的行为。<br />但如果列表前后长度一致，其中某几个 key 变动了，但是组件的类型是一样的。<br />这时候对比前后两轮的 key 值，不存在的 key 对应的组件 unmount ， 新增的 key 对应的组件 mount ， 依旧存在的 key 复用组件实例，触发 render 。 \n3.  组件的引用地址变动，导致 diff 时判定了 unmount，然而实际上也是同一个组件占了这个位置，继而马上 mount 。<br />这种情况比较特别，目前只发现一种情况下会出现，即组件内部声明组件。如下： \n\n```javascript\nexport const UnmountMountPaper3 = () => {\n  const forceUpdate = useForceRender();\n  useLogger('ParentNode');\n\n  const InnerChild = () => {\n    useLogger('InnerChild');\n    const [num, setNum] = React.useState(0);\n\n    return (\n      <div>\n        <div\n          onClick={() => {\n            forceUpdate();\n            setNum((n) => n + 1);\n          }}\n        >\n          click me : {num}\n        </div>\n        <Typography p={1} component=\"p\">\n          InnerChild\n        </Typography>\n      </div>\n    );\n  };\n\n  return (\n    <Paper sx={{ m: 1, width: '100%' }}>\n      <InnerChild />\n      <Button\n        onClick={() => {\n          forceUpdate();\n        }}\n      >\n        触发组件更新\n      </Button>\n    </Paper>\n  );\n};\n```\n\n这种情况容易出问题，比如上面例子中的 click me 按钮 ，点击了应该是把 num + 1 才对，可实际不管点击多少次都是0。<br />这是因为 InnerChild 是 unmount -> mount -> render 这样一个过程。因为走了一遍 mount 过程， num 的值又被初始化为 0 了。\n\n<a name=\"677e6608\"></a>\n## 5. state 变动，引起的渲染\n\n抛开 Class 组件的 forceUpdate 方法，其实某种意义上，可以说 React 里能触发渲染的就只有一种方式，那就是改变 state 。<br />上文中，除了 mount 引起的渲染，就剩下 props 和 context 引起的渲染了，可这两者针对的都是组件，这两者的修改都不会导致 React 的渲染。<br />比如一个组件，你传给 props 或者 context 的 provider 一个任意值，然后你修改这个值，是不会有任何变化的。<br />因为 React 不是响应式的，你修改了值，你想把结果渲染到页面上，你就需要通知 React 走一次 render 过程，而这个通知的方法就是改变 state 。\n\n这也是个人比较喜欢 React 的原因，简洁，不复杂，纯粹。\n\n1.  `setState` 会导致渲染，这个每个人都能理解。 \n2.  因为自定义hook的出现，出现了很多不是那么直接的 `setState` 。 \n   - 比如 demo 里的 forceUpdate 。\n3.  Redux 触发更新的方式。 \n   - Redux 并不直接触发 React 的渲染，触发渲染的是 react-redux 。\n   - react-redux 触发渲染，一个是 Connect 高阶组件，一个是 useSelector 自定义 hook 。\n\n以下摘自 react-redux 7.x 版本的代码:\n\nConnect 最终触发 React 更新的[代码](https://github.com/reduxjs/react-redux/blob/7.x/src/components/connectAdvanced.js#L21)\n\n```typescript\nfunction storeStateUpdatesReducer(state, action) {\n  const [, updateCount] = state\n  return [action.payload, updateCount + 1]\n}\n```\n\nuseSelector 最终触发 React 更新的[代码](https://github.com/reduxjs/react-redux/blob/7.x/src/hooks/useSelector.js#L15)\n\n```typescript\nconst [, forceRender] = useReducer((s) => s + 1, 0)\n```\n\n由上面代码可以看出来， redux 最终通知 React 进行一次渲染，就是通过state的改变来做的。\n\n4. Mobx 触发更新的方式\n\n以下摘自 mobx-react-lite 的[代码](https://github.com/mobxjs/mobx/blob/main/packages/mobx-react-lite/src/useObserver.ts#L32):\n\n```typescript\nconst [, setState] = React.useState()\nconst forceUpdate = () => setState([] as any)\n```\n",
  "body_draft": "",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><hr id=\"mpSKj\" class=\"ne-hr\"><p id=\"ue33692fe\" class=\"ne-p\"><br></p><p id=\"u0b4a5866\" class=\"ne-p\"><span class=\"ne-text\">React 组件的生命周期大概是这样：</span></p><p id=\"u04dcdfd6\" class=\"ne-p\"><br></p><p id=\"ufab60c32\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">mount -&gt; init-render -&gt; re-render -&gt; unmount</span></code></p><p id=\"u426bcc4b\" class=\"ne-p\"><br></p><p id=\"u7f53c604\" class=\"ne-p\"><span class=\"ne-text\">在线demo。可对照着查看。</span></p><p id=\"u267176dc\" class=\"ne-p\"><a href=\"https://stackblitz.com/edit/rerender-in-react\" data-href=\"https://stackblitz.com/edit/rerender-in-react\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">rerender-in-react</span></a><span class=\"ne-text\"></span></p><p id=\"u7bba46e1\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"u82928ab6\" class=\"ne-p\"><span class=\"ne-text\">由于很久不用类组件了，以下都只针对函数式组件。</span></p><p id=\"u9501a051\" class=\"ne-p\"><br></p><h2 id=\"3a752774\"><span class=\"ne-text\">1. props 变动，引起的渲染</span></h2><p id=\"u4fc5bb5b\" class=\"ne-p\"><br></p><p id=\"u863fb65f\" class=\"ne-p\"><span class=\"ne-text\">此处省略。</span></p><p id=\"ub1e0b50a\" class=\"ne-p\"><br></p><h2 id=\"838b6c0c\"><span class=\"ne-text\">2. context 变动，引起的渲染</span></h2><p id=\"u174e782f\" class=\"ne-p\"><br></p><p id=\"udd29a157\" class=\"ne-p\"><span class=\"ne-text\">建议先通读一下官方文档 </span><a href=\"https://reactjs.org/docs/context.html\" data-href=\"https://reactjs.org/docs/context.html\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">React Context</span></a><span class=\"ne-text\"> 。</span></p><p id=\"uf46e2764\" class=\"ne-p\"><br></p><p id=\"u0cffbacc\" class=\"ne-p\"><span class=\"ne-text\">简单来说， context 是用于组件嵌套过深时，避免一层层传递 props ，传递参数用的。</span></p><p id=\"ua1f706e9\" class=\"ne-p\"><br></p><p id=\"uef7e8bfd\" class=\"ne-p\"><span class=\"ne-text\">使用 context ， 需要注意的是：</span></p><p id=\"u23725b38\" class=\"ne-p\"><br></p><ul class=\"ne-ul\"><li id=\"uec7fe2fe\"><span class=\"ne-text\">传递给 provider 的 value 值，在两次渲染期间是浅对比，类似于 </span><code class=\"ne-code\"><span class=\"ne-text\">Object.is</span></code><span class=\"ne-text\"> 的实现。</span></li><li id=\"u3a1bca9f\"><span class=\"ne-text\">传递给 value 的值， 即便浅对比变动了，是不会触发 React 的 render 的，需要通过其它方式来触发 render 。</span></li></ul><p id=\"udbe1e892\" class=\"ne-p\"><br></p><h2 id=\"adaf08b6\"><span class=\"ne-text\">3. 父组件渲染引起的子组件重新渲染</span></h2><p id=\"uec6305c2\" class=\"ne-p\"><br></p><p id=\"u9eedad6d\" class=\"ne-p\"><span class=\"ne-text\">这是平常开发中比较容易忽略的一点，前端现在都是组件嵌套组件，形成一个巨大的组件树， React 只要确认了组件需要 render ， 在其之下的所有子组件都会走一遍 render 。</span></p><p id=\"u51f43a93\" class=\"ne-p\"><br></p><p id=\"u27a89d77\" class=\"ne-p\"><span class=\"ne-text\">在如今动则上百个组件的页面里，很容易就会引起某些子组件额外的 render ，造成性能浪费。</span></p><p id=\"uf5735070\" class=\"ne-p\"><br></p><p id=\"u27c5a90f\" class=\"ne-p\"><span class=\"ne-text\">React 提供了两个工具来给开发者手动进行这方面的优化。函数组件的 </span><code class=\"ne-code\"><span class=\"ne-text\">React.memo</span></code><span class=\"ne-text\"> ， 类组件的 </span><code class=\"ne-code\"><span class=\"ne-text\">shouldComponentUpdate</span></code><span class=\"ne-text\"> 。</span></p><p id=\"u2fb7f307\" class=\"ne-p\"><br></p><h2 id=\"370f0ed1\"><span class=\"ne-text\">4. 组件 unmount -&gt; mount 引起的渲染</span></h2><p id=\"ub41ef4ab\" class=\"ne-p\"><br></p><p id=\"u3ac78318\" class=\"ne-p\"><span class=\"ne-text\">这个场景也不常见， unmount 后，再 mount ，触发渲染是理所应当的。所以问题不在触发了渲染，问题在于什么时候触发的 unmount 。</span></p><p id=\"u562ba556\" class=\"ne-p\"><br></p><p id=\"ub23204b1\" class=\"ne-p\"><span class=\"ne-text\">实际遇到的几个场景都写在demo里了。</span></p><p id=\"u08d9c8cd\" class=\"ne-p\"><br></p><ol class=\"ne-ol\"><li id=\"ua448cc0f\"><span class=\"ne-text\"> </span><code class=\"ne-code\"><span class=\"ne-text\">xx &amp;&amp; &lt;Comp&gt;</span></code><span class=\"ne-text\"> 这种写法比较常见，会触发组件的 unmount , 但不会马上紧接着 mount , 所以一般情况下是没啥问题的。 </span></li><li id=\"ub56a79a5\"><span class=\"ne-text\"> 列表里长度不一样或者 key 不一样，导致的 unmount 。此外还要分情况，如果列表前后长度不一样了，会导致卸载或者新增的情况，这一般都是期望的行为。<br /></span><span class=\"ne-text\">但如果列表前后长度一致，其中某几个 key 变动了，但是组件的类型是一样的。<br /></span><span class=\"ne-text\">这时候对比前后两轮的 key 值，不存在的 key 对应的组件 unmount ， 新增的 key 对应的组件 mount ， 依旧存在的 key 复用组件实例，触发 render 。 </span></li><li id=\"u8aa804b4\"><span class=\"ne-text\"> 组件的引用地址变动，导致 diff 时判定了 unmount，然而实际上也是同一个组件占了这个位置，继而马上 mount 。<br /></span><span class=\"ne-text\">这种情况比较特别，目前只发现一种情况下会出现，即组件内部声明组件。如下： </span></li></ol><p id=\"u64fda4ec\" class=\"ne-p\"><br></p><pre data-language=\"javascript\" id=\"5dc6f3ce\" class=\"ne-codeblock language-javascript\">export const UnmountMountPaper3 = () =&gt; {\n  const forceUpdate = useForceRender();\n  useLogger('ParentNode');\n\n  const InnerChild = () =&gt; {\n    useLogger('InnerChild');\n    const [num, setNum] = React.useState(0);\n\n    return (\n      &lt;div&gt;\n        &lt;div\n          onClick={() =&gt; {\n            forceUpdate();\n            setNum((n) =&gt; n + 1);\n          }}\n        &gt;\n          click me : {num}\n        &lt;/div&gt;\n        &lt;Typography p={1} component=&quot;p&quot;&gt;\n          InnerChild\n        &lt;/Typography&gt;\n      &lt;/div&gt;\n    );\n  };\n\n  return (\n    &lt;Paper sx={{ m: 1, width: '100%' }}&gt;\n      &lt;InnerChild /&gt;\n      &lt;Button\n        onClick={() =&gt; {\n          forceUpdate();\n        }}\n      &gt;\n        触发组件更新\n      &lt;/Button&gt;\n    &lt;/Paper&gt;\n  );\n};</pre><p id=\"u337c47f9\" class=\"ne-p\"><br></p><p id=\"u07e9a385\" class=\"ne-p\"><span class=\"ne-text\">这种情况容易出问题，比如上面例子中的 click me 按钮 ，点击了应该是把 num + 1 才对，可实际不管点击多少次都是0。<br /></span><span class=\"ne-text\">这是因为 InnerChild 是 unmount -&gt; mount -&gt; render 这样一个过程。因为走了一遍 mount 过程， num 的值又被初始化为 0 了。</span></p><p id=\"u7c597925\" class=\"ne-p\"><br></p><h2 id=\"677e6608\"><span class=\"ne-text\">5. state 变动，引起的渲染</span></h2><p id=\"ub50c7467\" class=\"ne-p\"><br></p><p id=\"u5d831222\" class=\"ne-p\"><span class=\"ne-text\">抛开 Class 组件的 forceUpdate 方法，其实某种意义上，可以说 React 里能触发渲染的就只有一种方式，那就是改变 state 。<br /></span><span class=\"ne-text\">上文中，除了 mount 引起的渲染，就剩下 props 和 context 引起的渲染了，可这两者针对的都是组件，这两者的修改都不会导致 React 的渲染。<br /></span><span class=\"ne-text\">比如一个组件，你传给 props 或者 context 的 provider 一个任意值，然后你修改这个值，是不会有任何变化的。<br /></span><span class=\"ne-text\">因为 React 不是响应式的，你修改了值，你想把结果渲染到页面上，你就需要通知 React 走一次 render 过程，而这个通知的方法就是改变 state 。</span></p><p id=\"u6a52fe72\" class=\"ne-p\"><br></p><p id=\"uaca575cd\" class=\"ne-p\"><span class=\"ne-text\">这也是个人比较喜欢 React 的原因，简洁，不复杂，纯粹。</span></p><p id=\"uaf1612ed\" class=\"ne-p\"><br></p><ol class=\"ne-ol\"><li id=\"u83afc1f7\"><span class=\"ne-text\"> </span><code class=\"ne-code\"><span class=\"ne-text\">setState</span></code><span class=\"ne-text\"> 会导致渲染，这个每个人都能理解。 </span></li><li id=\"u5448d92a\"><span class=\"ne-text\"> 因为自定义hook的出现，出现了很多不是那么直接的 </span><code class=\"ne-code\"><span class=\"ne-text\">setState</span></code><span class=\"ne-text\"> 。 </span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"ubf6f5381\"><span class=\"ne-text\">比如 demo 里的 forceUpdate 。</span></li></ul></ul><ol start=\"3\" class=\"ne-ol\"><li id=\"u153dbb2f\"><span class=\"ne-text\"> Redux 触发更新的方式。 </span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u4b275c27\"><span class=\"ne-text\">Redux 并不直接触发 React 的渲染，触发渲染的是 react-redux 。</span></li><li id=\"u9813a4c6\"><span class=\"ne-text\">react-redux 触发渲染，一个是 Connect 高阶组件，一个是 useSelector 自定义 hook 。</span></li></ul></ul><p id=\"u7bb6d387\" class=\"ne-p\"><br></p><p id=\"u5005f741\" class=\"ne-p\"><span class=\"ne-text\">以下摘自 react-redux 7.x 版本的代码:</span></p><p id=\"u19e0326a\" class=\"ne-p\"><br></p><p id=\"ue6c53fc1\" class=\"ne-p\"><span class=\"ne-text\">Connect 最终触发 React 更新的</span><a href=\"https://github.com/reduxjs/react-redux/blob/7.x/src/components/connectAdvanced.js#L21\" data-href=\"https://github.com/reduxjs/react-redux/blob/7.x/src/components/connectAdvanced.js#L21\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">代码</span></a></p><p id=\"u906cf411\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"ec89d7c8\" class=\"ne-codeblock language-typescript\">function storeStateUpdatesReducer(state, action) {\n  const [, updateCount] = state\n  return [action.payload, updateCount + 1]\n}</pre><p id=\"u795e4849\" class=\"ne-p\"><br></p><p id=\"u4e2edb10\" class=\"ne-p\"><span class=\"ne-text\">useSelector 最终触发 React 更新的</span><a href=\"https://github.com/reduxjs/react-redux/blob/7.x/src/hooks/useSelector.js#L15\" data-href=\"https://github.com/reduxjs/react-redux/blob/7.x/src/hooks/useSelector.js#L15\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">代码</span></a></p><p id=\"u1b75b6f6\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"44a8e69a\" class=\"ne-codeblock language-typescript\">const [, forceRender] = useReducer((s) =&gt; s + 1, 0)</pre><p id=\"u81df3e1d\" class=\"ne-p\"><br></p><p id=\"uc7cb277b\" class=\"ne-p\"><span class=\"ne-text\">由上面代码可以看出来， redux 最终通知 React 进行一次渲染，就是通过state的改变来做的。</span></p><p id=\"u81b6780c\" class=\"ne-p\"><br></p><ol start=\"4\" class=\"ne-ol\"><li id=\"ua1313548\"><span class=\"ne-text\">Mobx 触发更新的方式</span></li></ol><p id=\"ufbe9cb21\" class=\"ne-p\"><br></p><p id=\"ub9c886a7\" class=\"ne-p\"><span class=\"ne-text\">以下摘自 mobx-react-lite 的</span><a href=\"https://github.com/mobxjs/mobx/blob/main/packages/mobx-react-lite/src/useObserver.ts#L32\" data-href=\"https://github.com/mobxjs/mobx/blob/main/packages/mobx-react-lite/src/useObserver.ts#L32\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">代码</span></a><span class=\"ne-text\">:</span></p><p id=\"u6b1d4aa3\" class=\"ne-p\"><br></p><pre data-language=\"typescript\" id=\"0c432aeb\" class=\"ne-codeblock language-typescript\">const [, setState] = React.useState()\nconst forceUpdate = () =&gt; setState([] as any)</pre></div>",
  "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"fixed\" /><meta name=\"paragraphSpacing\" content=\"relax\" /><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22mpSKj%22%7D\"></card><p data-lake-id=\"ue33692fe\" id=\"ue33692fe\"><br></p><p data-lake-id=\"u0b4a5866\" id=\"u0b4a5866\"><span data-lake-id=\"u8e5f588a\" id=\"u8e5f588a\">React 组件的生命周期大概是这样：</span></p><p data-lake-id=\"u04dcdfd6\" id=\"u04dcdfd6\"><br></p><p data-lake-id=\"ufab60c32\" id=\"ufab60c32\"><code data-lake-id=\"uafb94ad7\" id=\"uafb94ad7\"><span data-lake-id=\"u2d8d19a0\" id=\"u2d8d19a0\">mount -&gt; init-render -&gt; re-render -&gt; unmount</span></code></p><p data-lake-id=\"u426bcc4b\" id=\"u426bcc4b\"><br></p><p data-lake-id=\"u7f53c604\" id=\"u7f53c604\"><span data-lake-id=\"u9c8c0f38\" id=\"u9c8c0f38\">在线demo。可对照着查看。</span></p><p data-lake-id=\"u267176dc\" id=\"u267176dc\"><a href=\"https://stackblitz.com/edit/rerender-in-react\" target=\"_blank\" data-lake-id=\"u1d5ca373\" id=\"u1d5ca373\"><span data-lake-id=\"u37d3834e\" id=\"u37d3834e\">rerender-in-react</span></a><span data-lake-id=\"u7bc2980d\" id=\"u7bc2980d\">​</span></p><p data-lake-id=\"u7bba46e1\" id=\"u7bba46e1\"><span data-lake-id=\"u38574398\" id=\"u38574398\">​</span><br></p><p data-lake-id=\"u82928ab6\" id=\"u82928ab6\"><span data-lake-id=\"u3f2d1372\" id=\"u3f2d1372\">由于很久不用类组件了，以下都只针对函数式组件。</span></p><p data-lake-id=\"u9501a051\" id=\"u9501a051\"><br></p><h2 data-lake-id=\"3a752774\" id=\"3a752774\"><span data-lake-id=\"u757267bb\" id=\"u757267bb\">1. props 变动，引起的渲染</span></h2><p data-lake-id=\"u4fc5bb5b\" id=\"u4fc5bb5b\"><br></p><p data-lake-id=\"u863fb65f\" id=\"u863fb65f\"><span data-lake-id=\"ua7fb1b5b\" id=\"ua7fb1b5b\">此处省略。</span></p><p data-lake-id=\"ub1e0b50a\" id=\"ub1e0b50a\"><br></p><h2 data-lake-id=\"838b6c0c\" id=\"838b6c0c\"><span data-lake-id=\"u7812a62f\" id=\"u7812a62f\">2. context 变动，引起的渲染</span></h2><p data-lake-id=\"u174e782f\" id=\"u174e782f\"><br></p><p data-lake-id=\"udd29a157\" id=\"udd29a157\"><span data-lake-id=\"uaab98112\" id=\"uaab98112\">建议先通读一下官方文档 </span><a href=\"https://reactjs.org/docs/context.html\" target=\"_blank\" data-lake-id=\"u006fee2b\" id=\"u006fee2b\"><span data-lake-id=\"udb63f3ff\" id=\"udb63f3ff\">React Context</span></a><span data-lake-id=\"ua6a3d288\" id=\"ua6a3d288\"> 。</span></p><p data-lake-id=\"uf46e2764\" id=\"uf46e2764\"><br></p><p data-lake-id=\"u0cffbacc\" id=\"u0cffbacc\"><span data-lake-id=\"u840d68b6\" id=\"u840d68b6\">简单来说， context 是用于组件嵌套过深时，避免一层层传递 props ，传递参数用的。</span></p><p data-lake-id=\"ua1f706e9\" id=\"ua1f706e9\"><br></p><p data-lake-id=\"uef7e8bfd\" id=\"uef7e8bfd\"><span data-lake-id=\"u8fcb902c\" id=\"u8fcb902c\">使用 context ， 需要注意的是：</span></p><p data-lake-id=\"u23725b38\" id=\"u23725b38\"><br></p><ul list=\"uf0d7691f\"><li fid=\"u001ea8fe\" data-lake-id=\"uec7fe2fe\" id=\"uec7fe2fe\"><span data-lake-id=\"u31cc374b\" id=\"u31cc374b\">传递给 provider 的 value 值，在两次渲染期间是浅对比，类似于 </span><code data-lake-id=\"u9c0a4c11\" id=\"u9c0a4c11\"><span data-lake-id=\"ub8cd6f7a\" id=\"ub8cd6f7a\">Object.is</span></code><span data-lake-id=\"u32ae68bc\" id=\"u32ae68bc\"> 的实现。</span></li><li fid=\"u001ea8fe\" data-lake-id=\"u3a1bca9f\" id=\"u3a1bca9f\"><span data-lake-id=\"ue9191cbb\" id=\"ue9191cbb\">传递给 value 的值， 即便浅对比变动了，是不会触发 React 的 render 的，需要通过其它方式来触发 render 。</span></li></ul><p data-lake-id=\"udbe1e892\" id=\"udbe1e892\"><br></p><h2 data-lake-id=\"adaf08b6\" id=\"adaf08b6\"><span data-lake-id=\"u3a34f843\" id=\"u3a34f843\">3. 父组件渲染引起的子组件重新渲染</span></h2><p data-lake-id=\"uec6305c2\" id=\"uec6305c2\"><br></p><p data-lake-id=\"u9eedad6d\" id=\"u9eedad6d\"><span data-lake-id=\"u0b8fd7b7\" id=\"u0b8fd7b7\">这是平常开发中比较容易忽略的一点，前端现在都是组件嵌套组件，形成一个巨大的组件树， React 只要确认了组件需要 render ， 在其之下的所有子组件都会走一遍 render 。</span></p><p data-lake-id=\"u51f43a93\" id=\"u51f43a93\"><br></p><p data-lake-id=\"u27a89d77\" id=\"u27a89d77\"><span data-lake-id=\"u81881c58\" id=\"u81881c58\">在如今动则上百个组件的页面里，很容易就会引起某些子组件额外的 render ，造成性能浪费。</span></p><p data-lake-id=\"uf5735070\" id=\"uf5735070\"><br></p><p data-lake-id=\"u27c5a90f\" id=\"u27c5a90f\"><span data-lake-id=\"u10df3d6a\" id=\"u10df3d6a\">React 提供了两个工具来给开发者手动进行这方面的优化。函数组件的 </span><code data-lake-id=\"u53218a99\" id=\"u53218a99\"><span data-lake-id=\"u9512d45e\" id=\"u9512d45e\">React.memo</span></code><span data-lake-id=\"u5e5d15e8\" id=\"u5e5d15e8\"> ， 类组件的 </span><code data-lake-id=\"u3c75605c\" id=\"u3c75605c\"><span data-lake-id=\"u79ab54ad\" id=\"u79ab54ad\">shouldComponentUpdate</span></code><span data-lake-id=\"u9ce94bf8\" id=\"u9ce94bf8\"> 。</span></p><p data-lake-id=\"u2fb7f307\" id=\"u2fb7f307\"><br></p><h2 data-lake-id=\"370f0ed1\" id=\"370f0ed1\"><span data-lake-id=\"ue0c16b96\" id=\"ue0c16b96\">4. 组件 unmount -&gt; mount 引起的渲染</span></h2><p data-lake-id=\"ub41ef4ab\" id=\"ub41ef4ab\"><br></p><p data-lake-id=\"u3ac78318\" id=\"u3ac78318\"><span data-lake-id=\"u2d4e5dbe\" id=\"u2d4e5dbe\">这个场景也不常见， unmount 后，再 mount ，触发渲染是理所应当的。所以问题不在触发了渲染，问题在于什么时候触发的 unmount 。</span></p><p data-lake-id=\"u562ba556\" id=\"u562ba556\"><br></p><p data-lake-id=\"ub23204b1\" id=\"ub23204b1\"><span data-lake-id=\"u789e3aa3\" id=\"u789e3aa3\">实际遇到的几个场景都写在demo里了。</span></p><p data-lake-id=\"u08d9c8cd\" id=\"u08d9c8cd\"><br></p><ol list=\"u6bb57afc\"><li fid=\"u4d20571a\" data-lake-id=\"ua448cc0f\" id=\"ua448cc0f\"><span data-lake-id=\"ua32baef2\" id=\"ua32baef2\"> </span><code data-lake-id=\"u15ef49a1\" id=\"u15ef49a1\"><span data-lake-id=\"u3c85d80a\" id=\"u3c85d80a\">xx &amp;&amp; &lt;Comp&gt;</span></code><span data-lake-id=\"u8d74ad98\" id=\"u8d74ad98\"> 这种写法比较常见，会触发组件的 unmount , 但不会马上紧接着 mount , 所以一般情况下是没啥问题的。 </span></li><li fid=\"u4d20571a\" data-lake-id=\"ub56a79a5\" id=\"ub56a79a5\"><span data-lake-id=\"u1698ed63\" id=\"u1698ed63\"> 列表里长度不一样或者 key 不一样，导致的 unmount 。此外还要分情况，如果列表前后长度不一样了，会导致卸载或者新增的情况，这一般都是期望的行为。<br /></span><span data-lake-id=\"u778f7843\" id=\"u778f7843\">但如果列表前后长度一致，其中某几个 key 变动了，但是组件的类型是一样的。<br /></span><span data-lake-id=\"ue7c52342\" id=\"ue7c52342\">这时候对比前后两轮的 key 值，不存在的 key 对应的组件 unmount ， 新增的 key 对应的组件 mount ， 依旧存在的 key 复用组件实例，触发 render 。 </span></li><li fid=\"u4d20571a\" data-lake-id=\"u8aa804b4\" id=\"u8aa804b4\"><span data-lake-id=\"u6ec28fcd\" id=\"u6ec28fcd\"> 组件的引用地址变动，导致 diff 时判定了 unmount，然而实际上也是同一个组件占了这个位置，继而马上 mount 。<br /></span><span data-lake-id=\"u96de09a1\" id=\"u96de09a1\">这种情况比较特别，目前只发现一种情况下会出现，即组件内部声明组件。如下： </span></li></ol><p data-lake-id=\"u64fda4ec\" id=\"u64fda4ec\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22export%20const%20UnmountMountPaper3%20%3D%20()%20%3D%3E%20%7B%5Cn%20%20const%20forceUpdate%20%3D%20useForceRender()%3B%5Cn%20%20useLogger('ParentNode')%3B%5Cn%5Cn%20%20const%20InnerChild%20%3D%20()%20%3D%3E%20%7B%5Cn%20%20%20%20useLogger('InnerChild')%3B%5Cn%20%20%20%20const%20%5Bnum%2C%20setNum%5D%20%3D%20React.useState(0)%3B%5Cn%5Cn%20%20%20%20return%20(%5Cn%20%20%20%20%20%20%3Cdiv%3E%5Cn%20%20%20%20%20%20%20%20%3Cdiv%5Cn%20%20%20%20%20%20%20%20%20%20onClick%3D%7B()%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20forceUpdate()%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20setNum((n)%20%3D%3E%20n%20%2B%201)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%7D%7D%5Cn%20%20%20%20%20%20%20%20%3E%5Cn%20%20%20%20%20%20%20%20%20%20click%20me%20%3A%20%7Bnum%7D%5Cn%20%20%20%20%20%20%20%20%3C%2Fdiv%3E%5Cn%20%20%20%20%20%20%20%20%3CTypography%20p%3D%7B1%7D%20component%3D%5C%22p%5C%22%3E%5Cn%20%20%20%20%20%20%20%20%20%20InnerChild%5Cn%20%20%20%20%20%20%20%20%3C%2FTypography%3E%5Cn%20%20%20%20%20%20%3C%2Fdiv%3E%5Cn%20%20%20%20)%3B%5Cn%20%20%7D%3B%5Cn%5Cn%20%20return%20(%5Cn%20%20%20%20%3CPaper%20sx%3D%7B%7B%20m%3A%201%2C%20width%3A%20'100%25'%20%7D%7D%3E%5Cn%20%20%20%20%20%20%3CInnerChild%20%2F%3E%5Cn%20%20%20%20%20%20%3CButton%5Cn%20%20%20%20%20%20%20%20onClick%3D%7B()%20%3D%3E%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20forceUpdate()%3B%5Cn%20%20%20%20%20%20%20%20%7D%7D%5Cn%20%20%20%20%20%20%3E%5Cn%20%20%20%20%20%20%20%20%E8%A7%A6%E5%8F%91%E7%BB%84%E4%BB%B6%E6%9B%B4%E6%96%B0%5Cn%20%20%20%20%20%20%3C%2FButton%3E%5Cn%20%20%20%20%3C%2FPaper%3E%5Cn%20%20)%3B%5Cn%7D%3B%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%225dc6f3ce%22%7D\"></card><p data-lake-id=\"u337c47f9\" id=\"u337c47f9\"><br></p><p data-lake-id=\"u07e9a385\" id=\"u07e9a385\"><span data-lake-id=\"ud4aa6b36\" id=\"ud4aa6b36\">这种情况容易出问题，比如上面例子中的 click me 按钮 ，点击了应该是把 num + 1 才对，可实际不管点击多少次都是0。<br /></span><span data-lake-id=\"u490d6a1a\" id=\"u490d6a1a\">这是因为 InnerChild 是 unmount -&gt; mount -&gt; render 这样一个过程。因为走了一遍 mount 过程， num 的值又被初始化为 0 了。</span></p><p data-lake-id=\"u7c597925\" id=\"u7c597925\"><br></p><h2 data-lake-id=\"677e6608\" id=\"677e6608\"><span data-lake-id=\"ueb22ba4f\" id=\"ueb22ba4f\">5. state 变动，引起的渲染</span></h2><p data-lake-id=\"ub50c7467\" id=\"ub50c7467\"><br></p><p data-lake-id=\"u5d831222\" id=\"u5d831222\"><span data-lake-id=\"u3729be2c\" id=\"u3729be2c\">抛开 Class 组件的 forceUpdate 方法，其实某种意义上，可以说 React 里能触发渲染的就只有一种方式，那就是改变 state 。<br /></span><span data-lake-id=\"u1e0c22d9\" id=\"u1e0c22d9\">上文中，除了 mount 引起的渲染，就剩下 props 和 context 引起的渲染了，可这两者针对的都是组件，这两者的修改都不会导致 React 的渲染。<br /></span><span data-lake-id=\"u811e93c2\" id=\"u811e93c2\">比如一个组件，你传给 props 或者 context 的 provider 一个任意值，然后你修改这个值，是不会有任何变化的。<br /></span><span data-lake-id=\"ufea11769\" id=\"ufea11769\">因为 React 不是响应式的，你修改了值，你想把结果渲染到页面上，你就需要通知 React 走一次 render 过程，而这个通知的方法就是改变 state 。</span></p><p data-lake-id=\"u6a52fe72\" id=\"u6a52fe72\"><br></p><p data-lake-id=\"uaca575cd\" id=\"uaca575cd\"><span data-lake-id=\"u5bb8dccb\" id=\"u5bb8dccb\">这也是个人比较喜欢 React 的原因，简洁，不复杂，纯粹。</span></p><p data-lake-id=\"uaf1612ed\" id=\"uaf1612ed\"><br></p><ol list=\"u8541706d\"><li fid=\"u9e6991c8\" data-lake-id=\"u83afc1f7\" id=\"u83afc1f7\"><span data-lake-id=\"uc39bd787\" id=\"uc39bd787\"> </span><code data-lake-id=\"uf5db2bad\" id=\"uf5db2bad\"><span data-lake-id=\"u0e62c040\" id=\"u0e62c040\">setState</span></code><span data-lake-id=\"u58753107\" id=\"u58753107\"> 会导致渲染，这个每个人都能理解。 </span></li><li fid=\"u9e6991c8\" data-lake-id=\"u5448d92a\" id=\"u5448d92a\"><span data-lake-id=\"u5e03e60d\" id=\"u5e03e60d\"> 因为自定义hook的出现，出现了很多不是那么直接的 </span><code data-lake-id=\"ud1bc3c3a\" id=\"ud1bc3c3a\"><span data-lake-id=\"ua21a6416\" id=\"ua21a6416\">setState</span></code><span data-lake-id=\"ue72b1d77\" id=\"ue72b1d77\"> 。 </span></li></ol><ul list=\"uac62ce3c\" data-lake-indent=\"1\"><li fid=\"u23de07d6\" data-lake-id=\"ubf6f5381\" id=\"ubf6f5381\"><span data-lake-id=\"u8aa67b67\" id=\"u8aa67b67\">比如 demo 里的 forceUpdate 。</span></li></ul><ol list=\"u7ce41b64\" start=\"3\"><li fid=\"uf83e1e88\" data-lake-id=\"u153dbb2f\" id=\"u153dbb2f\"><span data-lake-id=\"u197c77fb\" id=\"u197c77fb\"> Redux 触发更新的方式。 </span></li></ol><ul list=\"u36c23c23\" data-lake-indent=\"1\"><li fid=\"u6e6c7c17\" data-lake-id=\"u4b275c27\" id=\"u4b275c27\"><span data-lake-id=\"u894e708b\" id=\"u894e708b\">Redux 并不直接触发 React 的渲染，触发渲染的是 react-redux 。</span></li><li fid=\"u6e6c7c17\" data-lake-id=\"u9813a4c6\" id=\"u9813a4c6\"><span data-lake-id=\"u097e47cd\" id=\"u097e47cd\">react-redux 触发渲染，一个是 Connect 高阶组件，一个是 useSelector 自定义 hook 。</span></li></ul><p data-lake-id=\"u7bb6d387\" id=\"u7bb6d387\"><br></p><p data-lake-id=\"u5005f741\" id=\"u5005f741\"><span data-lake-id=\"u9dd1d486\" id=\"u9dd1d486\">以下摘自 react-redux 7.x 版本的代码:</span></p><p data-lake-id=\"u19e0326a\" id=\"u19e0326a\"><br></p><p data-lake-id=\"ue6c53fc1\" id=\"ue6c53fc1\"><span data-lake-id=\"u21b0299a\" id=\"u21b0299a\">Connect 最终触发 React 更新的</span><a href=\"https://github.com/reduxjs/react-redux/blob/7.x/src/components/connectAdvanced.js#L21\" target=\"_blank\" data-lake-id=\"u11d8cef1\" id=\"u11d8cef1\"><span data-lake-id=\"u9ac75e4b\" id=\"u9ac75e4b\">代码</span></a></p><p data-lake-id=\"u906cf411\" id=\"u906cf411\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22typescript%22%2C%22code%22%3A%22function%20storeStateUpdatesReducer(state%2C%20action)%20%7B%5Cn%20%20const%20%5B%2C%20updateCount%5D%20%3D%20state%5Cn%20%20return%20%5Baction.payload%2C%20updateCount%20%2B%201%5D%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%22ec89d7c8%22%7D\"></card><p data-lake-id=\"u795e4849\" id=\"u795e4849\"><br></p><p data-lake-id=\"u4e2edb10\" id=\"u4e2edb10\"><span data-lake-id=\"u3b2e8d32\" id=\"u3b2e8d32\">useSelector 最终触发 React 更新的</span><a href=\"https://github.com/reduxjs/react-redux/blob/7.x/src/hooks/useSelector.js#L15\" target=\"_blank\" data-lake-id=\"u528e1943\" id=\"u528e1943\"><span data-lake-id=\"uf4a30320\" id=\"uf4a30320\">代码</span></a></p><p data-lake-id=\"u1b75b6f6\" id=\"u1b75b6f6\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22typescript%22%2C%22code%22%3A%22const%20%5B%2C%20forceRender%5D%20%3D%20useReducer((s)%20%3D%3E%20s%20%2B%201%2C%200)%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%2244a8e69a%22%7D\"></card><p data-lake-id=\"u81df3e1d\" id=\"u81df3e1d\"><br></p><p data-lake-id=\"uc7cb277b\" id=\"uc7cb277b\"><span data-lake-id=\"u00c89021\" id=\"u00c89021\">由上面代码可以看出来， redux 最终通知 React 进行一次渲染，就是通过state的改变来做的。</span></p><p data-lake-id=\"u81b6780c\" id=\"u81b6780c\"><br></p><ol list=\"ub0ef4a81\" start=\"4\"><li fid=\"ufe9237de\" data-lake-id=\"ua1313548\" id=\"ua1313548\"><span data-lake-id=\"ub785294f\" id=\"ub785294f\">Mobx 触发更新的方式</span></li></ol><p data-lake-id=\"ufbe9cb21\" id=\"ufbe9cb21\"><br></p><p data-lake-id=\"ub9c886a7\" id=\"ub9c886a7\"><span data-lake-id=\"uaa5d8f44\" id=\"uaa5d8f44\">以下摘自 mobx-react-lite 的</span><a href=\"https://github.com/mobxjs/mobx/blob/main/packages/mobx-react-lite/src/useObserver.ts#L32\" target=\"_blank\" data-lake-id=\"u0d8555fa\" id=\"u0d8555fa\"><span data-lake-id=\"u661907af\" id=\"u661907af\">代码</span></a><span data-lake-id=\"u30e0c932\" id=\"u30e0c932\">:</span></p><p data-lake-id=\"u6b1d4aa3\" id=\"u6b1d4aa3\"><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22typescript%22%2C%22code%22%3A%22const%20%5B%2C%20setState%5D%20%3D%20React.useState()%5Cnconst%20forceUpdate%20%3D%20()%20%3D%3E%20setState(%5B%5D%20as%20any)%22%2C%22autoWrap%22%3Afalse%2C%22lineNumbers%22%3Atrue%2C%22heightLimit%22%3Atrue%2C%22collapsed%22%3Afalse%2C%22hideToolbar%22%3Afalse%2C%22name%22%3A%22%22%2C%22tabSize%22%3Anull%2C%22indentWithTab%22%3Afalse%2C%22lightLines%22%3A%5B%5D%2C%22foldLines%22%3A%5B%5D%2C%22theme%22%3A%22Github%20Light%22%2C%22id%22%3A%220c432aeb%22%7D\"></card>",
  "body_draft_lake": "",
  "public": 0,
  "status": 1,
  "view_status": 0,
  "read_status": 1,
  "likes_count": 0,
  "comments_count": 0,
  "content_updated_at": "2023-01-31T01:57:37.000Z",
  "deleted_at": null,
  "created_at": "2023-01-31T01:55:40.000Z",
  "updated_at": "2023-01-31T01:57:38.000Z",
  "published_at": "2023-01-31T01:57:37.000Z",
  "first_published_at": "2023-01-31T01:57:37.388Z",
  "word_count": 1347,
  "cover": null,
  "description": "React 组件的生命周期大概是这样：mount -> init-render -> re-render -> unmount在线demo。可对照着查看。rerender-in-react由于很久不用类组件了，以下都只针对函数式组件。1. props 变动，引起的渲染此处省略。2. conte...",
  "custom_description": null,
  "hits": 0,
  "_serializer": "v2.doc_detail"
}