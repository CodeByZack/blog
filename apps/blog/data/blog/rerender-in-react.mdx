---
title: React 里引起 rernder 的几种情况
publishedAt: '2022-08-02 13:35:45'
updatedAt: '2022-08-03 16:31:27'
summary: React 里引起 rernder 的几种情况
---

React 组件的生命周期大概是这样：

`mount -> init-render -> re-render -> unmount`

在线demo。可对照着查看。

<iframe src="https://stackblitz.com/edit/rerender-in-react?devToolsHeight=33&embed=1&file=child.tsx"></iframe>

由于很久不用类组件了，以下都只针对函数式组件。

## 1. props 变动，引起的渲染

此处省略。

## 2. context 变动，引起的渲染

建议先通读一下官方文档 [React Context](https://reactjs.org/docs/context.html) 。

简单来说， context 是用于组件嵌套过深时，避免一层层传递 props ，传递参数用的。

使用 context ， 需要注意的是：

- 传递给 provider 的 value 值，在两次渲染期间是浅对比，类似于 `Object.is` 的实现。
- 传递给 value 的值， 即便浅对比变动了，是不会触发 React 的 render 的，需要通过其它方式来触发 render 。

## 3. 父组件渲染引起的子组件重新渲染

这是平常开发中比较容易忽略的一点，前端现在都是组件嵌套组件，形成一个巨大的组件树， React 只要确认了组件需要 render ， 在其之下的所有子组件都会走一遍 render 。

在如今动则上百个组件的页面里，很容易就会引起某些子组件额外的 render ，造成性能浪费。 

React 提供了两个工具来给开发者手动进行这方面的优化。函数组件的 `React.memo` ， 类组件的 `shouldComponentUpdate` 。

## 4. 组件 unmount -> mount 引起的渲染

这个场景也不常见， unmount 后，再 mount ，触发渲染是理所应当的。所以问题不在触发了渲染，问题在于什么时候触发的 unmount 。

实际遇到的几个场景都写在demo里了。

1. `xx && <Comp>` 这种写法比较常见，会触发组件的 unmount , 但不会马上紧接着 mount , 所以一般情况下是没啥问题的。

2. 列表里长度不一样或者 key 不一样，导致的 unmount 。此外还要分情况，如果列表前后长度不一样了，会导致卸载或者新增的情况，这一般都是期望的行为。
但如果列表前后长度一致，其中某几个 key 变动了，但是组件的类型是一样的。
这时候对比前后两轮的 key 值，不存在的 key 对应的组件 unmount ， 新增的 key 对应的组件 mount ， 依旧存在的 key 复用组件实例，触发 render 。

3. 组件的引用地址变动，导致 diff 时判定了 unmount，然而实际上也是同一个组件占了这个位置，继而马上 mount 。
这种情况比较特别，目前只发现一种情况下会出现，即组件内部声明组件。如下：

```jsx



```



## 5. state 变动，引起的渲染

   自定义hook，三方状态管理
